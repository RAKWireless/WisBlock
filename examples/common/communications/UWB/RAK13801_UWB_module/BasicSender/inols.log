






Started logging.

<<<
Content-Length: 3141

{"jsonrpc":"2.0","id":0,"method":"initialize","params":{"processId":37416,"clientInfo":{"name":"vscode","version":"1.53.2"},"rootPath":"d:\\RAK-Work\\20210707\\RAK13801\\RAK13801-UWB-Library\\examples\\BasicSender","rootUri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender","capabilities":{"workspace":{"applyEdit":true,"workspaceEdit":{"documentChanges":true,"resourceOperations":["create","rename","delete"],"failureHandling":"textOnlyTransactional"},"didChangeConfiguration":{"dynamicRegistration":true},"didChangeWatchedFiles":{"dynamicRegistration":true},"symbol":{"dynamicRegistration":true,"symbolKind":{"valueSet":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]}},"executeCommand":{"dynamicRegistration":true},"configuration":true,"workspaceFolders":true},"textDocument":{"publishDiagnostics":{"relatedInformation":true,"versionSupport":false,"tagSupport":{"valueSet":[1,2]}},"synchronization":{"dynamicRegistration":true,"willSave":true,"willSaveWaitUntil":true,"didSave":true},"completion":{"dynamicRegistration":true,"contextSupport":true,"completionItem":{"snippetSupport":true,"commitCharactersSupport":true,"documentationFormat":["markdown","plaintext"],"deprecatedSupport":true,"preselectSupport":true,"tagSupport":{"valueSet":[1]}},"completionItemKind":{"valueSet":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25]}},"hover":{"dynamicRegistration":true,"contentFormat":["markdown","plaintext"]},"signatureHelp":{"dynamicRegistration":true,"signatureInformation":{"documentationFormat":["markdown","plaintext"],"parameterInformation":{"labelOffsetSupport":true}},"contextSupport":true},"definition":{"dynamicRegistration":true,"linkSupport":true},"references":{"dynamicRegistration":true},"documentHighlight":{"dynamicRegistration":true},"documentSymbol":{"dynamicRegistration":true,"symbolKind":{"valueSet":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]},"hierarchicalDocumentSymbolSupport":true},"codeAction":{"dynamicRegistration":true,"isPreferredSupport":true,"codeActionLiteralSupport":{"codeActionKind":{"valueSet":["","quickfix","refactor","refactor.extract","refactor.inline","refactor.rewrite","source","source.organizeImports"]}}},"codeLens":{"dynamicRegistration":true},"formatting":{"dynamicRegistration":true},"rangeFormatting":{"dynamicRegistration":true},"onTypeFormatting":{"dynamicRegistration":true},"rename":{"dynamicRegistration":true,"prepareSupport":true},"documentLink":{"dynamicRegistration":true,"tooltipSupport":true},"typeDefinition":{"dynamicRegistration":true,"linkSupport":true},"implementation":{"dynamicRegistration":true,"linkSupport":true},"colorProvider":{"dynamicRegistration":true},"foldingRange":{"dynamicRegistration":true,"rangeLimit":5000,"lineFoldingOnly":true},"declaration":{"dynamicRegistration":true,"linkSupport":true},"selectionRange":{"dynamicRegistration":true}},"window":{"workDoneProgress":true}},"initializationOptions":{},"trace":"off","workspaceFolders":[{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender","name":"BasicSender"}]}}
>>>
Content-Length: 598

{"id":0,"result":{"capabilities":{"textDocumentSync":2,"hoverProvider":true,"completionProvider":{"triggerCharacters":[".","\u003e",":"]},"signatureHelpProvider":{"triggerCharacters":["(",","]},"definitionProvider":true,"documentHighlightProvider":true,"documentSymbolProvider":true,"workspaceSymbolProvider":true,"codeActionProvider":true,"documentFormattingProvider":true,"documentRangeFormattingProvider":true,"documentOnTypeFormattingProvider":{"firstTriggerCharacter":"\n"},"renameProvider":false,"executeCommandProvider":{"commands":["clangd.applyFix","clangd.applyTweak"]}}},"jsonrpc":"2.0"}
<<<
Content-Length: 52

{"jsonrpc":"2.0","method":"initialized","params":{}}Content-Length: 3485

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino","languageId":"cpp","version":1,"text":"/**\r\n   @file BasicSender.ino\r\n   @author rakwireless.com\r\n   @brief UWB transmit sender\r\n   @version 0.1\r\n   @date 2022-1-28\r\n   @copyright Copyright (c) 2020\r\n**/\r\n\r\n#include <SPI.h>\r\n#include <DW1000Ng.hpp>\r\n\r\nconst uint8_t PIN_SS = SS; // spi select pin\r\n\r\n\r\n// DEBUG packet sent status and count\r\nvolatile unsigned long delaySent = 0;\r\nint16_t sentNum = 0; // todo check int type\r\n\r\ndevice_configuration_t DEFAULT_CONFIG = {\r\n    false,\r\n    true,\r\n    true,\r\n    true,\r\n    false,\r\n    SFDMode::STANDARD_SFD,\r\n    Channel::CHANNEL_5,\r\n    DataRate::RATE_850KBPS,\r\n    PulseFrequency::FREQ_16MHZ,\r\n    PreambleLength::LEN_256,\r\n    PreambleCode::CODE_3\r\n};\r\n\r\nvoid setup() {\r\n  pinMode(WB_IO2, OUTPUT);\r\n  digitalWrite(WB_IO2, HIGH); //Turn on the power switch\r\n  delay(300);\r\n  time_t serial_timeout = millis();\r\n  // DEBUG monitoring\r\n  Serial.begin(115200);\r\n  while (!Serial)\r\n  {\r\n    if ((millis() - serial_timeout) < 5000)\r\n    {\r\n      delay(100);\r\n    }\r\n    else\r\n    {\r\n      break;\r\n    }\r\n  }\r\n  Serial.println(F(\"### DW1000Ng-arduino-sender-test ###\"));\r\n  // initialize the driver\r\n  DW1000Ng::initializeNoInterrupt(PIN_SS);\r\n  Serial.println(F(\"DW1000Ng initialized ...\"));\r\n\r\n  DW1000Ng::applyConfiguration(DEFAULT_CONFIG);\r\n\t//DW1000Ng::applyInterruptConfiguration(DEFAULT_INTERRUPT_CONFIG);\r\n\r\n  DW1000Ng::setDeviceAddress(5);\r\n  DW1000Ng::setNetworkId(10);\r\n\r\n  DW1000Ng::setAntennaDelay(16436);\r\n  Serial.println(F(\"Committed configuration ...\"));\r\n  // DEBUG chip info and registers pretty printed\r\n  char msg[128];\r\n  DW1000Ng::getPrintableDeviceIdentifier(msg);\r\n  Serial.print(\"Device ID: \"); Serial.println(msg);\r\n  DW1000Ng::getPrintableExtendedUniqueIdentifier(msg);\r\n  Serial.print(\"Unique ID: \"); Serial.println(msg);\r\n  DW1000Ng::getPrintableNetworkIdAndShortAddress(msg);\r\n  Serial.print(\"Network ID & Device Address: \"); Serial.println(msg);\r\n  DW1000Ng::getPrintableDeviceMode(msg);\r\n  Serial.print(\"Device mode: \"); Serial.println(msg);\r\n  // attach callback for (successfully) sent messages\r\n  //DW1000Ng::attachSentHandler(handleSent);\r\n  // start a transmission\r\n  transmit();\r\n}\r\n\r\n/*\r\nvoid handleSent() {\r\n  // status change on sent success\r\n  sentAck = true;\r\n}\r\n*/\r\n\r\nvoid transmit() {\r\n  // transmit some data\r\n  Serial.print(\"Transmitting packet ... #\"); Serial.println(sentNum);\r\n  String msg = \"Hello DW1000Ng, it's #\"; msg += sentNum;\r\n  DW1000Ng::setTransmitData(msg);\r\n  // delay sending the message for the given amount\r\n  delay(1000);\r\n  DW1000Ng::startTransmit(TransmitMode::IMMEDIATE);\r\n  delaySent = millis();\r\n  while(!DW1000Ng::isTransmitDone()) {\r\n\r\n  }\r\n  sentNum++;\r\n  DW1000Ng::clearTransmitStatus();\r\n}\r\n\r\nvoid loop() {\r\n    transmit();\r\n    // update and print some information about the sent message\r\n    Serial.print(\"ARDUINO delay sent [ms] ... \"); Serial.println(millis() - delaySent);\r\n    uint64_t newSentTime = DW1000Ng::getTransmitTimestamp();\r\n    Serial.print(\"Processed packet ... #\"); Serial.println(sentNum);\r\n    Serial.println();\r\n}\r\n"}}}Content-Length: 296

{"jsonrpc":"2.0","id":1,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}Content-Length: 197

{"jsonrpc":"2.0","id":2,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"}}}Content-Length: 62

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":2}}Content-Length: 197

{"jsonrpc":"2.0","id":3,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"}}}Content-Length: 62

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":1}}
>>>
Content-Length: 111

{"method":"window/workDoneProgress/create","params":{"token":"backgroundIndexProgress"},"id":0,"jsonrpc":"2.0"}Content-Length: 36

{"id":1,"result":[],"jsonrpc":"2.0"}Content-Length: 607

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino","diagnostics":[{"range":{"start":{"line":37,"character":2},"end":{"line":37,"character":8}},"severity":1,"code":"unknown_typename_suggest","source":"clang","message":"Unknown type name 'time_t'; did you mean 'size_t'? (fix available)\n\nc:\\Users\\ltp\\AppData\\Local\\Programs\\Arduino IDE\\resources\\app\\node_modules\\arduino-ide-extension\\build\\lib\\clang\\12.0.0\\include\\stddef.h:46:23:\nnote: 'size_t' declared here"}]},"jsonrpc":"2.0"}Content-Length: 1386

{"id":2,"result":[{"name":"PIN_SS","kind":13,"range":{"start":{"line":12,"character":0},"end":{"line":12,"character":25}},"selectionRange":{"start":{"line":12,"character":14},"end":{"line":12,"character":20}}},{"name":"delaySent","kind":13,"range":{"start":{"line":16,"character":0},"end":{"line":16,"character":36}},"selectionRange":{"start":{"line":16,"character":23},"end":{"line":16,"character":32}}},{"name":"sentNum","kind":13,"range":{"start":{"line":17,"character":0},"end":{"line":17,"character":19}},"selectionRange":{"start":{"line":17,"character":8},"end":{"line":17,"character":15}}},{"name":"DEFAULT_CONFIG","kind":13,"range":{"start":{"line":19,"character":0},"end":{"line":31,"character":1}},"selectionRange":{"start":{"line":19,"character":23},"end":{"line":19,"character":37}}},{"name":"setup","kind":12,"range":{"start":{"line":33,"character":0},"end":{"line":78,"character":1}},"selectionRange":{"start":{"line":33,"character":5},"end":{"line":33,"character":10}}},{"name":"transmit","kind":12,"range":{"start":{"line":87,"character":0},"end":{"line":101,"character":1}},"selectionRange":{"start":{"line":87,"character":5},"end":{"line":87,"character":13}}},{"name":"loop","kind":12,"range":{"start":{"line":103,"character":0},"end":{"line":110,"character":1}},"selectionRange":{"start":{"line":103,"character":5},"end":{"line":103,"character":9}}}],"jsonrpc":"2.0"}Content-Length: 1386

{"id":3,"result":[{"name":"PIN_SS","kind":13,"range":{"start":{"line":12,"character":0},"end":{"line":12,"character":25}},"selectionRange":{"start":{"line":12,"character":14},"end":{"line":12,"character":20}}},{"name":"delaySent","kind":13,"range":{"start":{"line":16,"character":0},"end":{"line":16,"character":36}},"selectionRange":{"start":{"line":16,"character":23},"end":{"line":16,"character":32}}},{"name":"sentNum","kind":13,"range":{"start":{"line":17,"character":0},"end":{"line":17,"character":19}},"selectionRange":{"start":{"line":17,"character":8},"end":{"line":17,"character":15}}},{"name":"DEFAULT_CONFIG","kind":13,"range":{"start":{"line":19,"character":0},"end":{"line":31,"character":1}},"selectionRange":{"start":{"line":19,"character":23},"end":{"line":19,"character":37}}},{"name":"setup","kind":12,"range":{"start":{"line":33,"character":0},"end":{"line":78,"character":1}},"selectionRange":{"start":{"line":33,"character":5},"end":{"line":33,"character":10}}},{"name":"transmit","kind":12,"range":{"start":{"line":87,"character":0},"end":{"line":101,"character":1}},"selectionRange":{"start":{"line":87,"character":5},"end":{"line":87,"character":13}}},{"name":"loop","kind":12,"range":{"start":{"line":103,"character":0},"end":{"line":110,"character":1}},"selectionRange":{"start":{"line":103,"character":5},"end":{"line":103,"character":9}}}],"jsonrpc":"2.0"}
<<<
Content-Length: 38

{"jsonrpc":"2.0","id":0,"result":null}
>>>
Content-Length: 143

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"title":"indexing","percentage":0,"kind":"begin"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"1/36","percentage":2.7777777777777777,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"2/36","percentage":5.555555555555555,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"3/36","percentage":8.333333333333334,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"3/36","percentage":8.333333333333334,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"4/36","percentage":11.11111111111111,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"4/36","percentage":11.11111111111111,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"5/36","percentage":13.88888888888889,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"5/36","percentage":13.88888888888889,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"6/36","percentage":16.666666666666668,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"6/36","percentage":16.666666666666668,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"7/36","percentage":19.444444444444443,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"7/36","percentage":19.444444444444443,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"8/36","percentage":22.22222222222222,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"8/36","percentage":22.22222222222222,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 143

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"9/36","percentage":25,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 143

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"9/36","percentage":25,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"10/36","percentage":27.77777777777778,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"10/36","percentage":27.77777777777778,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"11/36","percentage":30.555555555555557,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"11/36","percentage":30.555555555555557,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"12/36","percentage":33.333333333333336,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"12/36","percentage":33.333333333333336,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"13/36","percentage":36.111111111111114,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"13/36","percentage":36.111111111111114,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"14/36","percentage":38.888888888888886,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"14/36","percentage":38.888888888888886,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"15/36","percentage":41.666666666666664,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"15/36","percentage":41.666666666666664,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"16/36","percentage":44.44444444444444,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"16/36","percentage":44.44444444444444,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"17/36","percentage":47.22222222222222,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"17/36","percentage":47.22222222222222,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 144

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"18/36","percentage":50,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 144

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"18/36","percentage":50,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"19/36","percentage":52.77777777777778,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"19/36","percentage":52.77777777777778,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"20/36","percentage":55.55555555555556,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"20/36","percentage":55.55555555555556,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"21/36","percentage":58.333333333333336,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"22/36","percentage":61.111111111111114,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"22/36","percentage":61.111111111111114,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"23/36","percentage":63.888888888888886,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"23/36","percentage":63.888888888888886,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"24/36","percentage":66.66666666666667,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"24/36","percentage":66.66666666666667,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"25/36","percentage":69.44444444444444,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"26/36","percentage":72.22222222222223,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"26/36","percentage":72.22222222222223,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 144

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"27/36","percentage":75,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 144

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"27/36","percentage":75,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"28/36","percentage":77.77777777777777,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"28/36","percentage":77.77777777777777,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"29/36","percentage":80.55555555555556,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"29/36","percentage":80.55555555555556,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"30/36","percentage":83.33333333333333,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"31/36","percentage":86.11111111111111,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"32/36","percentage":88.88888888888889,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"32/36","percentage":88.88888888888889,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"33/36","percentage":91.66666666666667,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"34/36","percentage":94.44444444444444,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"35/36","percentage":97.22222222222223,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 107

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"kind":"end"}},"jsonrpc":"2.0"}
<<<
Content-Length: 226

{"jsonrpc":"2.0","id":4,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":94,"character":30}}}
>>>
Content-Length: 268

{"id":4,"result":{"contents":{"kind":"markdown","value":"### enum `TransmitMode`  \n\n---\nValue = `IMMEDIATE (0)`  \n\n---\n```cpp\nenum class TransmitMode : int {}\n```"},"range":{"start":{"line":94,"character":26},"end":{"line":94,"character":38}}},"jsonrpc":"2.0"}
<<<
Content-Length: 226

{"jsonrpc":"2.0","id":5,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":94,"character":28}}}
>>>
Content-Length: 268

{"id":5,"result":{"contents":{"kind":"markdown","value":"### enum `TransmitMode`  \n\n---\nValue = `IMMEDIATE (0)`  \n\n---\n```cpp\nenum class TransmitMode : int {}\n```"},"range":{"start":{"line":94,"character":26},"end":{"line":94,"character":38}}},"jsonrpc":"2.0"}
<<<
Content-Length: 227

{"jsonrpc":"2.0","id":6,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":105,"character":23}}}
>>>
Content-Length: 38

{"id":6,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 239

{"jsonrpc":"2.0","id":7,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":105,"character":23}}}
>>>
Content-Length: 36

{"id":7,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 300

{"jsonrpc":"2.0","id":8,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"range":{"start":{"line":105,"character":0},"end":{"line":106,"character":0}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 36

{"id":8,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 302

{"jsonrpc":"2.0","id":9,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"range":{"start":{"line":103,"character":13},"end":{"line":103,"character":13}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 36

{"id":9,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 227

{"jsonrpc":"2.0","id":10,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":94,"character":39}}}
>>>
Content-Length: 269

{"id":10,"result":{"contents":{"kind":"markdown","value":"### enum `TransmitMode`  \n\n---\nValue = `IMMEDIATE (0)`  \n\n---\n```cpp\nenum class TransmitMode : int {}\n```"},"range":{"start":{"line":94,"character":38},"end":{"line":94,"character":40}}},"jsonrpc":"2.0"}
<<<
Content-Length: 227

{"jsonrpc":"2.0","id":11,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":94,"character":40}}}
>>>
Content-Length: 317

{"id":11,"result":{"contents":{"kind":"markdown","value":"### enumerator `IMMEDIATE`  \n\n---\nType: `enum TransmitMode`  \nValue = `0`  \nPassed by reference as mode  \n\n---\n```cpp\n// In TransmitMode\nIMMEDIATE\n```"},"range":{"start":{"line":94,"character":40},"end":{"line":94,"character":49}}},"jsonrpc":"2.0"}
<<<
Content-Length: 227

{"jsonrpc":"2.0","id":12,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":89,"character":29}}}
>>>
Content-Length: 39

{"id":12,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 59

{"jsonrpc":"2.0","id":13,"method":"shutdown","params":null}
>>>
Content-Length: 39

{"id":13,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 47

{"jsonrpc":"2.0","method":"exit","params":null}






Started logging.

<<<
Content-Length: 3141

{"jsonrpc":"2.0","id":0,"method":"initialize","params":{"processId":37416,"clientInfo":{"name":"vscode","version":"1.53.2"},"rootPath":"d:\\RAK-Work\\20210707\\RAK13801\\RAK13801-UWB-Library\\examples\\BasicSender","rootUri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender","capabilities":{"workspace":{"applyEdit":true,"workspaceEdit":{"documentChanges":true,"resourceOperations":["create","rename","delete"],"failureHandling":"textOnlyTransactional"},"didChangeConfiguration":{"dynamicRegistration":true},"didChangeWatchedFiles":{"dynamicRegistration":true},"symbol":{"dynamicRegistration":true,"symbolKind":{"valueSet":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]}},"executeCommand":{"dynamicRegistration":true},"configuration":true,"workspaceFolders":true},"textDocument":{"publishDiagnostics":{"relatedInformation":true,"versionSupport":false,"tagSupport":{"valueSet":[1,2]}},"synchronization":{"dynamicRegistration":true,"willSave":true,"willSaveWaitUntil":true,"didSave":true},"completion":{"dynamicRegistration":true,"contextSupport":true,"completionItem":{"snippetSupport":true,"commitCharactersSupport":true,"documentationFormat":["markdown","plaintext"],"deprecatedSupport":true,"preselectSupport":true,"tagSupport":{"valueSet":[1]}},"completionItemKind":{"valueSet":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25]}},"hover":{"dynamicRegistration":true,"contentFormat":["markdown","plaintext"]},"signatureHelp":{"dynamicRegistration":true,"signatureInformation":{"documentationFormat":["markdown","plaintext"],"parameterInformation":{"labelOffsetSupport":true}},"contextSupport":true},"definition":{"dynamicRegistration":true,"linkSupport":true},"references":{"dynamicRegistration":true},"documentHighlight":{"dynamicRegistration":true},"documentSymbol":{"dynamicRegistration":true,"symbolKind":{"valueSet":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]},"hierarchicalDocumentSymbolSupport":true},"codeAction":{"dynamicRegistration":true,"isPreferredSupport":true,"codeActionLiteralSupport":{"codeActionKind":{"valueSet":["","quickfix","refactor","refactor.extract","refactor.inline","refactor.rewrite","source","source.organizeImports"]}}},"codeLens":{"dynamicRegistration":true},"formatting":{"dynamicRegistration":true},"rangeFormatting":{"dynamicRegistration":true},"onTypeFormatting":{"dynamicRegistration":true},"rename":{"dynamicRegistration":true,"prepareSupport":true},"documentLink":{"dynamicRegistration":true,"tooltipSupport":true},"typeDefinition":{"dynamicRegistration":true,"linkSupport":true},"implementation":{"dynamicRegistration":true,"linkSupport":true},"colorProvider":{"dynamicRegistration":true},"foldingRange":{"dynamicRegistration":true,"rangeLimit":5000,"lineFoldingOnly":true},"declaration":{"dynamicRegistration":true,"linkSupport":true},"selectionRange":{"dynamicRegistration":true}},"window":{"workDoneProgress":true}},"initializationOptions":{},"trace":"off","workspaceFolders":[{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender","name":"BasicSender"}]}}
>>>
Content-Length: 598

{"id":0,"result":{"capabilities":{"textDocumentSync":2,"hoverProvider":true,"completionProvider":{"triggerCharacters":[".","\u003e",":"]},"signatureHelpProvider":{"triggerCharacters":["(",","]},"definitionProvider":true,"documentHighlightProvider":true,"documentSymbolProvider":true,"workspaceSymbolProvider":true,"codeActionProvider":true,"documentFormattingProvider":true,"documentRangeFormattingProvider":true,"documentOnTypeFormattingProvider":{"firstTriggerCharacter":"\n"},"renameProvider":false,"executeCommandProvider":{"commands":["clangd.applyFix","clangd.applyTweak"]}}},"jsonrpc":"2.0"}
<<<
Content-Length: 52

{"jsonrpc":"2.0","method":"initialized","params":{}}Content-Length: 3485

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino","languageId":"cpp","version":1,"text":"/**\r\n   @file BasicSender.ino\r\n   @author rakwireless.com\r\n   @brief UWB transmit sender\r\n   @version 0.1\r\n   @date 2022-1-28\r\n   @copyright Copyright (c) 2020\r\n**/\r\n\r\n#include <SPI.h>\r\n#include <DW1000Ng.hpp>\r\n\r\nconst uint8_t PIN_SS = SS; // spi select pin\r\n\r\n\r\n// DEBUG packet sent status and count\r\nvolatile unsigned long delaySent = 0;\r\nint16_t sentNum = 0; // todo check int type\r\n\r\ndevice_configuration_t DEFAULT_CONFIG = {\r\n    false,\r\n    true,\r\n    true,\r\n    true,\r\n    false,\r\n    SFDMode::STANDARD_SFD,\r\n    Channel::CHANNEL_5,\r\n    DataRate::RATE_850KBPS,\r\n    PulseFrequency::FREQ_16MHZ,\r\n    PreambleLength::LEN_256,\r\n    PreambleCode::CODE_3\r\n};\r\n\r\nvoid setup() {\r\n  pinMode(WB_IO2, OUTPUT);\r\n  digitalWrite(WB_IO2, HIGH); //Turn on the power switch\r\n  delay(300);\r\n  time_t serial_timeout = millis();\r\n  // DEBUG monitoring\r\n  Serial.begin(115200);\r\n  while (!Serial)\r\n  {\r\n    if ((millis() - serial_timeout) < 5000)\r\n    {\r\n      delay(100);\r\n    }\r\n    else\r\n    {\r\n      break;\r\n    }\r\n  }\r\n  Serial.println(F(\"### DW1000Ng-arduino-sender-test ###\"));\r\n  // initialize the driver\r\n  DW1000Ng::initializeNoInterrupt(PIN_SS);\r\n  Serial.println(F(\"DW1000Ng initialized ...\"));\r\n\r\n  DW1000Ng::applyConfiguration(DEFAULT_CONFIG);\r\n\t//DW1000Ng::applyInterruptConfiguration(DEFAULT_INTERRUPT_CONFIG);\r\n\r\n  DW1000Ng::setDeviceAddress(5);\r\n  DW1000Ng::setNetworkId(10);\r\n\r\n  DW1000Ng::setAntennaDelay(16436);\r\n  Serial.println(F(\"Committed configuration ...\"));\r\n  // DEBUG chip info and registers pretty printed\r\n  char msg[128];\r\n  DW1000Ng::getPrintableDeviceIdentifier(msg);\r\n  Serial.print(\"Device ID: \"); Serial.println(msg);\r\n  DW1000Ng::getPrintableExtendedUniqueIdentifier(msg);\r\n  Serial.print(\"Unique ID: \"); Serial.println(msg);\r\n  DW1000Ng::getPrintableNetworkIdAndShortAddress(msg);\r\n  Serial.print(\"Network ID & Device Address: \"); Serial.println(msg);\r\n  DW1000Ng::getPrintableDeviceMode(msg);\r\n  Serial.print(\"Device mode: \"); Serial.println(msg);\r\n  // attach callback for (successfully) sent messages\r\n  //DW1000Ng::attachSentHandler(handleSent);\r\n  // start a transmission\r\n  transmit();\r\n}\r\n\r\n/*\r\nvoid handleSent() {\r\n  // status change on sent success\r\n  sentAck = true;\r\n}\r\n*/\r\n\r\nvoid transmit() {\r\n  // transmit some data\r\n  Serial.print(\"Transmitting packet ... #\"); Serial.println(sentNum);\r\n  String msg = \"Hello DW1000Ng, it's #\"; msg += sentNum;\r\n  DW1000Ng::setTransmitData(msg);\r\n  // delay sending the message for the given amount\r\n  delay(1000);\r\n  DW1000Ng::startTransmit(TransmitMode::IMMEDIATE);\r\n  delaySent = millis();\r\n  while(!DW1000Ng::isTransmitDone()) {\r\n\r\n  }\r\n  sentNum++;\r\n  DW1000Ng::clearTransmitStatus();\r\n}\r\n\r\nvoid loop() {\r\n    transmit();\r\n    // update and print some information about the sent message\r\n    Serial.print(\"ARDUINO delay sent [ms] ... \"); Serial.println(millis() - delaySent);\r\n    uint64_t newSentTime = DW1000Ng::getTransmitTimestamp();\r\n    Serial.print(\"Processed packet ... #\"); Serial.println(sentNum);\r\n    Serial.println();\r\n}\r\n"}}}Content-Length: 302

{"jsonrpc":"2.0","id":1,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"range":{"start":{"line":103,"character":13},"end":{"line":103,"character":13}},"context":{"diagnostics":[]}}}Content-Length: 226

{"jsonrpc":"2.0","id":2,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":94,"character":25}}}Content-Length: 62

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":2}}Content-Length: 58

{"jsonrpc":"2.0","id":3,"method":"shutdown","params":null}Content-Length: 62

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":1}}
>>>
Content-Length: 111

{"method":"window/workDoneProgress/create","params":{"token":"backgroundIndexProgress"},"id":0,"jsonrpc":"2.0"}Content-Length: 36

{"id":1,"result":[],"jsonrpc":"2.0"}Content-Length: 983

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino","diagnostics":[{"range":{"start":{"line":34,"character":10},"end":{"line":34,"character":16}},"severity":1,"code":"undeclared_var_use","source":"clang","message":"Use of undeclared identifier 'WB_IO2'"},{"range":{"start":{"line":35,"character":15},"end":{"line":35,"character":21}},"severity":1,"code":"undeclared_var_use","source":"clang","message":"Use of undeclared identifier 'WB_IO2'"},{"range":{"start":{"line":37,"character":2},"end":{"line":37,"character":8}},"severity":1,"code":"unknown_typename_suggest","source":"clang","message":"Unknown type name 'time_t'; did you mean 'size_t'? (fix available)\n\nc:\\Users\\ltp\\AppData\\Local\\Programs\\Arduino IDE\\resources\\app\\node_modules\\arduino-ide-extension\\build\\lib\\clang\\12.0.0\\include\\stddef.h:46:23:\nnote: 'size_t' declared here"}]},"jsonrpc":"2.0"}Content-Length: 482

{"id":2,"result":{"contents":{"kind":"markdown","value":"### function `startTransmit`  \n\n---\nâ†’ `void`  \nParameters:  \n- `enum TransmitMode mode = TransmitMode::IMMEDIATE`\n\nSets the device in transmission mode  \n@param [in] mode IMMEDIATE or DELAYED transmission  \n\n---\n```cpp\n// In namespace DW1000Ng\nvoid startTransmit(TransmitMode mode = TransmitMode::IMMEDIATE)\n```"},"range":{"start":{"line":94,"character":12},"end":{"line":94,"character":25}}},"jsonrpc":"2.0"}Content-Length: 38

{"id":3,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 153

{"jsonrpc":"2.0","id":0,"error":{"code":-32603,"message":"Request window/workDoneProgress/create failed with message: Language client is not ready yet"}}Content-Length: 47

{"jsonrpc":"2.0","method":"exit","params":null}
>>>
Content-Length: 111

{"method":"window/workDoneProgress/create","params":{"token":"backgroundIndexProgress"},"id":1,"jsonrpc":"2.0"}






Started logging.

<<<
Content-Length: 3141

{"jsonrpc":"2.0","id":0,"method":"initialize","params":{"processId":37416,"clientInfo":{"name":"vscode","version":"1.53.2"},"rootPath":"d:\\RAK-Work\\20210707\\RAK13801\\RAK13801-UWB-Library\\examples\\BasicSender","rootUri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender","capabilities":{"workspace":{"applyEdit":true,"workspaceEdit":{"documentChanges":true,"resourceOperations":["create","rename","delete"],"failureHandling":"textOnlyTransactional"},"didChangeConfiguration":{"dynamicRegistration":true},"didChangeWatchedFiles":{"dynamicRegistration":true},"symbol":{"dynamicRegistration":true,"symbolKind":{"valueSet":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]}},"executeCommand":{"dynamicRegistration":true},"configuration":true,"workspaceFolders":true},"textDocument":{"publishDiagnostics":{"relatedInformation":true,"versionSupport":false,"tagSupport":{"valueSet":[1,2]}},"synchronization":{"dynamicRegistration":true,"willSave":true,"willSaveWaitUntil":true,"didSave":true},"completion":{"dynamicRegistration":true,"contextSupport":true,"completionItem":{"snippetSupport":true,"commitCharactersSupport":true,"documentationFormat":["markdown","plaintext"],"deprecatedSupport":true,"preselectSupport":true,"tagSupport":{"valueSet":[1]}},"completionItemKind":{"valueSet":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25]}},"hover":{"dynamicRegistration":true,"contentFormat":["markdown","plaintext"]},"signatureHelp":{"dynamicRegistration":true,"signatureInformation":{"documentationFormat":["markdown","plaintext"],"parameterInformation":{"labelOffsetSupport":true}},"contextSupport":true},"definition":{"dynamicRegistration":true,"linkSupport":true},"references":{"dynamicRegistration":true},"documentHighlight":{"dynamicRegistration":true},"documentSymbol":{"dynamicRegistration":true,"symbolKind":{"valueSet":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]},"hierarchicalDocumentSymbolSupport":true},"codeAction":{"dynamicRegistration":true,"isPreferredSupport":true,"codeActionLiteralSupport":{"codeActionKind":{"valueSet":["","quickfix","refactor","refactor.extract","refactor.inline","refactor.rewrite","source","source.organizeImports"]}}},"codeLens":{"dynamicRegistration":true},"formatting":{"dynamicRegistration":true},"rangeFormatting":{"dynamicRegistration":true},"onTypeFormatting":{"dynamicRegistration":true},"rename":{"dynamicRegistration":true,"prepareSupport":true},"documentLink":{"dynamicRegistration":true,"tooltipSupport":true},"typeDefinition":{"dynamicRegistration":true,"linkSupport":true},"implementation":{"dynamicRegistration":true,"linkSupport":true},"colorProvider":{"dynamicRegistration":true},"foldingRange":{"dynamicRegistration":true,"rangeLimit":5000,"lineFoldingOnly":true},"declaration":{"dynamicRegistration":true,"linkSupport":true},"selectionRange":{"dynamicRegistration":true}},"window":{"workDoneProgress":true}},"initializationOptions":{},"trace":"off","workspaceFolders":[{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender","name":"BasicSender"}]}}
>>>
Content-Length: 598

{"id":0,"result":{"capabilities":{"textDocumentSync":2,"hoverProvider":true,"completionProvider":{"triggerCharacters":[".","\u003e",":"]},"signatureHelpProvider":{"triggerCharacters":["(",","]},"definitionProvider":true,"documentHighlightProvider":true,"documentSymbolProvider":true,"workspaceSymbolProvider":true,"codeActionProvider":true,"documentFormattingProvider":true,"documentRangeFormattingProvider":true,"documentOnTypeFormattingProvider":{"firstTriggerCharacter":"\n"},"renameProvider":false,"executeCommandProvider":{"commands":["clangd.applyFix","clangd.applyTweak"]}}},"jsonrpc":"2.0"}
<<<
Content-Length: 52

{"jsonrpc":"2.0","method":"initialized","params":{}}Content-Length: 3485

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino","languageId":"cpp","version":1,"text":"/**\r\n   @file BasicSender.ino\r\n   @author rakwireless.com\r\n   @brief UWB transmit sender\r\n   @version 0.1\r\n   @date 2022-1-28\r\n   @copyright Copyright (c) 2020\r\n**/\r\n\r\n#include <SPI.h>\r\n#include <DW1000Ng.hpp>\r\n\r\nconst uint8_t PIN_SS = SS; // spi select pin\r\n\r\n\r\n// DEBUG packet sent status and count\r\nvolatile unsigned long delaySent = 0;\r\nint16_t sentNum = 0; // todo check int type\r\n\r\ndevice_configuration_t DEFAULT_CONFIG = {\r\n    false,\r\n    true,\r\n    true,\r\n    true,\r\n    false,\r\n    SFDMode::STANDARD_SFD,\r\n    Channel::CHANNEL_5,\r\n    DataRate::RATE_850KBPS,\r\n    PulseFrequency::FREQ_16MHZ,\r\n    PreambleLength::LEN_256,\r\n    PreambleCode::CODE_3\r\n};\r\n\r\nvoid setup() {\r\n  pinMode(WB_IO2, OUTPUT);\r\n  digitalWrite(WB_IO2, HIGH); //Turn on the power switch\r\n  delay(300);\r\n  time_t serial_timeout = millis();\r\n  // DEBUG monitoring\r\n  Serial.begin(115200);\r\n  while (!Serial)\r\n  {\r\n    if ((millis() - serial_timeout) < 5000)\r\n    {\r\n      delay(100);\r\n    }\r\n    else\r\n    {\r\n      break;\r\n    }\r\n  }\r\n  Serial.println(F(\"### DW1000Ng-arduino-sender-test ###\"));\r\n  // initialize the driver\r\n  DW1000Ng::initializeNoInterrupt(PIN_SS);\r\n  Serial.println(F(\"DW1000Ng initialized ...\"));\r\n\r\n  DW1000Ng::applyConfiguration(DEFAULT_CONFIG);\r\n\t//DW1000Ng::applyInterruptConfiguration(DEFAULT_INTERRUPT_CONFIG);\r\n\r\n  DW1000Ng::setDeviceAddress(5);\r\n  DW1000Ng::setNetworkId(10);\r\n\r\n  DW1000Ng::setAntennaDelay(16436);\r\n  Serial.println(F(\"Committed configuration ...\"));\r\n  // DEBUG chip info and registers pretty printed\r\n  char msg[128];\r\n  DW1000Ng::getPrintableDeviceIdentifier(msg);\r\n  Serial.print(\"Device ID: \"); Serial.println(msg);\r\n  DW1000Ng::getPrintableExtendedUniqueIdentifier(msg);\r\n  Serial.print(\"Unique ID: \"); Serial.println(msg);\r\n  DW1000Ng::getPrintableNetworkIdAndShortAddress(msg);\r\n  Serial.print(\"Network ID & Device Address: \"); Serial.println(msg);\r\n  DW1000Ng::getPrintableDeviceMode(msg);\r\n  Serial.print(\"Device mode: \"); Serial.println(msg);\r\n  // attach callback for (successfully) sent messages\r\n  //DW1000Ng::attachSentHandler(handleSent);\r\n  // start a transmission\r\n  transmit();\r\n}\r\n\r\n/*\r\nvoid handleSent() {\r\n  // status change on sent success\r\n  sentAck = true;\r\n}\r\n*/\r\n\r\nvoid transmit() {\r\n  // transmit some data\r\n  Serial.print(\"Transmitting packet ... #\"); Serial.println(sentNum);\r\n  String msg = \"Hello DW1000Ng, it's #\"; msg += sentNum;\r\n  DW1000Ng::setTransmitData(msg);\r\n  // delay sending the message for the given amount\r\n  delay(1000);\r\n  DW1000Ng::startTransmit(TransmitMode::IMMEDIATE);\r\n  delaySent = millis();\r\n  while(!DW1000Ng::isTransmitDone()) {\r\n\r\n  }\r\n  sentNum++;\r\n  DW1000Ng::clearTransmitStatus();\r\n}\r\n\r\nvoid loop() {\r\n    transmit();\r\n    // update and print some information about the sent message\r\n    Serial.print(\"ARDUINO delay sent [ms] ... \"); Serial.println(millis() - delaySent);\r\n    uint64_t newSentTime = DW1000Ng::getTransmitTimestamp();\r\n    Serial.print(\"Processed packet ... #\"); Serial.println(sentNum);\r\n    Serial.println();\r\n}\r\n"}}}Content-Length: 302

{"jsonrpc":"2.0","id":1,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"range":{"start":{"line":103,"character":13},"end":{"line":103,"character":13}},"context":{"diagnostics":[]}}}Content-Length: 226

{"jsonrpc":"2.0","id":2,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":92,"character":39}}}Content-Length: 62

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":2}}Content-Length: 226

{"jsonrpc":"2.0","id":3,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":92,"character":39}}}Content-Length: 62

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":3}}
>>>
Content-Length: 111

{"method":"window/workDoneProgress/create","params":{"token":"backgroundIndexProgress"},"id":0,"jsonrpc":"2.0"}Content-Length: 607

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino","diagnostics":[{"range":{"start":{"line":37,"character":2},"end":{"line":37,"character":8}},"severity":1,"code":"unknown_typename_suggest","source":"clang","message":"Unknown type name 'time_t'; did you mean 'size_t'? (fix available)\n\nc:\\Users\\ltp\\AppData\\Local\\Programs\\Arduino IDE\\resources\\app\\node_modules\\arduino-ide-extension\\build\\lib\\clang\\12.0.0\\include\\stddef.h:46:23:\nnote: 'size_t' declared here"}]},"jsonrpc":"2.0"}Content-Length: 36

{"id":1,"result":[],"jsonrpc":"2.0"}Content-Length: 38

{"id":2,"result":null,"jsonrpc":"2.0"}Content-Length: 38

{"id":3,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 38

{"jsonrpc":"2.0","id":0,"result":null}
>>>
Content-Length: 143

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"title":"indexing","percentage":0,"kind":"begin"}},"jsonrpc":"2.0"}Content-Length: 143

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"3/100","percentage":3,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 143

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"4/100","percentage":4,"kind":"report"}},"jsonrpc":"2.0"}
<<<
Content-Length: 302

{"jsonrpc":"2.0","id":4,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"range":{"start":{"line":103,"character":13},"end":{"line":103,"character":13}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 36

{"id":4,"result":[],"jsonrpc":"2.0"}Content-Length: 143

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"5/100","percentage":5,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 143

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"6/100","percentage":6,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 143

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"7/100","percentage":7,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 143

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"8/100","percentage":8,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 143

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"9/100","percentage":9,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"10/100","percentage":10,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"11/100","percentage":11,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"12/100","percentage":12,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"13/100","percentage":13,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"14/100","percentage":14,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"15/100","percentage":15,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"16/100","percentage":16,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"17/100","percentage":17,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"18/100","percentage":18,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"18/100","percentage":18,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"19/100","percentage":19,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"20/100","percentage":20,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"20/100","percentage":20,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"21/100","percentage":21,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"21/100","percentage":21,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"22/100","percentage":22,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"22/100","percentage":22,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"23/100","percentage":23,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"23/100","percentage":23,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"24/100","percentage":24,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"25/100","percentage":25,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"25/100","percentage":25,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"26/100","percentage":26,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"27/100","percentage":27,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"27/100","percentage":27,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"28/100","percentage":28,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"28/100","percentage":28,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"29/100","percentage":29,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"30/100","percentage":30,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"31/100","percentage":31,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"32/100","percentage":32,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"33/100","percentage":33,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"34/100","percentage":34,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"34/100","percentage":34,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"35/100","percentage":35,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"36/100","percentage":36,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"37/100","percentage":37,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"38/100","percentage":38,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"39/100","percentage":39,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"40/100","percentage":40,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"40/100","percentage":40,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"42/100","percentage":42,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"43/100","percentage":43,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"44/100","percentage":44,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"44/100","percentage":44,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"45/100","percentage":45,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"45/100","percentage":45,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"46/100","percentage":46,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"46/100","percentage":46,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"47/100","percentage":47,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"47/100","percentage":47,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"48/100","percentage":48,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"49/100","percentage":49,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"50/100","percentage":50,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"50/100","percentage":50,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"51/100","percentage":51,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"51/100","percentage":51,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"52/100","percentage":52,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"52/100","percentage":52,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"53/100","percentage":53,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"53/100","percentage":53,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"54/100","percentage":54,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"54/100","percentage":54,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"55/100","percentage":55,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"55/100","percentage":55,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"56/100","percentage":56,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"56/100","percentage":56,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"57/100","percentage":57,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"57/100","percentage":57,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"58/100","percentage":58,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"59/100","percentage":59,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"59/100","percentage":59,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"60/100","percentage":60,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"61/100","percentage":61,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"62/100","percentage":62,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"62/100","percentage":62,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"63/100","percentage":63,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"64/100","percentage":64,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"64/100","percentage":64,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"65/100","percentage":65,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"65/100","percentage":65,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"66/100","percentage":66,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"66/100","percentage":66,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"67/100","percentage":67,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"68/100","percentage":68,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"68/100","percentage":68,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"69/100","percentage":69,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"69/100","percentage":69,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"70/100","percentage":70,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"70/100","percentage":70,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"71/100","percentage":71,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"72/100","percentage":72,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"72/100","percentage":72,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"73/100","percentage":73,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"73/100","percentage":73,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"74/100","percentage":74,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"74/100","percentage":74,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"75/100","percentage":75,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"76/100","percentage":76,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"77/100","percentage":77,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"77/100","percentage":77,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"78/100","percentage":78,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"78/100","percentage":78,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"79/100","percentage":79,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"79/100","percentage":79,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"80/100","percentage":80,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"80/100","percentage":80,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"81/100","percentage":81,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"82/100","percentage":82,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"83/100","percentage":83,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"83/100","percentage":83,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"84/100","percentage":84,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"84/100","percentage":84,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"85/100","percentage":85,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"85/100","percentage":85,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"86/100","percentage":86,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"86/100","percentage":86,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"87/100","percentage":87,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"87/100","percentage":87,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"88/100","percentage":88,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"88/100","percentage":88,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"89/100","percentage":89,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"89/100","percentage":89,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"90/100","percentage":90,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"91/100","percentage":91,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"91/100","percentage":91,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"92/100","percentage":92,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"93/100","percentage":93,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"93/100","percentage":93,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"94/100","percentage":94,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"94/100","percentage":94,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"95/100","percentage":95,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"95/100","percentage":95,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"96/100","percentage":96,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"96/100","percentage":96,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"97/100","percentage":97,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"98/100","percentage":98,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 145

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"99/100","percentage":99,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 107

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"kind":"end"}},"jsonrpc":"2.0"}
<<<
Content-Length: 226

{"jsonrpc":"2.0","id":5,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":91,"character":20}}}
>>>
Content-Length: 483

{"id":5,"result":{"contents":{"kind":"markdown","value":"### function `setTransmitData`  \n\n---\nâ†’ `void`  \nParameters:  \n- `const String \u0026 data`\n\nSets the transmission bytes inside the tx buffer of the DW1000 based on the input string  \n@param [in] data the string to transmit  \n\n---\n```cpp\n// In namespace DW1000Ng\nvoid setTransmitData(const String \u0026data)\n```"},"range":{"start":{"line":91,"character":12},"end":{"line":91,"character":27}}},"jsonrpc":"2.0"}
<<<
Content-Length: 226

{"jsonrpc":"2.0","id":6,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":75,"character":35}}}
>>>
Content-Length: 38

{"id":6,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 226

{"jsonrpc":"2.0","id":7,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":90,"character":22}}}
>>>
Content-Length: 38

{"id":7,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 226

{"jsonrpc":"2.0","id":8,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":90,"character":26}}}
>>>
Content-Length: 38

{"id":8,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 226

{"jsonrpc":"2.0","id":9,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":96,"character":19}}}
>>>
Content-Length: 282

{"id":9,"result":{"contents":{"kind":"markdown","value":"### function `isTransmitDone`  \n\n---\nâ†’ `boolean`  \n\n---\n```cpp\n// In namespace DW1000Ng\nboolean isTransmitDone()\n```"},"range":{"start":{"line":96,"character":19},"end":{"line":96,"character":33}}},"jsonrpc":"2.0"}
<<<
Content-Length: 59

{"jsonrpc":"2.0","id":10,"method":"shutdown","params":null}
>>>
Content-Length: 39

{"id":10,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 47

{"jsonrpc":"2.0","method":"exit","params":null}






Started logging.

<<<
Content-Length: 3141

{"jsonrpc":"2.0","id":0,"method":"initialize","params":{"processId":37416,"clientInfo":{"name":"vscode","version":"1.53.2"},"rootPath":"d:\\RAK-Work\\20210707\\RAK13801\\RAK13801-UWB-Library\\examples\\BasicSender","rootUri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender","capabilities":{"workspace":{"applyEdit":true,"workspaceEdit":{"documentChanges":true,"resourceOperations":["create","rename","delete"],"failureHandling":"textOnlyTransactional"},"didChangeConfiguration":{"dynamicRegistration":true},"didChangeWatchedFiles":{"dynamicRegistration":true},"symbol":{"dynamicRegistration":true,"symbolKind":{"valueSet":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]}},"executeCommand":{"dynamicRegistration":true},"configuration":true,"workspaceFolders":true},"textDocument":{"publishDiagnostics":{"relatedInformation":true,"versionSupport":false,"tagSupport":{"valueSet":[1,2]}},"synchronization":{"dynamicRegistration":true,"willSave":true,"willSaveWaitUntil":true,"didSave":true},"completion":{"dynamicRegistration":true,"contextSupport":true,"completionItem":{"snippetSupport":true,"commitCharactersSupport":true,"documentationFormat":["markdown","plaintext"],"deprecatedSupport":true,"preselectSupport":true,"tagSupport":{"valueSet":[1]}},"completionItemKind":{"valueSet":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25]}},"hover":{"dynamicRegistration":true,"contentFormat":["markdown","plaintext"]},"signatureHelp":{"dynamicRegistration":true,"signatureInformation":{"documentationFormat":["markdown","plaintext"],"parameterInformation":{"labelOffsetSupport":true}},"contextSupport":true},"definition":{"dynamicRegistration":true,"linkSupport":true},"references":{"dynamicRegistration":true},"documentHighlight":{"dynamicRegistration":true},"documentSymbol":{"dynamicRegistration":true,"symbolKind":{"valueSet":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]},"hierarchicalDocumentSymbolSupport":true},"codeAction":{"dynamicRegistration":true,"isPreferredSupport":true,"codeActionLiteralSupport":{"codeActionKind":{"valueSet":["","quickfix","refactor","refactor.extract","refactor.inline","refactor.rewrite","source","source.organizeImports"]}}},"codeLens":{"dynamicRegistration":true},"formatting":{"dynamicRegistration":true},"rangeFormatting":{"dynamicRegistration":true},"onTypeFormatting":{"dynamicRegistration":true},"rename":{"dynamicRegistration":true,"prepareSupport":true},"documentLink":{"dynamicRegistration":true,"tooltipSupport":true},"typeDefinition":{"dynamicRegistration":true,"linkSupport":true},"implementation":{"dynamicRegistration":true,"linkSupport":true},"colorProvider":{"dynamicRegistration":true},"foldingRange":{"dynamicRegistration":true,"rangeLimit":5000,"lineFoldingOnly":true},"declaration":{"dynamicRegistration":true,"linkSupport":true},"selectionRange":{"dynamicRegistration":true}},"window":{"workDoneProgress":true}},"initializationOptions":{},"trace":"off","workspaceFolders":[{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender","name":"BasicSender"}]}}
>>>
Content-Length: 598

{"id":0,"result":{"capabilities":{"textDocumentSync":2,"hoverProvider":true,"completionProvider":{"triggerCharacters":[".","\u003e",":"]},"signatureHelpProvider":{"triggerCharacters":["(",","]},"definitionProvider":true,"documentHighlightProvider":true,"documentSymbolProvider":true,"workspaceSymbolProvider":true,"codeActionProvider":true,"documentFormattingProvider":true,"documentRangeFormattingProvider":true,"documentOnTypeFormattingProvider":{"firstTriggerCharacter":"\n"},"renameProvider":false,"executeCommandProvider":{"commands":["clangd.applyFix","clangd.applyTweak"]}}},"jsonrpc":"2.0"}
<<<
Content-Length: 52

{"jsonrpc":"2.0","method":"initialized","params":{}}Content-Length: 3485

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino","languageId":"cpp","version":1,"text":"/**\r\n   @file BasicSender.ino\r\n   @author rakwireless.com\r\n   @brief UWB transmit sender\r\n   @version 0.1\r\n   @date 2022-1-28\r\n   @copyright Copyright (c) 2020\r\n**/\r\n\r\n#include <SPI.h>\r\n#include <DW1000Ng.hpp>\r\n\r\nconst uint8_t PIN_SS = SS; // spi select pin\r\n\r\n\r\n// DEBUG packet sent status and count\r\nvolatile unsigned long delaySent = 0;\r\nint16_t sentNum = 0; // todo check int type\r\n\r\ndevice_configuration_t DEFAULT_CONFIG = {\r\n    false,\r\n    true,\r\n    true,\r\n    true,\r\n    false,\r\n    SFDMode::STANDARD_SFD,\r\n    Channel::CHANNEL_5,\r\n    DataRate::RATE_850KBPS,\r\n    PulseFrequency::FREQ_16MHZ,\r\n    PreambleLength::LEN_256,\r\n    PreambleCode::CODE_3\r\n};\r\n\r\nvoid setup() {\r\n  pinMode(WB_IO2, OUTPUT);\r\n  digitalWrite(WB_IO2, HIGH); //Turn on the power switch\r\n  delay(300);\r\n  time_t serial_timeout = millis();\r\n  // DEBUG monitoring\r\n  Serial.begin(115200);\r\n  while (!Serial)\r\n  {\r\n    if ((millis() - serial_timeout) < 5000)\r\n    {\r\n      delay(100);\r\n    }\r\n    else\r\n    {\r\n      break;\r\n    }\r\n  }\r\n  Serial.println(F(\"### DW1000Ng-arduino-sender-test ###\"));\r\n  // initialize the driver\r\n  DW1000Ng::initializeNoInterrupt(PIN_SS);\r\n  Serial.println(F(\"DW1000Ng initialized ...\"));\r\n\r\n  DW1000Ng::applyConfiguration(DEFAULT_CONFIG);\r\n\t//DW1000Ng::applyInterruptConfiguration(DEFAULT_INTERRUPT_CONFIG);\r\n\r\n  DW1000Ng::setDeviceAddress(5);\r\n  DW1000Ng::setNetworkId(10);\r\n\r\n  DW1000Ng::setAntennaDelay(16436);\r\n  Serial.println(F(\"Committed configuration ...\"));\r\n  // DEBUG chip info and registers pretty printed\r\n  char msg[128];\r\n  DW1000Ng::getPrintableDeviceIdentifier(msg);\r\n  Serial.print(\"Device ID: \"); Serial.println(msg);\r\n  DW1000Ng::getPrintableExtendedUniqueIdentifier(msg);\r\n  Serial.print(\"Unique ID: \"); Serial.println(msg);\r\n  DW1000Ng::getPrintableNetworkIdAndShortAddress(msg);\r\n  Serial.print(\"Network ID & Device Address: \"); Serial.println(msg);\r\n  DW1000Ng::getPrintableDeviceMode(msg);\r\n  Serial.print(\"Device mode: \"); Serial.println(msg);\r\n  // attach callback for (successfully) sent messages\r\n  //DW1000Ng::attachSentHandler(handleSent);\r\n  // start a transmission\r\n  transmit();\r\n}\r\n\r\n/*\r\nvoid handleSent() {\r\n  // status change on sent success\r\n  sentAck = true;\r\n}\r\n*/\r\n\r\nvoid transmit() {\r\n  // transmit some data\r\n  Serial.print(\"Transmitting packet ... #\"); Serial.println(sentNum);\r\n  String msg = \"Hello DW1000Ng, it's #\"; msg += sentNum;\r\n  DW1000Ng::setTransmitData(msg);\r\n  // delay sending the message for the given amount\r\n  delay(1000);\r\n  DW1000Ng::startTransmit(TransmitMode::IMMEDIATE);\r\n  delaySent = millis();\r\n  while(!DW1000Ng::isTransmitDone()) {\r\n\r\n  }\r\n  sentNum++;\r\n  DW1000Ng::clearTransmitStatus();\r\n}\r\n\r\nvoid loop() {\r\n    transmit();\r\n    // update and print some information about the sent message\r\n    Serial.print(\"ARDUINO delay sent [ms] ... \"); Serial.println(millis() - delaySent);\r\n    uint64_t newSentTime = DW1000Ng::getTransmitTimestamp();\r\n    Serial.print(\"Processed packet ... #\"); Serial.println(sentNum);\r\n    Serial.println();\r\n}\r\n"}}}Content-Length: 302

{"jsonrpc":"2.0","id":1,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"range":{"start":{"line":103,"character":13},"end":{"line":103,"character":13}},"context":{"diagnostics":[]}}}Content-Length: 225

{"jsonrpc":"2.0","id":2,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":83,"character":9}}}Content-Length: 62

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":2}}
>>>
Content-Length: 111

{"method":"window/workDoneProgress/create","params":{"token":"backgroundIndexProgress"},"id":0,"jsonrpc":"2.0"}Content-Length: 36

{"id":1,"result":[],"jsonrpc":"2.0"}Content-Length: 607

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino","diagnostics":[{"range":{"start":{"line":37,"character":2},"end":{"line":37,"character":8}},"severity":1,"code":"unknown_typename_suggest","source":"clang","message":"Unknown type name 'time_t'; did you mean 'size_t'? (fix available)\n\nc:\\Users\\ltp\\AppData\\Local\\Programs\\Arduino IDE\\resources\\app\\node_modules\\arduino-ide-extension\\build\\lib\\clang\\12.0.0\\include\\stddef.h:46:23:\nnote: 'size_t' declared here"}]},"jsonrpc":"2.0"}Content-Length: 38

{"id":2,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 38

{"jsonrpc":"2.0","id":0,"result":null}
>>>
Content-Length: 143

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"title":"indexing","percentage":0,"kind":"begin"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"3/36","percentage":8.333333333333334,"kind":"report"}},"jsonrpc":"2.0"}
<<<
Content-Length: 302

{"jsonrpc":"2.0","id":3,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"range":{"start":{"line":103,"character":13},"end":{"line":103,"character":13}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 36

{"id":3,"result":[],"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"4/36","percentage":11.11111111111111,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"4/36","percentage":11.11111111111111,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"5/36","percentage":13.88888888888889,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"6/36","percentage":16.666666666666668,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"6/36","percentage":16.666666666666668,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"7/36","percentage":19.444444444444443,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"7/36","percentage":19.444444444444443,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"8/36","percentage":22.22222222222222,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"8/36","percentage":22.22222222222222,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 143

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"9/36","percentage":25,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 143

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"9/36","percentage":25,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"10/36","percentage":27.77777777777778,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"10/36","percentage":27.77777777777778,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"11/36","percentage":30.555555555555557,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"11/36","percentage":30.555555555555557,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"12/36","percentage":33.333333333333336,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"12/36","percentage":33.333333333333336,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"13/36","percentage":36.111111111111114,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"13/36","percentage":36.111111111111114,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"14/36","percentage":38.888888888888886,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"14/36","percentage":38.888888888888886,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"15/36","percentage":41.666666666666664,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"15/36","percentage":41.666666666666664,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"16/36","percentage":44.44444444444444,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"16/36","percentage":44.44444444444444,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"17/36","percentage":47.22222222222222,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"17/36","percentage":47.22222222222222,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 144

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"18/36","percentage":50,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 144

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"18/36","percentage":50,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"19/36","percentage":52.77777777777778,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"19/36","percentage":52.77777777777778,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"20/36","percentage":55.55555555555556,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"20/36","percentage":55.55555555555556,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"21/36","percentage":58.333333333333336,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"21/36","percentage":58.333333333333336,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"22/36","percentage":61.111111111111114,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"22/36","percentage":61.111111111111114,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"23/36","percentage":63.888888888888886,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"23/36","percentage":63.888888888888886,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"24/36","percentage":66.66666666666667,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"24/36","percentage":66.66666666666667,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"25/36","percentage":69.44444444444444,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"25/36","percentage":69.44444444444444,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"26/36","percentage":72.22222222222223,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"26/36","percentage":72.22222222222223,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 144

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"27/36","percentage":75,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 144

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"27/36","percentage":75,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"28/36","percentage":77.77777777777777,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"28/36","percentage":77.77777777777777,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"29/36","percentage":80.55555555555556,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"29/36","percentage":80.55555555555556,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"30/36","percentage":83.33333333333333,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"30/36","percentage":83.33333333333333,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"31/36","percentage":86.11111111111111,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"31/36","percentage":86.11111111111111,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"32/36","percentage":88.88888888888889,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"32/36","percentage":88.88888888888889,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"33/36","percentage":91.66666666666667,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"34/36","percentage":94.44444444444444,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"35/36","percentage":97.22222222222223,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 107

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"kind":"end"}},"jsonrpc":"2.0"}
<<<
Content-Length: 300

{"jsonrpc":"2.0","id":4,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"range":{"start":{"line":94,"character":51},"end":{"line":94,"character":51}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 36

{"id":4,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 238

{"jsonrpc":"2.0","id":5,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":92,"character":51}}}
>>>
Content-Length: 36

{"id":5,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 300

{"jsonrpc":"2.0","id":6,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"range":{"start":{"line":92,"character":51},"end":{"line":92,"character":51}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 36

{"id":6,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 238

{"jsonrpc":"2.0","id":7,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":89,"character":59}}}
>>>
Content-Length: 36

{"id":7,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 300

{"jsonrpc":"2.0","id":8,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"range":{"start":{"line":89,"character":59},"end":{"line":89,"character":59}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 36

{"id":8,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 226

{"jsonrpc":"2.0","id":9,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":89,"character":59}}}
>>>
Content-Length: 38

{"id":9,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 227

{"jsonrpc":"2.0","id":10,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":89,"character":59}}}
>>>
Content-Length: 39

{"id":10,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 227

{"jsonrpc":"2.0","id":11,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":90,"character":10}}}
>>>
Content-Length: 301

{"id":11,"result":{"contents":{"kind":"markdown","value":"### variable `msg`  \n\n---\nType: `class arduino::String`  \n\n---\n```cpp\n// In transmit\narduino::String msg = \"Hello DW1000Ng, it's #\"\n```"},"range":{"start":{"line":90,"character":9},"end":{"line":90,"character":12}}},"jsonrpc":"2.0"}
<<<
Content-Length: 227

{"jsonrpc":"2.0","id":12,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":94,"character":29}}}
>>>
Content-Length: 269

{"id":12,"result":{"contents":{"kind":"markdown","value":"### enum `TransmitMode`  \n\n---\nValue = `IMMEDIATE (0)`  \n\n---\n```cpp\nenum class TransmitMode : int {}\n```"},"range":{"start":{"line":94,"character":26},"end":{"line":94,"character":38}}},"jsonrpc":"2.0"}
<<<
Content-Length: 227

{"jsonrpc":"2.0","id":13,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":94,"character":28}}}
>>>
Content-Length: 269

{"id":13,"result":{"contents":{"kind":"markdown","value":"### enum `TransmitMode`  \n\n---\nValue = `IMMEDIATE (0)`  \n\n---\n```cpp\nenum class TransmitMode : int {}\n```"},"range":{"start":{"line":94,"character":26},"end":{"line":94,"character":38}}},"jsonrpc":"2.0"}
<<<
Content-Length: 227

{"jsonrpc":"2.0","id":14,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":90,"character":26}}}
>>>
Content-Length: 39

{"id":14,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 301

{"jsonrpc":"2.0","id":15,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"range":{"start":{"line":87,"character":17},"end":{"line":87,"character":17}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":15,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 227

{"jsonrpc":"2.0","id":16,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":90,"character":37}}}
>>>
Content-Length: 39

{"id":16,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 227

{"jsonrpc":"2.0","id":17,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":90,"character":19}}}Content-Length: 63

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":17}}
>>>
Content-Length: 39

{"id":17,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 227

{"jsonrpc":"2.0","id":18,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":91,"character":27}}}
>>>
Content-Length: 502

{"id":18,"result":{"contents":{"kind":"markdown","value":"### function `setTransmitData`  \n\n---\nâ†’ `void`  \nParameters:  \n- `const arduino::String \u0026 data`\n\nSets the transmission bytes inside the tx buffer of the DW1000 based on the input string  \n@param [in] data the string to transmit  \n\n---\n```cpp\n// In namespace DW1000Ng\nvoid setTransmitData(const arduino::String \u0026data)\n```"},"range":{"start":{"line":91,"character":12},"end":{"line":91,"character":27}}},"jsonrpc":"2.0"}
<<<
Content-Length: 227

{"jsonrpc":"2.0","id":19,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":89,"character":41}}}
>>>
Content-Length: 39

{"id":19,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 63

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":19}}Content-Length: 227

{"jsonrpc":"2.0","id":20,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":92,"character":49}}}
>>>
Content-Length: 39

{"id":20,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 227

{"jsonrpc":"2.0","id":21,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":72,"character":37}}}
>>>
Content-Length: 324

{"id":21,"result":{"contents":{"kind":"markdown","value":"### variable `msg`  \n\n---\nType: `char [128]`  \nPassed as msgBuffer  \nDEBUG chip info and registers pretty printed  \n\n---\n```cpp\n// In setup\nchar msg[128]\n```"},"range":{"start":{"line":72,"character":35},"end":{"line":72,"character":38}}},"jsonrpc":"2.0"}
<<<
Content-Length: 239

{"jsonrpc":"2.0","id":22,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":81,"character":12}}}
>>>
Content-Length: 37

{"id":22,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 300

{"jsonrpc":"2.0","id":23,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"range":{"start":{"line":81,"character":5},"end":{"line":81,"character":15}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":23,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 227

{"jsonrpc":"2.0","id":24,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":81,"character":12}}}
>>>
Content-Length: 39

{"id":24,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 232

{"jsonrpc":"2.0","id":25,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":81,"character":12}}}
>>>
Content-Length: 37

{"id":25,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 301

{"jsonrpc":"2.0","id":26,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"range":{"start":{"line":75,"character":32},"end":{"line":75,"character":42}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":26,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 300

{"jsonrpc":"2.0","id":27,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"range":{"start":{"line":81,"character":5},"end":{"line":81,"character":15}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":27,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 301

{"jsonrpc":"2.0","id":28,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"range":{"start":{"line":75,"character":32},"end":{"line":75,"character":42}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":28,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 300

{"jsonrpc":"2.0","id":29,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"range":{"start":{"line":81,"character":5},"end":{"line":81,"character":15}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":29,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 300

{"jsonrpc":"2.0","id":30,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"range":{"start":{"line":81,"character":5},"end":{"line":81,"character":15}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":30,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 301

{"jsonrpc":"2.0","id":31,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"range":{"start":{"line":75,"character":32},"end":{"line":75,"character":42}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":31,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 239

{"jsonrpc":"2.0","id":32,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":74,"character":23}}}
>>>
Content-Length: 37

{"id":32,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 299

{"jsonrpc":"2.0","id":33,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"range":{"start":{"line":74,"character":0},"end":{"line":75,"character":0}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":33,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 227

{"jsonrpc":"2.0","id":34,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":74,"character":24}}}
>>>
Content-Length: 39

{"id":34,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 232

{"jsonrpc":"2.0","id":35,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":74,"character":24}}}
>>>
Content-Length: 37

{"id":35,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 227

{"jsonrpc":"2.0","id":36,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":76,"character":20}}}
>>>
Content-Length: 39

{"id":36,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 239

{"jsonrpc":"2.0","id":37,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":76,"character":21}}}
>>>
Content-Length: 37

{"id":37,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 301

{"jsonrpc":"2.0","id":38,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"range":{"start":{"line":76,"character":21},"end":{"line":76,"character":21}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":38,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 227

{"jsonrpc":"2.0","id":39,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":76,"character":22}}}
>>>
Content-Length: 39

{"id":39,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 227

{"jsonrpc":"2.0","id":40,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":75,"character":31}}}
>>>
Content-Length: 39

{"id":40,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 227

{"jsonrpc":"2.0","id":41,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":74,"character":32}}}
>>>
Content-Length: 39

{"id":41,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 227

{"jsonrpc":"2.0","id":42,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":75,"character":29}}}
>>>
Content-Length: 39

{"id":42,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 239

{"jsonrpc":"2.0","id":43,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":75,"character":29}}}
>>>
Content-Length: 37

{"id":43,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 299

{"jsonrpc":"2.0","id":44,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"range":{"start":{"line":75,"character":0},"end":{"line":76,"character":0}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":44,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 227

{"jsonrpc":"2.0","id":45,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":75,"character":23}}}
>>>
Content-Length: 39

{"id":45,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 227

{"jsonrpc":"2.0","id":46,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":75,"character":24}}}
>>>
Content-Length: 39

{"id":46,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 239

{"jsonrpc":"2.0","id":47,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":74,"character":22}}}
>>>
Content-Length: 37

{"id":47,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 301

{"jsonrpc":"2.0","id":48,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"range":{"start":{"line":74,"character":22},"end":{"line":74,"character":22}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":48,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 299

{"jsonrpc":"2.0","id":49,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"range":{"start":{"line":74,"character":0},"end":{"line":75,"character":0}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":49,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 239

{"jsonrpc":"2.0","id":50,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":75,"character":21}}}
>>>
Content-Length: 37

{"id":50,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 299

{"jsonrpc":"2.0","id":51,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"range":{"start":{"line":75,"character":0},"end":{"line":76,"character":0}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":51,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 232

{"jsonrpc":"2.0","id":52,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":75,"character":21}}}
>>>
Content-Length: 214

{"id":52,"result":[{"uri":"file:///C:/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","range":{"start":{"line":1654,"character":6},"end":{"line":1654,"character":23}}}],"jsonrpc":"2.0"}
<<<
Content-Length: 82613

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","languageId":"cpp","version":1,"text":"/*\n * MIT License\n *\n * Copyright (c) 2018 Michele Biondi, Andrea Salvatori\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n/*\n * Copyright (c) 2015 by Thomas Trojer <thomas@trojer.net>\n * Decawave DW1000Ng library for arduino.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @file DW1000Ng.cpp\n * Arduino driver library (source file) for the Decawave DW1000Ng UWB transceiver Module.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"DW1000Ng.hpp\"\n#include \"DW1000NgUtils.hpp\"\n#include \"DW1000NgConstants.hpp\"\n#include \"DW1000NgRegisters.hpp\"\n#include \"SPIporting.hpp\"\n\nnamespace DW1000Ng\n{\n\n\t/* anonymous namespace to host private-like variables and methods */\n\tnamespace\n\t{\n\n\t\t/* ########################### PRIVATE VARIABLES ################################# */\n\n\t\t/* SPI select pin and interrupt pin*/\n\t\tuint8_t _ss = 0xff;\n\t\tuint8_t _irq = 0xff;\n\t\tuint8_t _rst = 0xff;\n\n\t\t/* IRQ callbacks */\n\t\tvoid (*_handleSent)(void) = nullptr;\n\t\tvoid (*_handleError)(void) = nullptr;\n\t\tvoid (*_handleReceived)(void) = nullptr;\n\t\tvoid (*_handleReceiveFailed)(void) = nullptr;\n\t\tvoid (*_handleReceiveTimeout)(void) = nullptr;\n\t\tvoid (*_handleReceiveTimestampAvailable)(void) = nullptr;\n\n\t\t/* registers */\n\t\tbyte _syscfg[LEN_SYS_CFG];\n\t\tbyte _sysctrl[LEN_SYS_CTRL];\n\t\tbyte _sysstatus[LEN_SYS_STATUS];\n\t\tbyte _txfctrl[LEN_TX_FCTRL];\n\t\tbyte _sysmask[LEN_SYS_MASK];\n\t\tbyte _chanctrl[LEN_CHAN_CTRL];\n\t\tbyte _networkAndAddress[LEN_PANADR];\n\n\t\t/* Temperature and Voltage monitoring */\n\t\tbyte _vmeas3v3 = 0;\n\t\tbyte _tmeas23C = 0;\n\n\t\t/* Driver Internal State Trackers */\n\t\tbyte _extendedFrameLength;\n\t\tPacSize _pacSize;\n\t\tPulseFrequency _pulseFrequency;\n\t\tDataRate _dataRate;\n\t\tPreambleLength _preambleLength;\n\t\tPreambleCode _preambleCode;\n\t\tChannel _channel;\n\t\tboolean _smartPower;\n\t\tboolean _frameCheck;\n\t\tboolean _debounceClockEnabled = false;\n\t\tboolean _nlos = false;\n\t\tboolean _standardSFD = true;\n\t\tboolean _autoTXPower = true;\n\t\tboolean _autoTCPGDelay = true;\n\t\tboolean _wait4resp = false;\n\t\tuint16_t _antennaTxDelay = 0;\n\t\tuint16_t _antennaRxDelay = 0;\n\n\t\t/* ############################# PRIVATE METHODS ################################### */\n\t\t/*\n\t\t * Write bytes to the DW1000Ng. Single bytes can be written to registers via sub-addressing.\n\t\t * @param cmd\n\t\t * \t\tThe register address (see Chapter 7 in the DW1000Ng user manual).\n\t\t * @param offset\n\t\t *\t\tThe offset to select register sub-parts for writing, or 0x00 to disable\n\t\t * \t\tsub-adressing.\n\t\t * @param data\n\t\t *\t\tThe data array to be written.\n\t\t * @param data_size\n\t\t *\t\tThe number of bytes to be written (take care not to go out of bounds of\n\t\t * \t\tthe register).\n\t\t */\n\t\t// TODO offset really bigger than byte?\n\n\t\tvoid _writeBytesToRegister(byte cmd, uint16_t offset, byte data[], uint16_t data_size)\n\t\t{\n\t\t\tbyte header[3];\n\t\t\tuint8_t headerLen = 1;\n\n\t\t\t// TODO proper error handling: address out of bounds\n\t\t\t// build SPI header\n\t\t\tif (offset == NO_SUB)\n\t\t\t{\n\t\t\t\theader[0] = WRITE | cmd;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\theader[0] = WRITE_SUB | cmd;\n\t\t\t\tif (offset < 128)\n\t\t\t\t{\n\t\t\t\t\theader[1] = (byte)offset;\n\t\t\t\t\theaderLen++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\theader[1] = RW_SUB_EXT | (byte)offset;\n\t\t\t\t\theader[2] = (byte)(offset >> 7);\n\t\t\t\t\theaderLen += 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSPIporting::writeToSPI(_ss, headerLen, header, data_size, data);\n\t\t}\n\n\t\tvoid _writeToRegister(byte cmd, uint16_t offset, uint32_t data, uint16_t data_size)\n\t\t{\n\t\t\tbyte dataBytes[data_size];\n\t\t\tDW1000NgUtils::writeValueToBytes(dataBytes, data, data_size);\n\t\t\t_writeBytesToRegister(cmd, offset, dataBytes, data_size);\n\t\t}\n\n\t\t// Helper to set a single register\n\t\tvoid _writeByte(byte cmd, uint16_t offset, byte data)\n\t\t{\n\t\t\t_writeBytesToRegister(cmd, offset, &data, 1);\n\t\t}\n\n\t\t/*\n\t\t * Read bytes from the DW1000Ng. Number of bytes depend on register length.\n\t\t * @param cmd\n\t\t * \t\tThe register address (see Chapter 7 in the DW1000Ng user manual).\n\t\t * @param data\n\t\t *\t\tThe data array to be read into.\n\t\t * @param n\n\t\t *\t\tThe number of bytes expected to be received.\n\t\t */\n\t\t// TODO incomplete doc\n\t\tvoid _readBytes(byte cmd, uint16_t offset, byte data[], uint16_t data_size)\n\t\t{\n\t\t\tbyte header[3];\n\t\t\tuint8_t headerLen = 1;\n\n\t\t\t// build SPI header\n\t\t\tif (offset == NO_SUB)\n\t\t\t{\n\t\t\t\theader[0] = READ | cmd;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\theader[0] = READ_SUB | cmd;\n\t\t\t\tif (offset < 128)\n\t\t\t\t{\n\t\t\t\t\theader[1] = (byte)offset;\n\t\t\t\t\theaderLen++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\theader[1] = RW_SUB_EXT | (byte)offset;\n\t\t\t\t\theader[2] = (byte)(offset >> 7);\n\t\t\t\t\theaderLen += 2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSPIporting::readFromSPI(_ss, headerLen, header, data_size, data);\n\t\t}\n\n\t\t// always 4 bytes\n\t\t// TODO why always 4 bytes? can be different, see p. 58 table 10 otp memory map\n\t\tvoid _readBytesOTP(uint16_t address, byte data[])\n\t\t{\n\t\t\tbyte addressBytes[LEN_OTP_ADDR];\n\n\t\t\t// p60 - 6.3.3 Reading a value from OTP memory\n\t\t\t// bytes of address\n\t\t\taddressBytes[0] = (address & 0xFF);\n\t\t\taddressBytes[1] = ((address >> 8) & 0xFF);\n\t\t\t// set address\n\t\t\t_writeBytesToRegister(OTP_IF, OTP_ADDR_SUB, addressBytes, LEN_OTP_ADDR);\n\t\t\t// switch into read mode\n\t\t\t_writeByte(OTP_IF, OTP_CTRL_SUB, 0x03); // OTPRDEN | OTPREAD\n\t\t\t_writeByte(OTP_IF, OTP_CTRL_SUB, 0x01); // OTPRDEN\n\t\t\t// read value/block - 4 bytes\n\t\t\t_readBytes(OTP_IF, OTP_RDAT_SUB, data, LEN_OTP_RDAT);\n\t\t\t// end read mode\n\t\t\t_writeByte(OTP_IF, OTP_CTRL_SUB, 0x00);\n\t\t}\n\n\t\tvoid _writeBitToRegister(byte bitRegister, uint16_t RegisterOffset, uint16_t bitRegister_LEN, uint16_t selectedBit, boolean value)\n\t\t{\n\t\t\tuint16_t idx;\n\t\t\tuint8_t bitPosition;\n\n\t\t\tidx = selectedBit / 8;\n\t\t\tif (idx >= bitRegister_LEN)\n\t\t\t{\n\t\t\t\treturn; // TODO proper error handling: out of bounds\n\t\t\t}\n\t\t\tbyte targetByte;\n\t\t\tmemset(&targetByte, 0, 1);\n\t\t\tbitPosition = selectedBit % 8;\n\t\t\t_readBytes(bitRegister, RegisterOffset + idx, &targetByte, 1);\n\n\t\t\tvalue ? bitSet(targetByte, bitPosition) : bitClear(targetByte, bitPosition);\n\n\t\t\tif (RegisterOffset == NO_SUB)\n\t\t\t\tRegisterOffset = 0x00;\n\n\t\t\t_writeBytesToRegister(bitRegister, RegisterOffset + idx, &targetByte, 1);\n\t\t}\n\n\t\tvoid _enableClock(byte clock)\n\t\t{\n\t\t\tbyte pmscctrl0[LEN_PMSC_CTRL0];\n\t\t\tmemset(pmscctrl0, 0, LEN_PMSC_CTRL0);\n\t\t\t_readBytes(PMSC, PMSC_CTRL0_SUB, pmscctrl0, LEN_PMSC_CTRL0);\n\t\t\tif (clock == SYS_AUTO_CLOCK)\n\t\t\t{\n\t\t\t\tpmscctrl0[0] = SYS_AUTO_CLOCK;\n\t\t\t\tpmscctrl0[1] &= 0xFE;\n\t\t\t}\n\t\t\telse if (clock == SYS_XTI_CLOCK)\n\t\t\t{\n\t\t\t\tpmscctrl0[0] &= 0xFC;\n\t\t\t\tpmscctrl0[0] |= SYS_XTI_CLOCK;\n\t\t\t}\n\t\t\telse if (clock == SYS_PLL_CLOCK)\n\t\t\t{\n\t\t\t\tpmscctrl0[0] &= 0xFC;\n\t\t\t\tpmscctrl0[0] |= SYS_PLL_CLOCK;\n\t\t\t}\n\t\t\telse if (clock == TX_PLL_CLOCK)\n\t\t\t{\n\t\t\t\tpmscctrl0[0] &= 0xCF;\n\t\t\t\tpmscctrl0[0] |= TX_PLL_CLOCK;\n\t\t\t}\n\t\t\telse if (clock == LDE_CLOCK)\n\t\t\t{\n\t\t\t\tpmscctrl0[0] = SYS_XTI_CLOCK;\n\t\t\t\tpmscctrl0[1] = 0x03;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO deliver proper warning\n\t\t\t}\n\t\t\t_writeBytesToRegister(PMSC, PMSC_CTRL0_SUB, pmscctrl0, 2);\n\t\t}\n\n\t\t/* Steps used to get Temp and Voltage */\n\t\tvoid _vbatAndTempSteps()\n\t\t{\n\t\t\tbyte step1 = 0x80;\n\t\t\t_writeBytesToRegister(RF_CONF, 0x11, &step1, 1);\n\t\t\tbyte step2 = 0x0A;\n\t\t\t_writeBytesToRegister(RF_CONF, 0x12, &step2, 1);\n\t\t\tbyte step3 = 0x0F;\n\t\t\t_writeBytesToRegister(RF_CONF, 0x12, &step3, 1);\n\t\t\tbyte step4 = 0x01;\n\t\t\t_writeBytesToRegister(TX_CAL, NO_SUB, &step4, 1);\n\t\t\tbyte step5 = 0x00;\n\t\t\t_writeBytesToRegister(TX_CAL, NO_SUB, &step5, 1);\n\t\t}\n\n\t\t/* AGC_TUNE1 - reg:0x23, sub-reg:0x04, table 24 */\n\t\tvoid _agctune1()\n\t\t{\n\t\t\tbyte agctune1[LEN_AGC_TUNE1];\n\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(agctune1, 0x8870, LEN_AGC_TUNE1);\n\t\t\t}\n\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(agctune1, 0x889B, LEN_AGC_TUNE1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(AGC_TUNE, AGC_TUNE1_SUB, agctune1, LEN_AGC_TUNE1);\n\t\t}\n\n\t\t/* AGC_TUNE2 - reg:0x23, sub-reg:0x0C, table 25 */\n\t\tvoid _agctune2()\n\t\t{\n\t\t\tbyte agctune2[LEN_AGC_TUNE2];\n\t\t\tDW1000NgUtils::writeValueToBytes(agctune2, 0x2502A907L, LEN_AGC_TUNE2);\n\t\t\t_writeBytesToRegister(AGC_TUNE, AGC_TUNE2_SUB, agctune2, LEN_AGC_TUNE2);\n\t\t}\n\n\t\t/* AGC_TUNE3 - reg:0x23, sub-reg:0x12, table 26 */\n\t\tvoid _agctune3()\n\t\t{\n\t\t\tbyte agctune3[LEN_AGC_TUNE3];\n\t\t\tDW1000NgUtils::writeValueToBytes(agctune3, 0x0035, LEN_AGC_TUNE3);\n\t\t\t_writeBytesToRegister(AGC_TUNE, AGC_TUNE3_SUB, agctune3, LEN_AGC_TUNE3);\n\t\t}\n\n\t\t/* DRX_TUNE0b - reg:0x27, sub-reg:0x02, table 30 */\n\t\tvoid _drxtune0b()\n\t\t{\n\t\t\tbyte drxtune0b[LEN_DRX_TUNE0b];\n\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t{\n\t\t\t\tif (!_standardSFD)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune0b, 0x0016, LEN_DRX_TUNE0b);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune0b, 0x000A, LEN_DRX_TUNE0b);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_dataRate == DataRate::RATE_850KBPS)\n\t\t\t{\n\t\t\t\tif (!_standardSFD)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune0b, 0x0006, LEN_DRX_TUNE0b);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune0b, 0x0001, LEN_DRX_TUNE0b);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_dataRate == DataRate::RATE_6800KBPS)\n\t\t\t{\n\t\t\t\tif (!_standardSFD)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune0b, 0x0002, LEN_DRX_TUNE0b);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune0b, 0x0001, LEN_DRX_TUNE0b);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(DRX_TUNE, DRX_TUNE0b_SUB, drxtune0b, LEN_DRX_TUNE0b);\n\t\t}\n\n\t\t/* DRX_TUNE1a - reg:0x27, sub-reg:0x04, table 31 */\n\t\tvoid _drxtune1a()\n\t\t{\n\t\t\tbyte drxtune1a[LEN_DRX_TUNE1a];\n\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune1a, 0x0087, LEN_DRX_TUNE1a);\n\t\t\t}\n\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune1a, 0x008D, LEN_DRX_TUNE1a);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(DRX_TUNE, DRX_TUNE1a_SUB, drxtune1a, LEN_DRX_TUNE1a);\n\t\t}\n\n\t\t/* DRX_TUNE1b - reg:0x27, sub-reg:0x06, table 32 */\n\t\tvoid _drxtune1b()\n\t\t{\n\t\t\tbyte drxtune1b[LEN_DRX_TUNE1b];\n\t\t\tif (_preambleLength == PreambleLength::LEN_1536 || _preambleLength == PreambleLength::LEN_2048 ||\n\t\t\t\t_preambleLength == PreambleLength::LEN_4096)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune1b, 0x0064, LEN_DRX_TUNE1b);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleLength != PreambleLength::LEN_64)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_850KBPS || _dataRate == DataRate::RATE_6800KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune1b, 0x0020, LEN_DRX_TUNE1b);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_6800KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune1b, 0x0010, LEN_DRX_TUNE1b);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\t_writeBytesToRegister(DRX_TUNE, DRX_TUNE1b_SUB, drxtune1b, LEN_DRX_TUNE1b);\n\t\t}\n\n\t\t/* DRX_TUNE2 - reg:0x27, sub-reg:0x08, table 33 */\n\t\tvoid _drxtune2()\n\t\t{\n\t\t\tbyte drxtune2[LEN_DRX_TUNE2];\n\t\t\tif (_pacSize == PacSize::SIZE_8)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune2, 0x311A002DL, LEN_DRX_TUNE2);\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune2, 0x313B006BL, LEN_DRX_TUNE2);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_pacSize == PacSize::SIZE_16)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune2, 0x331A0052L, LEN_DRX_TUNE2);\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune2, 0x333B00BEL, LEN_DRX_TUNE2);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_pacSize == PacSize::SIZE_32)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune2, 0x351A009AL, LEN_DRX_TUNE2);\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune2, 0x353B015EL, LEN_DRX_TUNE2);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_pacSize == PacSize::SIZE_64)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune2, 0x371A011DL, LEN_DRX_TUNE2);\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune2, 0x373B0296L, LEN_DRX_TUNE2);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(DRX_TUNE, DRX_TUNE2_SUB, drxtune2, LEN_DRX_TUNE2);\n\t\t}\n\n\t\t/* DRX_TUNE4H - reg:0x27, sub-reg:0x26, table 34 */\n\t\tvoid _drxtune4H()\n\t\t{\n\t\t\tbyte drxtune4H[LEN_DRX_TUNE4H];\n\t\t\tif (_preambleLength == PreambleLength::LEN_64)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune4H, 0x0010, LEN_DRX_TUNE4H);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune4H, 0x0028, LEN_DRX_TUNE4H);\n\t\t\t}\n\t\t\t_writeBytesToRegister(DRX_TUNE, DRX_TUNE4H_SUB, drxtune4H, LEN_DRX_TUNE4H);\n\t\t}\n\n\t\t/* LDE_CFG1 - reg 0x2E, sub-reg:0x0806 */\n\t\tvoid _ldecfg1()\n\t\t{\n\t\t\tbyte ldecfg1[LEN_LDE_CFG1];\n\t\t\t_nlos == true ? DW1000NgUtils::writeValueToBytes(ldecfg1, 0x7, LEN_LDE_CFG1) : DW1000NgUtils::writeValueToBytes(ldecfg1, 0xD, LEN_LDE_CFG1);\n\t\t\t_writeBytesToRegister(LDE_IF, LDE_CFG1_SUB, ldecfg1, LEN_LDE_CFG1);\n\t\t}\n\n\t\t/* LDE_CFG2 - reg 0x2E, sub-reg:0x1806, table 50 */\n\t\tvoid _ldecfg2()\n\t\t{\n\t\t\tbyte ldecfg2[LEN_LDE_CFG2];\n\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t{\n\t\t\t\t_nlos == true ? DW1000NgUtils::writeValueToBytes(ldecfg2, 0x0003, LEN_LDE_CFG2) : DW1000NgUtils::writeValueToBytes(ldecfg2, 0x1607, LEN_LDE_CFG2);\n\t\t\t}\n\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(ldecfg2, 0x0607, LEN_LDE_CFG2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(LDE_IF, LDE_CFG2_SUB, ldecfg2, LEN_LDE_CFG2);\n\t\t}\n\n\t\t/* LDE_REPC - reg 0x2E, sub-reg:0x2804, table 51 */\n\t\tvoid _lderepc()\n\t\t{\n\t\t\tbyte lderepc[LEN_LDE_REPC];\n\t\t\tif (_preambleCode == PreambleCode::CODE_1 || _preambleCode == PreambleCode::CODE_2)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x5998 >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x5998, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_3 || _preambleCode == PreambleCode::CODE_8)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x51EA >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x51EA, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_4)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x428E >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x428E, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_5)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x451E >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x451E, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_6)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x2E14 >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x2E14, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_7)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x8000 >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x8000, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_9)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x28F4 >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x28F4, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_10 || _preambleCode == PreambleCode::CODE_17)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x3332 >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x3332, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_11)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x3AE0 >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x3AE0, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_12)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x3D70 >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x3D70, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_18 || _preambleCode == PreambleCode::CODE_19)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x35C2 >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x35C2, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_20)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x47AE >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x47AE, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\n\t\t\t_writeBytesToRegister(LDE_IF, LDE_REPC_SUB, lderepc, LEN_LDE_REPC);\n\t\t}\n\n\t\t/* TX_POWER (enabled smart transmit power control) - reg:0x1E, tables 19-20\n\t\t * These values are based on a typical IC and an assumed IC to antenna loss of 1.5 dB with a 0 dBi antenna */\n\t\tvoid _txpowertune()\n\t\t{\n\t\t\tbyte txpower[LEN_TX_POWER];\n\t\t\tif (_channel == Channel::CHANNEL_1 || _channel == Channel::CHANNEL_2)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x1B153555L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x15355575L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x55555555L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x75757575L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x0D072747L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x07274767L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x47474747L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x67676767L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_3)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x150F2F4FL, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x0F2F4F6FL, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x4F4F4F4FL, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x6F6F6F6FL, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x0B2B4B6BL, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x2B4B6B8BL, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x6B6B6B6BL, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x8B8B8B8BL, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_4)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x1F1F1F3FL, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x1F1F3F5FL, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x3F3F3F3FL, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x5F5F5F5FL, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x1A3A5A7AL, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x3A5A7A9AL, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x7A7A7A7AL, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x9A9A9A9AL, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_5)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x140E0828L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x0E082848L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x28282828L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x48484848L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x05254565L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x25456585L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x65656565L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x85858585L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_7)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x12325272L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x32527292L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x72727272L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x92929292L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x315191B1L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x5171B1D1L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0xB1B1B1B1L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0xD1D1D1D1L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(TX_POWER, NO_SUB, txpower, LEN_TX_POWER);\n\t\t}\n\n\t\t/* RF_RXCTRLH - reg:0x28, sub-reg:0x0B, table 37 */\n\t\tvoid _rfrxctrlh()\n\t\t{\n\t\t\tbyte rfrxctrlh[LEN_RF_RXCTRLH];\n\t\t\tif (_channel != Channel::CHANNEL_4 && _channel != Channel::CHANNEL_7)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(rfrxctrlh, 0xD8, LEN_RF_RXCTRLH);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(rfrxctrlh, 0xBC, LEN_RF_RXCTRLH);\n\t\t\t}\n\t\t\t_writeBytesToRegister(RF_CONF, RF_RXCTRLH_SUB, rfrxctrlh, LEN_RF_RXCTRLH);\n\t\t}\n\n\t\t/* RX_TXCTRL - reg:0x28, sub-reg:0x0C */\n\t\tvoid _rftxctrl()\n\t\t{\n\t\t\tbyte rftxctrl[LEN_RF_TXCTRL];\n\t\t\tif (_channel == Channel::CHANNEL_1)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(rftxctrl, 0x00005C40L, LEN_RF_TXCTRL);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_2)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(rftxctrl, 0x00045CA0L, LEN_RF_TXCTRL);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_3)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(rftxctrl, 0x00086CC0L, LEN_RF_TXCTRL);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_4)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(rftxctrl, 0x00045C80L, LEN_RF_TXCTRL);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_5)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(rftxctrl, 0x001E3FE0L, LEN_RF_TXCTRL);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_7)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(rftxctrl, 0x001E7DE0L, LEN_RF_TXCTRL);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(RF_CONF, RF_TXCTRL_SUB, rftxctrl, LEN_RF_TXCTRL);\n\t\t}\n\n\t\t/* TC_PGDELAY - reg:0x2A, sub-reg:0x0B, table 40 */\n\t\tvoid _tcpgdelaytune()\n\t\t{\n\t\t\tbyte tcpgdelay[LEN_TC_PGDELAY];\n\t\t\tif (_channel == Channel::CHANNEL_1)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(tcpgdelay, 0xC9, LEN_TC_PGDELAY);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_2)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(tcpgdelay, 0xC2, LEN_TC_PGDELAY);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_3)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(tcpgdelay, 0xC5, LEN_TC_PGDELAY);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_4)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(tcpgdelay, 0x95, LEN_TC_PGDELAY);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_5)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(tcpgdelay, 0xC0, LEN_TC_PGDELAY);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_7)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(tcpgdelay, 0x93, LEN_TC_PGDELAY);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(TX_CAL, TC_PGDELAY_SUB, tcpgdelay, LEN_TC_PGDELAY);\n\t\t}\n\n\t\t// FS_PLLCFG and FS_PLLTUNE - reg:0x2B, sub-reg:0x07-0x0B, tables 43-44\n\t\tvoid _fspll()\n\t\t{\n\t\t\tbyte fspllcfg[LEN_FS_PLLCFG];\n\t\t\tbyte fsplltune[LEN_FS_PLLTUNE];\n\t\t\tif (_channel == Channel::CHANNEL_1)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fspllcfg, 0x09000407L, LEN_FS_PLLCFG);\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fsplltune, 0x1E, LEN_FS_PLLTUNE);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_2 || _channel == Channel::CHANNEL_4)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fspllcfg, 0x08400508L, LEN_FS_PLLCFG);\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fsplltune, 0x26, LEN_FS_PLLTUNE);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_3)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fspllcfg, 0x08401009L, LEN_FS_PLLCFG);\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fsplltune, 0x56, LEN_FS_PLLTUNE);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_5 || _channel == Channel::CHANNEL_7)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fspllcfg, 0x0800041DL, LEN_FS_PLLCFG);\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fsplltune, 0xBE, LEN_FS_PLLTUNE);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(FS_CTRL, FS_PLLTUNE_SUB, fsplltune, LEN_FS_PLLTUNE);\n\t\t\t_writeBytesToRegister(FS_CTRL, FS_PLLCFG_SUB, fspllcfg, LEN_FS_PLLCFG);\n\t\t}\n\n\t\tvoid _tune()\n\t\t{\n\t\t\t// these registers are going to be tuned/configured\n\t\t\t_agctune1();\n\t\t\t_agctune2();\n\t\t\t_agctune3();\n\t\t\t_drxtune0b();\n\t\t\t_drxtune1a();\n\t\t\t_drxtune1b();\n\t\t\t_drxtune2();\n\t\t\t_drxtune4H();\n\t\t\t_ldecfg1();\n\t\t\t_ldecfg2();\n\t\t\t_lderepc();\n\t\t\tif (_autoTXPower)\n\t\t\t\t_txpowertune();\n\t\t\t_rfrxctrlh();\n\t\t\t_rftxctrl();\n\t\t\tif (_autoTCPGDelay)\n\t\t\t\t_tcpgdelaytune();\n\t\t\t_fspll();\n\t\t}\n\n\t\tvoid _writeNetworkIdAndDeviceAddress()\n\t\t{\n\t\t\t_writeBytesToRegister(PANADR, NO_SUB, _networkAndAddress, LEN_PANADR);\n\t\t}\n\n\t\tvoid _writeSystemConfigurationRegister()\n\t\t{\n\t\t\t_writeBytesToRegister(SYS_CFG, NO_SUB, _syscfg, LEN_SYS_CFG);\n\t\t}\n\n\t\tvoid _writeChannelControlRegister()\n\t\t{\n\t\t\t_writeBytesToRegister(CHAN_CTRL, NO_SUB, _chanctrl, LEN_CHAN_CTRL);\n\t\t}\n\n\t\tvoid _writeTransmitFrameControlRegister()\n\t\t{\n\t\t\t_writeBytesToRegister(TX_FCTRL, NO_SUB, _txfctrl, LEN_TX_FCTRL);\n\t\t}\n\n\t\tvoid _writeSystemEventMaskRegister()\n\t\t{\n\t\t\t_writeBytesToRegister(SYS_MASK, NO_SUB, _sysmask, LEN_SYS_MASK);\n\t\t}\n\n\t\tvoid _writeAntennaDelayRegisters()\n\t\t{\n\t\t\tbyte antennaTxDelayBytes[2];\n\t\t\tbyte antennaRxDelayBytes[2];\n\t\t\tDW1000NgUtils::writeValueToBytes(antennaTxDelayBytes, _antennaTxDelay, LEN_TX_ANTD);\n\t\t\tDW1000NgUtils::writeValueToBytes(antennaRxDelayBytes, _antennaRxDelay, LEN_LDE_RXANTD);\n\t\t\t_writeBytesToRegister(TX_ANTD, NO_SUB, antennaTxDelayBytes, LEN_TX_ANTD);\n\t\t\t_writeBytesToRegister(LDE_IF, LDE_RXANTD_SUB, antennaRxDelayBytes, LEN_LDE_RXANTD);\n\t\t}\n\n\t\tvoid _writeConfiguration()\n\t\t{\n\t\t\t// write all configurations back to device\n\t\t\t_writeSystemConfigurationRegister();\n\t\t\t_writeChannelControlRegister();\n\t\t\t_writeTransmitFrameControlRegister();\n\t\t}\n\n\t\tvoid _useExtendedFrameLength(boolean val)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, PHR_MODE_0_BIT, val);\n\t\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, PHR_MODE_1_BIT, val);\n\t\t}\n\n\t\tvoid _setReceiverAutoReenable(boolean val)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, RXAUTR_BIT, val);\n\t\t}\n\n\t\tvoid _useFrameCheck(boolean val)\n\t\t{\n\t\t\t_frameCheck = val;\n\t\t}\n\n\t\tvoid _setNlosOptimization(boolean val)\n\t\t{\n\t\t\t_nlos = val;\n\t\t\tif (_nlos)\n\t\t\t{\n\t\t\t\t_ldecfg1();\n\t\t\t\t_ldecfg2();\n\t\t\t}\n\t\t}\n\n\t\tvoid _useSmartPower(boolean smartPower)\n\t\t{\n\t\t\t_smartPower = smartPower;\n\t\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, DIS_STXP_BIT, !smartPower);\n\t\t\t_writeSystemConfigurationRegister();\n\t\t\tif (_autoTXPower)\n\t\t\t\t_txpowertune();\n\t\t}\n\n\t\tvoid _setSFDMode(SFDMode mode)\n\t\t{\n\t\t\tswitch (mode)\n\t\t\t{\n\t\t\tcase SFDMode::STANDARD_SFD:\n\t\t\t\tDW1000NgUtils::setBit(_chanctrl, LEN_CHAN_CTRL, DWSFD_BIT, false);\n\t\t\t\tDW1000NgUtils::setBit(_chanctrl, LEN_CHAN_CTRL, TNSSFD_BIT, false);\n\t\t\t\tDW1000NgUtils::setBit(_chanctrl, LEN_CHAN_CTRL, RNSSFD_BIT, false);\n\t\t\t\t_standardSFD = true;\n\t\t\t\tbreak;\n\t\t\tcase SFDMode::DECAWAVE_SFD:\n\t\t\t\tDW1000NgUtils::setBit(_chanctrl, LEN_CHAN_CTRL, DWSFD_BIT, true);\n\t\t\t\tDW1000NgUtils::setBit(_chanctrl, LEN_CHAN_CTRL, TNSSFD_BIT, true);\n\t\t\t\tDW1000NgUtils::setBit(_chanctrl, LEN_CHAN_CTRL, RNSSFD_BIT, true);\n\t\t\t\t_standardSFD = false;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn; // TODO Proper error handling\n\t\t\t}\n\t\t}\n\n\t\tvoid _setChannel(Channel channel)\n\t\t{\n\t\t\tbyte chan = static_cast<byte>(channel);\n\t\t\tchan &= 0xF;\n\t\t\t_chanctrl[0] = ((chan | (chan << 4)) & 0xFF);\n\n\t\t\t_channel = channel;\n\t\t}\n\n\t\tvoid _setDataRate(DataRate data_rate)\n\t\t{\n\t\t\tbyte rate = static_cast<byte>(data_rate);\n\t\t\trate &= 0x03;\n\t\t\t_txfctrl[1] &= 0x83;\n\t\t\t_txfctrl[1] |= (byte)((rate << 5) & 0xFF);\n\t\t\t// special 110kbps flag\n\t\t\tif (data_rate == DataRate::RATE_110KBPS)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, RXM110K_BIT, true);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, RXM110K_BIT, false);\n\t\t\t}\n\t\t\t_dataRate = data_rate;\n\t\t}\n\n\t\tvoid _setPulseFrequency(PulseFrequency frequency)\n\t\t{\n\t\t\tbyte freq = static_cast<byte>(frequency);\n\t\t\tfreq &= 0x03;\n\t\t\t_txfctrl[2] &= 0xFC;\n\t\t\t_txfctrl[2] |= (byte)(freq & 0xFF);\n\t\t\t_chanctrl[2] &= 0xF3;\n\t\t\t_chanctrl[2] |= (byte)((freq << 2) & 0xFF);\n\n\t\t\t_pulseFrequency = frequency;\n\t\t}\n\n\t\tvoid _setPreambleLength(PreambleLength preamble_length)\n\t\t{\n\t\t\tbyte prealen = static_cast<byte>(preamble_length);\n\t\t\tprealen &= 0x0F;\n\t\t\t_txfctrl[2] &= 0xC3;\n\t\t\t_txfctrl[2] |= (byte)((prealen << 2) & 0xFF);\n\n\t\t\tswitch (preamble_length)\n\t\t\t{\n\t\t\tcase PreambleLength::LEN_64:\n\t\t\t\t_pacSize = PacSize::SIZE_8;\n\t\t\t\tbreak;\n\t\t\tcase PreambleLength::LEN_128:\n\t\t\t\t_pacSize = PacSize::SIZE_8;\n\t\t\t\tbreak;\n\t\t\tcase PreambleLength::LEN_256:\n\t\t\t\t_pacSize = PacSize::SIZE_16;\n\t\t\t\tbreak;\n\t\t\tcase PreambleLength::LEN_512:\n\t\t\t\t_pacSize = PacSize::SIZE_16;\n\t\t\t\tbreak;\n\t\t\tcase PreambleLength::LEN_1024:\n\t\t\t\t_pacSize = PacSize::SIZE_32;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t_pacSize = PacSize::SIZE_64; // In case of 1536, 2048 or 4096 preamble length.\n\t\t\t}\n\n\t\t\t_preambleLength = preamble_length;\n\t\t}\n\n\t\tvoid _setPreambleCode(PreambleCode preamble_code)\n\t\t{\n\t\t\tbyte preacode = static_cast<byte>(preamble_code);\n\t\t\tpreacode &= 0x1F;\n\t\t\t_chanctrl[2] &= 0x3F;\n\t\t\t_chanctrl[2] |= ((preacode << 6) & 0xFF);\n\t\t\t_chanctrl[3] = 0x00;\n\t\t\t_chanctrl[3] = ((((preacode >> 2) & 0x07) | (preacode << 3)) & 0xFF);\n\n\t\t\t_preambleCode = preamble_code;\n\t\t}\n\n\t\tboolean _checkPreambleCodeValidity()\n\t\t{\n\t\t\tbyte preacode = static_cast<byte>(_preambleCode);\n\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t{\n\t\t\t\tfor (auto i = 0; i < 2; i++)\n\t\t\t\t{\n\t\t\t\t\tif (preacode == preamble_validity_matrix_PRF16[(int)_channel][i])\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t{\n\t\t\t\tfor (auto i = 0; i < 4; i++)\n\t\t\t\t{\n\t\t\t\t\tif (preacode == preamble_validity_matrix_PRF64[(int)_channel][i])\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn false; // TODO Proper error handling\n\t\t\t}\n\t\t}\n\n\t\tvoid _setValidPreambleCode()\n\t\t{\n\t\t\tPreambleCode preamble_code;\n\n\t\t\tswitch (_channel)\n\t\t\t{\n\t\t\tcase Channel::CHANNEL_1:\n\t\t\t\tpreamble_code = _pulseFrequency == PulseFrequency::FREQ_16MHZ ? PreambleCode::CODE_2 : PreambleCode::CODE_10;\n\t\t\t\tbreak;\n\t\t\tcase Channel::CHANNEL_3:\n\t\t\t\tpreamble_code = _pulseFrequency == PulseFrequency::FREQ_16MHZ ? PreambleCode::CODE_6 : PreambleCode::CODE_10;\n\t\t\t\tbreak;\n\t\t\tcase Channel::CHANNEL_4:\n\t\t\tcase Channel::CHANNEL_7:\n\t\t\t\tpreamble_code = _pulseFrequency == PulseFrequency::FREQ_16MHZ ? PreambleCode::CODE_8 : PreambleCode::CODE_18;\n\t\t\t\tbreak;\n\t\t\tcase Channel::CHANNEL_2:\n\t\t\tcase Channel::CHANNEL_5:\n\t\t\t\tpreamble_code = _pulseFrequency == PulseFrequency::FREQ_16MHZ ? PreambleCode::CODE_3 : PreambleCode::CODE_10;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn; // TODO Proper Error Handling\n\t\t\t}\n\t\t\tbyte preacode = static_cast<byte>(preamble_code);\n\t\t\tpreacode &= 0x1F;\n\t\t\t_chanctrl[2] &= 0x3F;\n\t\t\t_chanctrl[2] |= ((preacode << 6) & 0xFF);\n\t\t\t_chanctrl[3] = 0x00;\n\t\t\t_chanctrl[3] = ((((preacode >> 2) & 0x07) | (preacode << 3)) & 0xFF);\n\n\t\t\t_preambleCode = preamble_code;\n\t\t}\n\n\t\tvoid _setNonStandardSFDLength()\n\t\t{\n\t\t\tswitch (_dataRate)\n\t\t\t{\n\t\t\tcase DataRate::RATE_6800KBPS:\n\t\t\t\t_writeByte(USR_SFD, SFD_LENGTH_SUB, 0x08);\n\t\t\t\tbreak;\n\t\t\tcase DataRate::RATE_850KBPS:\n\t\t\t\t_writeByte(USR_SFD, SFD_LENGTH_SUB, 0x10);\n\t\t\t\tbreak;\n\t\t\tcase DataRate::RATE_110KBPS:\n\t\t\t\t_writeByte(USR_SFD, SFD_LENGTH_SUB, 0x40);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn; // TODO Proper error handling\n\t\t\t}\n\t\t}\n\n\t\tvoid _interruptOnSent(boolean val)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_MASK, TXFRS_BIT, val);\n\t\t}\n\n\t\tvoid _interruptOnReceived(boolean val)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_MASK, RXDFR_BIT, val);\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_MASK, RXFCG_BIT, val);\n\t\t}\n\n\t\tvoid _interruptOnReceiveFailed(boolean val)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_STATUS, RXPHE_BIT, val);\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_STATUS, RXFCE_BIT, val);\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_STATUS, RXRFSL_BIT, val);\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_STATUS, LDEERR_BIT, val);\n\t\t}\n\n\t\tvoid _interruptOnReceiveTimeout(boolean val)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_MASK, RXRFTO_BIT, val);\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_MASK, RXPTO_BIT, val);\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_MASK, RXSFDTO_BIT, val);\n\t\t}\n\n\t\tvoid _interruptOnReceiveTimestampAvailable(boolean val)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_MASK, LDEDONE_BIT, val);\n\t\t}\n\n\t\tvoid _interruptOnAutomaticAcknowledgeTrigger(boolean val)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_MASK, AAT_BIT, val);\n\t\t}\n\n\t\tvoid _manageLDE()\n\t\t{\n\t\t\t// transfer any ldo tune values\n\t\t\tbyte ldoTune[LEN_OTP_RDAT];\n\t\t\tuint16_t LDOTUNE_ADDRESS = 0x04;\n\t\t\t_readBytesOTP(LDOTUNE_ADDRESS, ldoTune); // TODO #define\n\t\t\tif (ldoTune[0] != 0)\n\t\t\t{\n\t\t\t\t// TODO tuning available, copy over to RAM: use OTP_LDO bit\n\t\t\t}\n\t\t\t// tell the chip to load the LDE microcode\n\t\t\t// TODO remove clock-related code (PMSC_CTRL) as handled separately\n\t\t\tbyte pmscctrl0[LEN_PMSC_CTRL0];\n\t\t\tbyte otpctrl[LEN_OTP_CTRL];\n\t\t\tmemset(pmscctrl0, 0, LEN_PMSC_CTRL0);\n\t\t\tmemset(otpctrl, 0, LEN_OTP_CTRL);\n\t\t\t_readBytes(PMSC, PMSC_CTRL0_SUB, pmscctrl0, LEN_PMSC_CTRL0);\n\t\t\t_readBytes(OTP_IF, OTP_CTRL_SUB, otpctrl, LEN_OTP_CTRL);\n\t\t\tpmscctrl0[0] = 0x01;\n\t\t\tpmscctrl0[1] = 0x03;\n\t\t\totpctrl[1] = 0x80;\n\t\t\t_writeBytesToRegister(PMSC, PMSC_CTRL0_SUB, pmscctrl0, 2);\n\t\t\t// uCode\n\t\t\t_enableClock(LDE_CLOCK);\n\t\t\tdelay(5);\n\t\t\t_writeBytesToRegister(OTP_IF, OTP_CTRL_SUB, otpctrl, 2);\n\t\t\tdelay(1);\n\t\t\t_enableClock(SYS_AUTO_CLOCK);\n\t\t\tdelay(5);\n\t\t\tpmscctrl0[0] = 0x00;\n\t\t\tpmscctrl0[1] &= 0x02;\n\t\t\t_writeBytesToRegister(PMSC, PMSC_CTRL0_SUB, pmscctrl0, 2);\n\t\t}\n\n\t\t/* Crystal calibration from OTP (if available)\n\t\t * FS_XTALT - reg:0x2B, sub-reg:0x0E\n\t\t * OTP(one-time-programmable) memory map - table 10 */\n\t\tvoid _fsxtalt()\n\t\t{\n\t\t\tbyte fsxtalt[LEN_FS_XTALT];\n\t\t\tbyte buf_otp[4];\n\t\t\t_readBytesOTP(0x01E, buf_otp); // 0x01E -> byte[0]=XTAL_Trim\n\t\t\tif (buf_otp[0] == 0)\n\t\t\t{\n\t\t\t\t// No trim value available from OTP, use midrange value of 0x10\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fsxtalt, ((0x10 & 0x1F) | 0x60), LEN_FS_XTALT);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fsxtalt, ((buf_otp[0] & 0x1F) | 0x60), LEN_FS_XTALT);\n\t\t\t}\n\t\t\t// write configuration back to chip\n\t\t\t_writeBytesToRegister(FS_CTRL, FS_XTALT_SUB, fsxtalt, LEN_FS_XTALT);\n\t\t}\n\n\t\tvoid _clearReceiveStatus()\n\t\t{\n\t\t\t// clear latched RX bits (i.e. write 1 to clear)\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXDFR_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXFCG_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXPRD_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXSFDD_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXPHD_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, LDEDONE_BIT, true);\n\t\t\t_writeBytesToRegister(SYS_STATUS, NO_SUB, _sysstatus, LEN_SYS_STATUS);\n\t\t}\n\n\t\tvoid _clearReceiveTimestampAvailableStatus()\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, LDEDONE_BIT, true);\n\t\t\t_writeBytesToRegister(SYS_STATUS, NO_SUB, _sysstatus, LEN_SYS_STATUS);\n\t\t}\n\n\t\tvoid _clearReceiveTimeoutStatus()\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXRFTO_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXPTO_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXSFDTO_BIT, true);\n\t\t\t_writeBytesToRegister(SYS_STATUS, NO_SUB, _sysstatus, LEN_SYS_STATUS);\n\t\t}\n\n\t\tvoid _clearReceiveFailedStatus()\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXPHE_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXFCE_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXRFSL_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, AFFREJ_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, LDEERR_BIT, true);\n\t\t\t_writeBytesToRegister(SYS_STATUS, NO_SUB, _sysstatus, LEN_SYS_STATUS);\n\t\t}\n\n\t\tvoid _clearTransmitStatus()\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, AAT_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, TXFRB_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, TXPRS_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, TXPHS_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, TXFRS_BIT, true);\n\t\t\t_writeBytesToRegister(SYS_STATUS, NO_SUB, _sysstatus, LEN_SYS_STATUS);\n\t\t}\n\n\t\tvoid _resetReceiver()\n\t\t{\n\t\t\t/* Set to 0 only bit 28 */\n\t\t\t_writeToRegister(PMSC, PMSC_SOFTRESET_SUB, 0xE0, LEN_PMSC_SOFTRESET);\n\t\t\t/* Set SOFTRESET to all ones */\n\t\t\t_writeToRegister(PMSC, PMSC_SOFTRESET_SUB, 0xF0, LEN_PMSC_SOFTRESET);\n\t\t}\n\n\t\t/* Internal helpers to read configuration */\n\n\t\tvoid _readSystemConfigurationRegister()\n\t\t{\n\t\t\t_readBytes(SYS_CFG, NO_SUB, _syscfg, LEN_SYS_CFG);\n\t\t}\n\n\t\tvoid _readSystemEventStatusRegister()\n\t\t{\n\t\t\t_readBytes(SYS_STATUS, NO_SUB, _sysstatus, LEN_SYS_STATUS);\n\t\t}\n\n\t\tvoid _readNetworkIdAndDeviceAddress()\n\t\t{\n\t\t\t_readBytes(PANADR, NO_SUB, _networkAndAddress, LEN_PANADR);\n\t\t}\n\n\t\tvoid _readSystemEventMaskRegister()\n\t\t{\n\t\t\t_readBytes(SYS_MASK, NO_SUB, _sysmask, LEN_SYS_MASK);\n\t\t}\n\n\t\tvoid _readChannelControlRegister()\n\t\t{\n\t\t\t_readBytes(CHAN_CTRL, NO_SUB, _chanctrl, LEN_CHAN_CTRL);\n\t\t}\n\n\t\tvoid _readTransmitFrameControlRegister()\n\t\t{\n\t\t\t_readBytes(TX_FCTRL, NO_SUB, _txfctrl, LEN_TX_FCTRL);\n\t\t}\n\n\t\tboolean _isTransmitDone()\n\t\t{\n\t\t\treturn DW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, TXFRS_BIT);\n\t\t}\n\n\t\tboolean _isReceiveTimestampAvailable()\n\t\t{\n\t\t\treturn DW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, LDEDONE_BIT);\n\t\t}\n\n\t\tboolean _isReceiveDone()\n\t\t{\n\t\t\tif (_frameCheck)\n\t\t\t{\n\t\t\t\treturn (DW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXFCG_BIT) &&\n\t\t\t\t\t\tDW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXDFR_BIT));\n\t\t\t}\n\t\t\treturn DW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXDFR_BIT);\n\t\t}\n\n\t\tboolean _isReceiveFailed()\n\t\t{\n\t\t\treturn (DW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXPHE_BIT) ||\n\t\t\t\t\tDW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXFCE_BIT) ||\n\t\t\t\t\tDW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXRFSL_BIT) ||\n\t\t\t\t\tDW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, LDEERR_BIT));\n\t\t}\n\n\t\tboolean _isReceiveTimeout()\n\t\t{\n\t\t\treturn (DW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXRFTO_BIT) ||\n\t\t\t\t\tDW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXPTO_BIT) ||\n\t\t\t\t\tDW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXSFDTO_BIT));\n\t\t}\n\n\t\tboolean _isClockProblem()\n\t\t{\n\t\t\treturn (DW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, CLKPLL_LL_BIT) ||\n\t\t\t\t\tDW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RFPLL_LL_BIT));\n\t\t}\n\n\t\tvoid _disableSequencing()\n\t\t{\n\t\t\t_enableClock(SYS_XTI_CLOCK);\n\t\t\tbyte zero[2];\n\t\t\tDW1000NgUtils::writeValueToBytes(zero, 0x0000, 2);\n\t\t\t_writeBytesToRegister(PMSC, PMSC_CTRL1_SUB, zero, 2); // To re-enable write 0xE7\n\t\t}\n\n\t\tvoid _configureRFTransmitPowerSpectrumTestMode()\n\t\t{\n\t\t\t/* Enabled TXFEN, PLLFEN, LDOFEN and set TXRXSW to TX */\n\t\t\tbyte enable_mask[4];\n\t\t\tDW1000NgUtils::writeValueToBytes(enable_mask, 0x005FFF00, LEN_RX_CONF_SUB);\n\t\t\t_writeBytesToRegister(RF_CONF, RF_CONF_SUB, enable_mask, LEN_RX_CONF_SUB);\n\t\t}\n\n\t\tvoid _uploadConfigToAON()\n\t\t{\n\t\t\t/* Write 1 in UPL_CFG_BIT */\n\t\t\t_writeToRegister(AON, AON_CTRL_SUB, 0x04, LEN_AON_CTRL);\n\t\t\t/* Clear the register */\n\t\t\t_writeToRegister(AON, AON_CTRL_SUB, 0x00, LEN_AON_CTRL);\n\t\t}\n\t}\n\n\t/* ####################### PUBLIC ###################### */\n\n\tvoid initialize(uint8_t ss, uint8_t irq, uint8_t rst)\n\t{\n\t\t// generous initial init/wake-up-idle delay\n\t\tdelay(5);\n\t\t_ss = ss;\n\t\t_irq = irq;\n\t\t_rst = rst;\n\n\t\tif (rst != 0xff)\n\t\t{\n\t\t\t// DW1000 data sheet v2.08 Â§5.6.1 page 20, the RSTn pin should not be driven high but left floating.\n\t\t\tpinMode(_rst, INPUT);\n\t\t}\n\n\t\tSPIporting::SPIinit();\n\t\t// pin and basic member setup\n\t\t// attach interrupt\n\t\t// TODO throw error if pin is not a interrupt pin\n\t\tif (_irq != 0xff)\n\t\t{\n\t\t\tattachInterrupt(digitalPinToInterrupt(_irq), interruptServiceRoutine, RISING);\n\t\t\t// attachInterrupt(digitalPinToInterrupt(_irq), interruptServiceRoutine, FALLING);\n\t\t}\n\n\t\tSPIporting::SPIselect(_ss, _irq);\n\t\t// reset chip (either soft or hard)\n\t\treset();\n\n\t\tSPIporting::setSPIspeed(SPIClock::SLOW);\n\t\t_enableClock(SYS_XTI_CLOCK);\n\t\tdelay(5);\n\n\t\t// Configure the CPLL lock detect\n\t\t_writeBitToRegister(EXT_SYNC, EC_CTRL_SUB, LEN_EC_CTRL, PLLLDT_BIT, true);\n\n\t\t// Configure XTAL trim\n\t\t_fsxtalt();\n\n\t\t// load LDE micro-code\n\t\t_manageLDE();\n\n\t\t// read the temp and vbat readings from OTP that were recorded during production test\n\t\t// see 6.3.1 OTP memory map\n\t\tbyte buf_otp[4];\n\t\t_readBytesOTP(0x008, buf_otp); // the stored 3.3 V reading\n\t\t_vmeas3v3 = buf_otp[0];\n\t\t// Serial.printf(\"_vmeas3v3=%d\\r\\n\", _vmeas3v3);\n\t\t_readBytesOTP(0x009, buf_otp); // the stored 23C reading\n\t\t_tmeas23C = buf_otp[0];\n\t\t// Serial.printf(\"_tmeas23C=%d\\r\\n\", _tmeas23C);\n\n\t\t_enableClock(SYS_AUTO_CLOCK);\n\t\tdelay(5);\n\t\tSPIporting::setSPIspeed(SPIClock::FAST);\n\n\t\t_readNetworkIdAndDeviceAddress();\n\t\t_readSystemConfigurationRegister();\n\t\t_readChannelControlRegister();\n\t\t_readTransmitFrameControlRegister();\n\t\t_readSystemEventMaskRegister();\n\n\t\t/* Cleared AON:CFG1(0x2C:0x0A) for proper operation of deepSleep */\n\t\t_writeToRegister(AON, AON_CFG1_SUB, 0x00, LEN_AON_CFG1);\n\t}\n\n\tvoid initializeNoInterrupt(uint8_t ss, uint8_t rst)\n\t{\n\t\tinitialize(ss, 0xff, rst);\n\t}\n\n\t/* callback handler management. */\n\tvoid attachErrorHandler(void (*handleError)(void))\n\t{\n\t\t_handleError = handleError;\n\t}\n\n\tvoid attachSentHandler(void (*handleSent)(void))\n\t{\n\t\t_handleSent = handleSent;\n\t}\n\n\tvoid attachReceivedHandler(void (*handleReceived)(void))\n\t{\n\t\t_handleReceived = handleReceived;\n\t}\n\n\tvoid attachReceiveFailedHandler(void (*handleReceiveFailed)(void))\n\t{\n\t\t_handleReceiveFailed = handleReceiveFailed;\n\t}\n\n\tvoid attachReceiveTimeoutHandler(void (*handleReceiveTimeout)(void))\n\t{\n\t\t_handleReceiveTimeout = handleReceiveTimeout;\n\t}\n\n\tvoid attachReceiveTimestampAvailableHandler(void (*handleReceiveTimestampAvailable)(void))\n\t{\n\t\t_handleReceiveTimestampAvailable = handleReceiveTimestampAvailable;\n\t}\n\n\tvoid interruptServiceRoutine()\n\t{\n\t\t// Serial.printf(\"test----------------------------0\\r\\n\");\n\t\t// read current status and handle via callbacks\n\t\t_readSystemEventStatusRegister();\n\t\tif (_isClockProblem() /* TODO and others */ && _handleError != 0)\n\t\t{\n\t\t\t(*_handleError)();\n\t\t\t// Serial.printf(\"interrupt----------------------------1\\r\\n\");\n\t\t}\n\t\tif (_isTransmitDone())\n\t\t{\n\t\t\t_clearTransmitStatus();\n\t\t\tif (_handleSent != nullptr)\n\t\t\t{\n\t\t\t\t(*_handleSent)();\n\t\t\t\t// Serial.printf(\"interrupt----------------------------2\\r\\n\");\n\t\t\t}\n\t\t}\n\t\tif (_isReceiveTimestampAvailable())\n\t\t{\n\t\t\t_clearReceiveTimestampAvailableStatus();\n\t\t\tif (_handleReceiveTimestampAvailable != nullptr)\n\t\t\t{\n\t\t\t\t(*_handleReceiveTimestampAvailable)();\n\t\t\t\t// Serial.printf(\"interrupt----------------------------3\\r\\n\");\n\t\t\t}\n\t\t}\n\t\tif (_isReceiveFailed())\n\t\t{\n\t\t\t_clearReceiveFailedStatus();\n\t\t\tforceTRxOff();\n\t\t\t_resetReceiver();\n\t\t\tif (_handleReceiveFailed != nullptr)\n\t\t\t{\n\t\t\t\t(*_handleReceiveFailed)();\n\t\t\t\t// Serial.printf(\"interrupt----------------------------4\\r\\n\");\n\t\t\t}\n\t\t}\n\t\telse if (_isReceiveTimeout())\n\t\t{\n\t\t\t_clearReceiveTimeoutStatus();\n\t\t\tforceTRxOff();\n\t\t\t_resetReceiver();\n\t\t\tif (_handleReceiveTimeout != nullptr)\n\t\t\t{\n\t\t\t\t(*_handleReceiveTimeout)();\n\t\t\t\t// Serial.printf(\"interrupt----------------------------5\\r\\n\");\n\t\t\t}\n\t\t}\n\t\telse if (_isReceiveDone())\n\t\t{\n\t\t\t_clearReceiveStatus();\n\t\t\tif (_handleReceived != nullptr)\n\t\t\t{\n\t\t\t\t(*_handleReceived)();\n\t\t\t\t// Serial.printf(\"interrupt----------------------------6\\r\\n\");\n\t\t\t}\n\t\t}\n\t\t// Latched bits in status register are reset by writing 1 to them\n\t\tmemset(_sysstatus, 0xff, LEN_SYS_STATUS);\n\t\t_writeBytesToRegister(SYS_STATUS, NO_SUB, _sysstatus, LEN_SYS_STATUS);\n\t}\n\n\tboolean isTransmitDone()\n\t{\n\t\t_readSystemEventStatusRegister();\n\t\treturn _isTransmitDone();\n\t}\n\n\tvoid clearTransmitStatus()\n\t{\n\t\t_clearTransmitStatus();\n\t}\n\n\tboolean isReceiveDone()\n\t{\n\t\t_readSystemEventStatusRegister();\n\t\treturn _isReceiveDone();\n\t}\n\n\tvoid clearReceiveStatus()\n\t{\n\t\t_clearReceiveStatus();\n\t}\n\n\tboolean isReceiveFailed()\n\t{\n\t\t_readSystemEventStatusRegister();\n\t\treturn _isReceiveFailed();\n\t}\n\n\tvoid clearReceiveFailedStatus()\n\t{\n\t\t_clearReceiveFailedStatus();\n\t\tforceTRxOff();\n\t\t_resetReceiver();\n\t}\n\n\tboolean isReceiveTimeout()\n\t{\n\t\t_readSystemEventMaskRegister();\n\t\treturn _isReceiveTimeout();\n\t}\n\n\tvoid clearReceiveTimeoutStatus()\n\t{\n\t\t_clearReceiveTimeoutStatus();\n\t\tforceTRxOff();\n\t\t_resetReceiver();\n\t}\n\n\tvoid enableDebounceClock()\n\t{\n\t\tbyte pmscctrl0[LEN_PMSC_CTRL0];\n\t\tmemset(pmscctrl0, 0, LEN_PMSC_CTRL0);\n\t\t_readBytes(PMSC, PMSC_CTRL0_SUB, pmscctrl0, LEN_PMSC_CTRL0);\n\t\tDW1000NgUtils::setBit(pmscctrl0, LEN_PMSC_CTRL0, GPDCE_BIT, 1);\n\t\tDW1000NgUtils::setBit(pmscctrl0, LEN_PMSC_CTRL0, KHZCLKEN_BIT, 1);\n\t\t_writeBytesToRegister(PMSC, PMSC_CTRL0_SUB, pmscctrl0, LEN_PMSC_CTRL0);\n\t\t_debounceClockEnabled = true;\n\t}\n\n\tvoid enableLedBlinking()\n\t{\n\t\tbyte pmscledc[LEN_PMSC_LEDC];\n\t\tmemset(pmscledc, 0, LEN_PMSC_LEDC);\n\t\t_readBytes(PMSC, PMSC_LEDC_SUB, pmscledc, LEN_PMSC_LEDC);\n\t\tDW1000NgUtils::setBit(pmscledc, LEN_PMSC_LEDC, BLNKEN, 1);\n\t\t_writeBytesToRegister(PMSC, PMSC_LEDC_SUB, pmscledc, LEN_PMSC_LEDC);\n\t}\n\n\tvoid setGPIOMode(uint8_t msgp, uint8_t mode)\n\t{\n\t\tbyte gpiomode[LEN_GPIO_MODE];\n\t\tmemset(gpiomode, 0, LEN_GPIO_MODE);\n\t\t_readBytes(GPIO_CTRL, GPIO_MODE_SUB, gpiomode, LEN_GPIO_MODE);\n\t\tfor (char i = 0; i < 2; i++)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(gpiomode, LEN_GPIO_MODE, msgp + i, (mode >> i) & 1);\n\t\t}\n\t\t_writeBytesToRegister(GPIO_CTRL, GPIO_MODE_SUB, gpiomode, LEN_GPIO_MODE);\n\t}\n\n\tvoid applySleepConfiguration(sleep_configuration_t sleep_config)\n\t{\n\t\tbyte aon_wcfg[LEN_AON_WCFG];\n\t\t_readBytes(AON, AON_WCFG_SUB, aon_wcfg, LEN_AON_WCFG);\n\t\tbyte aon_cfg0[1];\n\t\tmemset(aon_cfg0, 0, 1);\n\n\t\tDW1000NgUtils::setBit(aon_wcfg, LEN_AON_WCFG, ONW_RADC_BIT, sleep_config.onWakeUpRunADC);\n\t\tDW1000NgUtils::setBit(aon_wcfg, LEN_AON_WCFG, ONW_RX_BIT, sleep_config.onWakeUpReceive);\n\t\tDW1000NgUtils::setBit(aon_wcfg, LEN_AON_WCFG, ONW_LEUI_BIT, sleep_config.onWakeUpLoadEUI);\n\t\tDW1000NgUtils::setBit(aon_wcfg, LEN_AON_WCFG, ONW_LDC_BIT, true);\n\t\tDW1000NgUtils::setBit(aon_wcfg, LEN_AON_WCFG, ONW_L64P_BIT, sleep_config.onWakeUpLoadL64Param);\n\t\tDW1000NgUtils::setBit(aon_wcfg, LEN_AON_WCFG, ONW_PRES_SLEEP_BIT, sleep_config.preserveSleep);\n\t\tDW1000NgUtils::setBit(aon_wcfg, LEN_AON_WCFG, ONW_LLDE_BIT, true);\n\t\tDW1000NgUtils::setBit(aon_wcfg, LEN_AON_WCFG, ONW_LLDO_BIT, true);\n\t\t_writeBytesToRegister(AON, AON_WCFG_SUB, aon_wcfg, LEN_AON_WCFG);\n\n\t\tDW1000NgUtils::setBit(aon_cfg0, 1, WAKE_PIN_BIT, sleep_config.enableWakePIN);\n\t\tDW1000NgUtils::setBit(aon_cfg0, 1, WAKE_SPI_BIT, sleep_config.enableWakeSPI);\n\t\tDW1000NgUtils::setBit(aon_cfg0, 1, WAKE_CNT_BIT, false);\n\t\tDW1000NgUtils::setBit(aon_cfg0, 1, SLEEP_EN_BIT, sleep_config.enableSLP);\n\t\t_writeBytesToRegister(AON, AON_CFG0_SUB, aon_cfg0, 1); // Deletes 3 bits of the unused LPCLKDIVA\n\t}\n\n\t/*Puts the device into sleep/deepSleep mode. This function also upload sleep config to AON. */\n\tvoid deepSleep()\n\t{\n\t\t/* Clear the register */\n\t\t_writeToRegister(AON, AON_CTRL_SUB, 0x00, LEN_AON_CTRL);\n\t\t/* Write 1 in SAVE_BIT */\n\t\t_writeToRegister(AON, AON_CTRL_SUB, 0x02, LEN_AON_CTRL);\n\t}\n\n\tvoid spiWakeup()\n\t{\n\t\tbyte deviceId[LEN_DEV_ID];\n\t\tbyte expectedDeviceId[LEN_DEV_ID];\n\t\tDW1000NgUtils::writeValueToBytes(expectedDeviceId, 0xDECA0130, LEN_DEV_ID);\n\t\t_readBytes(DEV_ID, NO_SUB, deviceId, LEN_DEV_ID);\n\t\tif (memcmp(deviceId, expectedDeviceId, LEN_DEV_ID))\n\t\t{\n\t\t\tdigitalWrite(_ss, LOW);\n\t\t\tdelay(1);\n\t\t\tdigitalWrite(_ss, HIGH);\n\t\t\tdelay(5);\n\t\t\tsetTxAntennaDelay(_antennaTxDelay);\n\t\t\tif (_debounceClockEnabled)\n\t\t\t{\n\t\t\t\tenableDebounceClock();\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid reset()   \n\t{\n\t\tif (_rst == 0xff)\n\t\t{ /* Fallback to Software Reset */\n\t\t\tsoftwareReset();\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// DW1000Ng data sheet v2.08 Â§5.6.1 page 20, the RSTn pin should not be driven high but left floating.\n\t\t\tpinMode(_rst, OUTPUT);\n\t\t\tdigitalWrite(_rst, LOW);\n\t\t\tdelay(2); // DW1000Ng data sheet v2.08 Â§5.6.1 page 20: nominal 50ns, to be safe take more time\n\t\t\tpinMode(_rst, INPUT);\n\t\t\tdelay(5); // dw1000Ng data sheet v1.2 page 5: nominal 3 ms, to be safe take more time\n\t\t}\n\t}\n\n\tvoid softwareReset()\n\t{\n\t\tSPIporting::setSPIspeed(SPIClock::SLOW);\n\n\t\t/* Disable sequencing and go to state \"INIT\" - (a) Sets SYSCLKS to 01 */\n\t\t_disableSequencing();\n\t\t/* Clear AON and WakeUp configuration */\n\t\t_writeToRegister(AON, AON_WCFG_SUB, 0x00, LEN_AON_WCFG);\n\t\t_writeToRegister(AON, AON_CFG0_SUB, 0x00, LEN_AON_CFG0);\n\t\t// TODO change this with uploadToAON\n\t\t_writeToRegister(AON, AON_CTRL_SUB, 0x00, LEN_AON_CTRL);\n\t\t_writeToRegister(AON, AON_CTRL_SUB, 0x02, LEN_AON_CTRL);\n\t\t/* (b) Clear SOFTRESET to all zeroâ€™s */\n\t\t_writeToRegister(PMSC, PMSC_SOFTRESET_SUB, 0x00, LEN_PMSC_SOFTRESET);\n\t\tdelay(1);\n\t\t/* (c) Set SOFTRESET to all ones */\n\t\t_writeToRegister(PMSC, PMSC_SOFTRESET_SUB, 0xF0, LEN_PMSC_SOFTRESET);\n\t}\n\n\t/* ###########################################################################\n\t * #### Pretty printed device information ####################################\n\t * ######################################################################### */\n\n\tvoid getPrintableDeviceIdentifier(char msgBuffer[])\n\t{\n\t\tbyte data[LEN_DEV_ID];\n\t\t_readBytes(DEV_ID, NO_SUB, data, LEN_DEV_ID);\n\t\tsprintf(msgBuffer, \"%02X - model: %d, version: %d, revision: %d\",\n\t\t\t\t(uint16_t)((data[3] << 8) | data[2]), data[1], (data[0] >> 4) & 0x0F, data[0] & 0x0F);\n\t}\n\n\tvoid getPrintableExtendedUniqueIdentifier(char msgBuffer[])\n\t{\n\t\tbyte data[LEN_EUI];\n\t\t_readBytes(EUI, NO_SUB, data, LEN_EUI);\n\t\tsprintf(msgBuffer, \"%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X\",\n\t\t\t\tdata[7], data[6], data[5], data[4], data[3], data[2], data[1], data[0]);\n\t}\n\n\tvoid getPrintableNetworkIdAndShortAddress(char msgBuffer[])\n\t{\n\t\tbyte data[LEN_PANADR];\n\t\t_readBytes(PANADR, NO_SUB, data, LEN_PANADR);\n\t\tsprintf(msgBuffer, \"PAN: %02X, Short Address: %02X\",\n\t\t\t\t(uint16_t)((data[3] << 8) | data[2]), (uint16_t)((data[1] << 8) | data[0]));\n\t}\n\n\tvoid getPrintableDeviceMode(char msgBuffer[])\n\t{\n\t\tuint16_t dr;\n\t\tuint8_t prf;\n\t\tuint16_t plen;\n\t\tuint8_t pcode;\n\t\tuint8_t ch;\n\t\tbyte chan_ctrl[LEN_CHAN_CTRL];\n\t\tbyte tx_fctrl[LEN_TX_FCTRL];\n\t\t_readBytes(CHAN_CTRL, NO_SUB, chan_ctrl, LEN_CHAN_CTRL);\n\t\t_readBytes(TX_FCTRL, NO_SUB, tx_fctrl, LEN_TX_FCTRL);\n\t\t/* Data Rate from 0x08 bits:13-14(tx_fctrl) */\n\t\tdr = (uint16_t)(tx_fctrl[1] >> 5 & 0x3);\n\t\tswitch (dr)\n\t\t{\n\t\tcase 0x00:\n\t\t\tdr = 110;\n\t\t\tbreak;\n\t\tcase 0x01:\n\t\t\tdr = 850;\n\t\t\tbreak;\n\t\tcase 0x02:\n\t\t\tdr = 6800;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn; // TODO Error handling\n\t\t}\n\t\t/* PRF(16 or 64) from 0x1F bits:18-19(chan_ctrl) */\n\t\tprf = (uint8_t)(chan_ctrl[2] >> 2 & 0x03);\n\t\tif (prf == 0x01)\n\t\t{\n\t\t\tprf = 16;\n\t\t}\n\t\telse if (prf == 0x02)\n\t\t{\n\t\t\tprf = 64;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn; // TODO Error handling\n\t\t}\n\t\t/* PreambleLength from 0x08 bits:18-21(tx_fctrl) */\n\t\tplen = (uint16_t)(tx_fctrl[2] >> 2 & 0xF);\n\t\tswitch (plen)\n\t\t{\n\t\tcase 0x01:\n\t\t\tplen = 64;\n\t\t\tbreak;\n\t\tcase 0x05:\n\t\t\tplen = 128;\n\t\t\tbreak;\n\t\tcase 0x09:\n\t\t\tplen = 256;\n\t\t\tbreak;\n\t\tcase 0x0D:\n\t\t\tplen = 512;\n\t\t\tbreak;\n\t\tcase 0x02:\n\t\t\tplen = 1024;\n\t\t\tbreak;\n\t\tcase 0x06:\n\t\t\tplen = 1536;\n\t\t\tbreak;\n\t\tcase 0x0A:\n\t\t\tplen = 2048;\n\t\t\tbreak;\n\t\tcase 0x03:\n\t\t\tplen = 4096;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn; // TODO Error handling\n\t\t}\n\t\t/* Channel from 0x1F bits:0-4(tx_chan) */\n\t\tch = (uint8_t)(chan_ctrl[0] & 0xF);\n\t\t/* Preamble Code from 0x1F bits:24-31(chan_ctrl) */\n\t\tpcode = (uint8_t)(chan_ctrl[3] >> 3 & 0x1F);\n\t\tsprintf(msgBuffer, \"Data rate: %u kb/s, PRF: %u MHz, Preamble: %u symbols, Channel: #%u, Preamble code #%u\", dr, prf, plen, ch, pcode);\n\t}\n\n\t/* ###########################################################################\n\t * #### DW1000Ng operation functions ###########################################\n\t * ######################################################################### */\n\n\tvoid setNetworkId(uint16_t val)\n\t{\n\t\t_networkAndAddress[2] = (byte)(val & 0xFF);\n\t\t_networkAndAddress[3] = (byte)((val >> 8) & 0xFF);\n\t\t_writeNetworkIdAndDeviceAddress();\n\t}\n\n\tvoid getNetworkId(byte id[])\n\t{\n\t\t_readNetworkIdAndDeviceAddress();\n\t\tid[0] = _networkAndAddress[2];\n\t\tid[1] = _networkAndAddress[3];\n\t}\n\n\tvoid setDeviceAddress(uint16_t val)\n\t{\n\t\t_networkAndAddress[0] = (byte)(val & 0xFF);\n\t\t_networkAndAddress[1] = (byte)((val >> 8) & 0xFF);\n\t\t_writeNetworkIdAndDeviceAddress();\n\t}\n\n\tvoid getDeviceAddress(byte address[])\n\t{\n\t\t_readNetworkIdAndDeviceAddress();\n\t\taddress[0] = _networkAndAddress[0];\n\t\taddress[1] = _networkAndAddress[1];\n\t}\n\n\tvoid setEUI(char eui[])\n\t{\n\t\tbyte eui_byte[LEN_EUI];\n\t\tDW1000NgUtils::convertToByte(eui, eui_byte);\n\t\tsetEUI(eui_byte);\n\t}\n\n\tvoid setEUI(byte eui[])\n\t{\n\t\t// we reverse the address->\n\t\tbyte reverseEUI[8];\n\t\tuint8_t size = 8;\n\t\tfor (uint8_t i = 0; i < size; i++)\n\t\t{\n\t\t\t*(reverseEUI + i) = *(eui + size - i - 1);\n\t\t}\n\t\t_writeBytesToRegister(EUI, NO_SUB, reverseEUI, LEN_EUI);\n\t}\n\n\tvoid getEUI(byte eui[])\n\t{\n\t\t_readBytes(EUI, NO_SUB, eui, LEN_EUI);\n\t}\n\n\tfloat getTemperature()\n\t{\n\t\t_vbatAndTempSteps();\n\t\tbyte sar_ltemp = 0;\n\t\t_readBytes(TX_CAL, 0x04, &sar_ltemp, 1);\n\t\treturn (sar_ltemp - _tmeas23C) * 1.14f + 23.0f;\n\t}\n\n\tfloat getBatteryVoltage()\n\t{\n\t\t_vbatAndTempSteps();\n\t\tbyte sar_lvbat = 0;\n\t\t_readBytes(TX_CAL, 0x03, &sar_lvbat, 1);\n\t\treturn (sar_lvbat - _vmeas3v3) / 173.0f + 3.3f;\n\t}\n\n\tvoid getTemperatureAndBatteryVoltage(float &temp, float &vbat)\n\t{\n\t\t// follow the procedure from section 6.4 of the User Manual\n\t\t_vbatAndTempSteps();\n\t\tdelay(1);\n\t\tbyte sar_lvbat = 0;\n\t\t_readBytes(TX_CAL, 0x03, &sar_lvbat, 1);\n\t\tbyte sar_ltemp = 0;\n\t\t_readBytes(TX_CAL, 0x04, &sar_ltemp, 1);\n\n\t\t// calculate voltage and temperature\n\t\tvbat = (sar_lvbat - _vmeas3v3) / 173.0f + 3.3f;\n\t\ttemp = (sar_ltemp - _tmeas23C) * 1.14f + 23.0f;\n\t}\n\n\tvoid enableFrameFiltering(frame_filtering_configuration_t config)\n\t{\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFEN_BIT, true);\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFBC_BIT, config.behaveAsCoordinator);\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFAB_BIT, config.allowBeacon);\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFAD_BIT, config.allowData);\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFAA_BIT, config.allowAcknowledgement);\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFAM_BIT, config.allowMacCommand);\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFAR_BIT, config.allowAllReserved);\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFA4_BIT, config.allowReservedFour);\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFA5_BIT, config.allowReservedFive);\n\n\t\t_writeSystemConfigurationRegister();\n\t}\n\n\tvoid disableFrameFiltering()\n\t{\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFEN_BIT, false);\n\t\t_writeSystemConfigurationRegister();\n\t}\n\n\tvoid setDoubleBuffering(boolean val)\n\t{\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, DIS_DRXB_BIT, !val);\n\t}\n\n\tvoid setAntennaDelay(uint16_t value)\n\t{\n\t\t_antennaTxDelay = value;\n\t\t_antennaRxDelay = value;\n\t\t_writeAntennaDelayRegisters();\n\t}\n\n\tvoid setTxAntennaDelay(uint16_t value)\n\t{\n\t\t_antennaTxDelay = value;\n\t\t_writeAntennaDelayRegisters();\n\t}\n\tvoid setRxAntennaDelay(uint16_t value)\n\t{\n\t\t_antennaRxDelay = value;\n\t\t_writeAntennaDelayRegisters();\n\t}\n\n\tuint16_t getTxAntennaDelay()\n\t{\n\t\treturn _antennaTxDelay;\n\t}\n\tuint16_t getRxAntennaDelay()\n\t{\n\t\treturn _antennaRxDelay;\n\t}\n\n\tvoid forceTRxOff()\n\t{\n\t\tmemset(_sysctrl, 0, LEN_SYS_CTRL);\n\t\tDW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, TRXOFF_BIT, true);\n\t\t_writeBytesToRegister(SYS_CTRL, NO_SUB, _sysctrl, LEN_SYS_CTRL);\n\t}\n\n\tvoid startReceive(ReceiveMode mode)\n\t{\n\t\tmemset(_sysctrl, 0, LEN_SYS_CTRL);\n\t\tDW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, SFCST_BIT, !_frameCheck);\n\t\tif (mode == ReceiveMode::DELAYED)\n\t\t\tDW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, RXDLYS_BIT, true);\n\t\tDW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, RXENAB_BIT, true);\n\t\t_writeBytesToRegister(SYS_CTRL, NO_SUB, _sysctrl, LEN_SYS_CTRL);\n\t}\n\n\tvoid startTransmit(TransmitMode mode)\n\t{\n\t\tmemset(_sysctrl, 0, LEN_SYS_CTRL);\n\t\tDW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, SFCST_BIT, !_frameCheck);\n\t\tif (mode == TransmitMode::DELAYED)\n\t\t\tDW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, TXDLYS_BIT, true);\n\t\tif (_wait4resp)\n\t\t\tDW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, WAIT4RESP_BIT, true);\n\n\t\tDW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, TXSTRT_BIT, true);\n\t\t_writeBytesToRegister(SYS_CTRL, NO_SUB, _sysctrl, LEN_SYS_CTRL);\n\t}\n\n\tvoid setInterruptPolarity(boolean val)\n\t{\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, HIRQ_POL_BIT, val);\n\t\t_writeSystemConfigurationRegister();\n\t}\n\n\tvoid applyConfiguration(device_configuration_t config)\n\t{\n\t\tforceTRxOff();\n\n\t\t_useExtendedFrameLength(config.extendedFrameLength);\n\t\t_setReceiverAutoReenable(config.receiverAutoReenable);\n\t\t_useSmartPower(config.smartPower);\n\t\t_useFrameCheck(config.frameCheck);\n\t\t_setNlosOptimization(config.nlos);\n\t\t_setSFDMode(config.sfd);\n\t\t_setChannel(config.channel);\n\t\t_setDataRate(config.dataRate);\n\t\t_setPulseFrequency(config.pulseFreq);\n\t\t_setPreambleLength(config.preambleLen);\n\t\t_setPreambleCode(config.preaCode);\n\n\t\tif (!_checkPreambleCodeValidity())\n\t\t\t_setValidPreambleCode();\n\n\t\tif (!_standardSFD)\n\t\t\t_setNonStandardSFDLength();\n\n\t\t// writes configuration to registers\n\t\t_writeConfiguration();\n\t\t// tune according to configuration\n\t\t_tune();\n\t}\n\n\tChannel getChannel()\n\t{\n\t\treturn _channel;\n\t}\n\n\tPulseFrequency getPulseFrequency()\n\t{\n\t\treturn _pulseFrequency;\n\t}\n\n\tvoid setPreambleDetectionTimeout(uint16_t pacSize)\n\t{\n\t\tbyte drx_pretoc[LEN_DRX_PRETOC];\n\t\tDW1000NgUtils::writeValueToBytes(drx_pretoc, pacSize, LEN_DRX_PRETOC);\n\t\t_writeBytesToRegister(DRX_TUNE, DRX_PRETOC_SUB, drx_pretoc, LEN_DRX_PRETOC);\n\t}\n\n\tvoid setSfdDetectionTimeout(uint16_t preambleSymbols)\n\t{\n\t\tbyte drx_sfdtoc[LEN_DRX_SFDTOC];\n\t\tDW1000NgUtils::writeValueToBytes(drx_sfdtoc, preambleSymbols, LEN_DRX_SFDTOC);\n\t\t_writeBytesToRegister(DRX_TUNE, DRX_SFDTOC_SUB, drx_sfdtoc, LEN_DRX_SFDTOC);\n\t}\n\n\tvoid setReceiveFrameWaitTimeoutPeriod(uint16_t timeMicroSeconds)\n\t{\n\t\tif (timeMicroSeconds > 0)\n\t\t{\n\t\t\tbyte rx_wfto[LEN_RX_WFTO];\n\t\t\tDW1000NgUtils::writeValueToBytes(rx_wfto, timeMicroSeconds, LEN_RX_WFTO);\n\t\t\t_writeBytesToRegister(RX_WFTO, NO_SUB, rx_wfto, LEN_RX_WFTO);\n\t\t\t/* enable frame wait timeout bit */\n\t\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, RXWTOE_BIT, true);\n\t\t\t_writeSystemConfigurationRegister();\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* disable frame wait timeout bit */\n\t\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, RXWTOE_BIT, false);\n\t\t\t_writeSystemConfigurationRegister();\n\t\t}\n\t}\n\n\tvoid applyInterruptConfiguration(interrupt_configuration_t interrupt_config)\n\t{\n\t\tforceTRxOff();\n\n\t\t_interruptOnSent(interrupt_config.interruptOnSent);\n\t\t_interruptOnReceived(interrupt_config.interruptOnReceived);\n\t\t_interruptOnReceiveFailed(interrupt_config.interruptOnReceiveFailed);\n\t\t_interruptOnReceiveTimeout(interrupt_config.interruptOnReceiveTimeout);\n\t\t_interruptOnReceiveTimestampAvailable(interrupt_config.interruptOnReceiveTimestampAvailable);\n\t\t_interruptOnAutomaticAcknowledgeTrigger(interrupt_config.interruptOnAutomaticAcknowledgeTrigger);\n\n\t\t_writeSystemEventMaskRegister();\n\t}\n\n\tvoid setWait4Response(uint32_t timeMicroSeconds)\n\t{\n\t\t_wait4resp = timeMicroSeconds == 0 ? false : true;\n\n\t\t/* Check if it overflows 20 bits */\n\t\tif (timeMicroSeconds > 1048575)\n\t\t\ttimeMicroSeconds = 1048575;\n\n\t\tbyte W4R_TIME[LEN_ACK_RESP_T_W4R_TIME_SUB];\n\t\tDW1000NgUtils::writeValueToBytes(W4R_TIME, timeMicroSeconds, LEN_ACK_RESP_T_W4R_TIME_SUB);\n\t\tW4R_TIME[2] &= 0x0F;\n\t\t_writeBytesToRegister(ACK_RESP_T, ACK_RESP_T_W4R_TIME_SUB, W4R_TIME, LEN_ACK_RESP_T_W4R_TIME_SUB);\n\t}\n\n\tvoid setTXPower(byte power[])\n\t{\n\t\t// TODO Check byte length\n\t\t_writeBytesToRegister(TX_POWER, NO_SUB, power, LEN_TX_POWER);\n\t\t_autoTXPower = false;\n\t}\n\n\tvoid setTXPower(int32_t power)\n\t{\n\t\tbyte txpower[LEN_TX_POWER];\n\t\tDW1000NgUtils::writeValueToBytes(txpower, power, LEN_TX_POWER);\n\t\tsetTXPower(txpower);\n\t}\n\n\tvoid setTXPower(DriverAmplifierValue driver_amplifier, TransmitMixerValue mixer)\n\t{\n\t\tbyte txpower[LEN_TX_POWER];\n\t\tbyte pwr = 0x00;\n\n\t\tpwr |= ((byte)driver_amplifier << 5);\n\t\tpwr |= (byte)mixer;\n\n\t\tfor (auto i = 0; i < LEN_TX_POWER; i++)\n\t\t{\n\t\t\ttxpower[i] = pwr;\n\t\t}\n\n\t\tsetTXPower(txpower);\n\t}\n\n\tvoid setTXPowerAuto()\n\t{\n\t\t_autoTXPower = true;\n\t\t_txpowertune();\n\t}\n\n\tvoid setTCPGDelay(byte tcpgdelay)\n\t{\n\t\tbyte tcpgBytes[LEN_TC_PGDELAY];\n\t\tDW1000NgUtils::writeValueToBytes(tcpgBytes, tcpgdelay, LEN_TC_PGDELAY);\n\t\t_writeBytesToRegister(TX_CAL, TC_PGDELAY_SUB, tcpgBytes, LEN_TC_PGDELAY);\n\t\t_autoTCPGDelay = false;\n\t}\n\n\tvoid setTCPGDelayAuto()\n\t{\n\t\t_tcpgdelaytune();\n\t\t_autoTCPGDelay = true;\n\t}\n\n\tvoid enableTransmitPowerSpectrumTestMode(int32_t repeat_interval)\n\t{\n\t\t/* DW1000 clocks must be set to crystal speed so SPI rate have to be lowered and will\n\t\tnot be increased again */\n\t\tSPIporting::setSPIspeed(SPIClock::SLOW);\n\n\t\t_disableSequencing();\n\t\t_configureRFTransmitPowerSpectrumTestMode();\n\t\t_enableClock(SYS_PLL_CLOCK);\n\t\t_enableClock(TX_PLL_CLOCK);\n\n\t\tif (repeat_interval < 4)\n\t\t\trepeat_interval = 4;\n\n\t\t/* In diagnostic transmit power  mode (set next) the bytes 31:0 only are used for DX_TIME register */\n\t\tbyte delayBytes[4];\n\t\tDW1000NgUtils::writeValueToBytes(delayBytes, repeat_interval, 4);\n\t\t_writeBytesToRegister(DX_TIME, NO_SUB, delayBytes, 4);\n\n\t\t/* Enable Transmit Power Spectrum Test Mode */\n\t\tbyte diagnosticBytes[2];\n\t\tDW1000NgUtils::writeValueToBytes(diagnosticBytes, 0x0010, LEN_DIAG_TMC);\n\t\t_writeBytesToRegister(DIG_DIAG, DIAG_TMC_SUB, diagnosticBytes, LEN_DIAG_TMC);\n\t}\n\n\tvoid setDelayedTRX(byte futureTimeBytes[])\n\t{\n\t\t/* the least significant 9-bits are ignored in DX_TIME in functional modes */\n\t\t_writeBytesToRegister(DX_TIME, NO_SUB, futureTimeBytes, LEN_DX_TIME);\n\t}\n\n\tvoid setTransmitData(byte data[], uint16_t n)\n\t{\n\t\tif (_frameCheck)\n\t\t{\n\t\t\tn += 2; // two bytes CRC-16\n\t\t}\n\t\tif (n > LEN_EXT_UWB_FRAMES)\n\t\t{\n\t\t\treturn; // TODO proper error handling: frame/buffer size\n\t\t}\n\t\tif (n > LEN_UWB_FRAMES && !_extendedFrameLength)\n\t\t{\n\t\t\treturn; // TODO proper error handling: frame/buffer size\n\t\t}\n\t\t// transmit data and length\n\t\t_writeBytesToRegister(TX_BUFFER, NO_SUB, data, n);\n\n\t\t/* Sets up transmit frame control length based on data length */\n\t\t_txfctrl[0] = (byte)(n & 0xFF); // 1 byte (regular length + 1 bit)\n\t\t_txfctrl[1] &= 0xE0;\n\t\t_txfctrl[1] |= (byte)((n >> 8) & 0x03); // 2 added bits if extended length\n\t\t_writeTransmitFrameControlRegister();\n\t}\n\n\tvoid setTransmitData(const String &data)\n\t{\n\t\tuint16_t n = data.length() + 1;\n\t\tbyte *dataBytes = (byte *)malloc(n);\n\t\tdata.getBytes(dataBytes, n);\n\t\tsetTransmitData(dataBytes, n);\n\t\tfree(dataBytes);\n\t}\n\n\t// TODO reorder\n\tuint16_t getReceivedDataLength()\n\t{\n\t\tuint16_t len = 0;\n\n\t\t// 10 bits of RX frame control register\n\t\tbyte rxFrameInfo[LEN_RX_FINFO];\n\t\t_readBytes(RX_FINFO, NO_SUB, rxFrameInfo, LEN_RX_FINFO);\n\t\tlen = ((((uint16_t)rxFrameInfo[1] << 8) | (uint16_t)rxFrameInfo[0]) & 0x03FF);\n\n\t\tif (_frameCheck && len > 2)\n\t\t{\n\t\t\treturn len - 2;\n\t\t}\n\t\treturn len;\n\t}\n\n\tvoid getReceivedData(byte data[], uint16_t n)\n\t{\n\t\tif (n <= 0)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\t_readBytes(RX_BUFFER, NO_SUB, data, n);\n\t}\n\n\tvoid getReceivedData(String &data)\n\t{\n\t\tuint16_t i;\n\t\tuint16_t n = getReceivedDataLength(); // number of bytes w/o the two FCS ones\n\t\tif (n <= 0)\n\t\t{ // TODO\n\t\t\treturn;\n\t\t}\n\t\tbyte *dataBytes = (byte *)malloc(n);\n\t\tgetReceivedData(dataBytes, n);\n\t\t// clear string\n\t\tdata.remove(0);\n\t\tdata = \"\";\n\t\t// append to string\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tdata += (char)dataBytes[i];\n\t\t}\n\t\tfree(dataBytes);\n\t}\n\n\tuint64_t getTransmitTimestamp()\n\t{\n\t\tbyte data[LENGTH_TIMESTAMP];\n\t\tmemset(data, 0, LENGTH_TIMESTAMP);\n\t\t_readBytes(TX_TIME, TX_STAMP_SUB, data, LEN_TX_STAMP);\n\t\treturn DW1000NgUtils::bytesAsValue(data, LEN_TX_STAMP);\n\t}\n\n\tuint64_t getReceiveTimestamp()\n\t{\n\t\tbyte data[LEN_RX_STAMP];\n\t\tmemset(data, 0, LEN_RX_STAMP);\n\t\t_readBytes(RX_TIME, RX_STAMP_SUB, data, LEN_RX_STAMP);\n\t\treturn DW1000NgUtils::bytesAsValue(data, LEN_RX_STAMP);\n\t}\n\n\tuint64_t getSystemTimestamp()\n\t{\n\t\tbyte data[LEN_SYS_TIME];\n\t\tmemset(data, 0, LEN_SYS_TIME);\n\t\t_readBytes(SYS_TIME, NO_SUB, data, LEN_SYS_TIME);\n\t\treturn DW1000NgUtils::bytesAsValue(data, LEN_SYS_TIME);\n\t}\n\n\tfloat getReceiveQuality()\n\t{\n\t\tbyte noiseBytes[LEN_STD_NOISE];\n\t\tbyte fpAmpl2Bytes[LEN_FP_AMPL2];\n\t\tuint16_t noise, f2;\n\t\t_readBytes(RX_FQUAL, STD_NOISE_SUB, noiseBytes, LEN_STD_NOISE);\n\t\t_readBytes(RX_FQUAL, FP_AMPL2_SUB, fpAmpl2Bytes, LEN_FP_AMPL2);\n\t\tnoise = (uint16_t)noiseBytes[0] | ((uint16_t)noiseBytes[1] << 8);\n\t\tf2 = (uint16_t)fpAmpl2Bytes[0] | ((uint16_t)fpAmpl2Bytes[1] << 8);\n\t\treturn (float)f2 / noise;\n\t}\n\n\tfloat getFirstPathPower()\n\t{\n\t\tbyte fpAmpl1Bytes[LEN_FP_AMPL1];\n\t\tbyte fpAmpl2Bytes[LEN_FP_AMPL2];\n\t\tbyte fpAmpl3Bytes[LEN_FP_AMPL3];\n\t\tbyte rxFrameInfo[LEN_RX_FINFO];\n\t\tuint16_t f1, f2, f3, N;\n\t\tfloat A, corrFac;\n\t\t_readBytes(RX_TIME, FP_AMPL1_SUB, fpAmpl1Bytes, LEN_FP_AMPL1);\n\t\t_readBytes(RX_FQUAL, FP_AMPL2_SUB, fpAmpl2Bytes, LEN_FP_AMPL2);\n\t\t_readBytes(RX_FQUAL, FP_AMPL3_SUB, fpAmpl3Bytes, LEN_FP_AMPL3);\n\t\t_readBytes(RX_FINFO, NO_SUB, rxFrameInfo, LEN_RX_FINFO);\n\t\tf1 = (uint16_t)fpAmpl1Bytes[0] | ((uint16_t)fpAmpl1Bytes[1] << 8);\n\t\tf2 = (uint16_t)fpAmpl2Bytes[0] | ((uint16_t)fpAmpl2Bytes[1] << 8);\n\t\tf3 = (uint16_t)fpAmpl3Bytes[0] | ((uint16_t)fpAmpl3Bytes[1] << 8);\n\t\tN = (((uint16_t)rxFrameInfo[2] >> 4) & 0xFF) | ((uint16_t)rxFrameInfo[3] << 4);\n\n\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t{\n\t\t\tA = 113.77;\n\t\t\tcorrFac = 2.3334;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tA = 121.74;\n\t\t\tcorrFac = 1.1667;\n\t\t}\n\t\tfloat estFpPwr = 10.0 * log10(((float)f1 * (float)f1 + (float)f2 * (float)f2 + (float)f3 * (float)f3) / ((float)N * (float)N)) - A;\n\t\tif (estFpPwr <= -88)\n\t\t{\n\t\t\treturn estFpPwr;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// approximation of Fig. 22 in user manual for dbm correction\n\t\t\testFpPwr += (estFpPwr + 88) * corrFac;\n\t\t}\n\t\treturn estFpPwr;\n\t}\n\n\tfloat getReceivePower()\n\t{\n\t\tbyte cirPwrBytes[LEN_CIR_PWR];\n\t\tbyte rxFrameInfo[LEN_RX_FINFO];\n\t\tuint32_t twoPower17 = 131072;\n\t\tuint16_t C, N;\n\t\tfloat A, corrFac;\n\t\t_readBytes(RX_FQUAL, CIR_PWR_SUB, cirPwrBytes, LEN_CIR_PWR);\n\t\t_readBytes(RX_FINFO, NO_SUB, rxFrameInfo, LEN_RX_FINFO);\n\t\tC = (uint16_t)cirPwrBytes[0] | ((uint16_t)cirPwrBytes[1] << 8);\n\t\tN = (((uint16_t)rxFrameInfo[2] >> 4) & 0xFF) | ((uint16_t)rxFrameInfo[3] << 4);\n\n\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t{\n\t\t\tA = 113.77;\n\t\t\tcorrFac = 2.3334;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tA = 121.74;\n\t\t\tcorrFac = 1.1667;\n\t\t}\n\n\t\tfloat estRxPwr = 10.0 * log10(((float)C * (float)twoPower17) / ((float)N * (float)N)) - A;\n\t\tif (estRxPwr <= -88)\n\t\t{\n\t\t\treturn estRxPwr;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// approximation of Fig. 22 in user manual for dbm correction\n\t\t\testRxPwr += (estRxPwr + 88) * corrFac;\n\t\t}\n\t\treturn estRxPwr;\n\t}\n\n#if DW1000NG_DEBUG\n\tvoid getPrettyBytes(byte data[], char msgBuffer[], uint16_t n)\n\t{\n\t\tuint16_t i, j, b;\n\t\tb = sprintf(msgBuffer, \"Data, bytes: %d\\nB: 7 6 5 4 3 2 1 0\\n\", n); // TODO - type\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tbyte curByte = data[i];\n\t\t\tsnprintf(&msgBuffer[b++], 2, \"%d\", (i + 1));\n\t\t\tmsgBuffer[b++] = (char)((i + 1) & 0xFF);\n\t\t\tmsgBuffer[b++] = ':';\n\t\t\tmsgBuffer[b++] = ' ';\n\t\t\tfor (j = 0; j < 8; j++)\n\t\t\t{\n\t\t\t\tmsgBuffer[b++] = ((curByte >> (7 - j)) & 0x01) ? '1' : '0';\n\t\t\t\tif (j < 7)\n\t\t\t\t{\n\t\t\t\t\tmsgBuffer[b++] = ' ';\n\t\t\t\t}\n\t\t\t\telse if (i < n - 1)\n\t\t\t\t{\n\t\t\t\t\tmsgBuffer[b++] = '\\n';\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmsgBuffer[b++] = '\\0';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmsgBuffer[b++] = '\\0';\n\t}\n\n\tvoid getPrettyBytes(byte cmd, uint16_t offset, char msgBuffer[], uint16_t n)\n\t{\n\t\tuint16_t i, j, b;\n\t\tbyte *readBuf = (byte *)malloc(n);\n\t\t_readBytes(cmd, offset, readBuf, n);\n\t\tb = sprintf(msgBuffer, \"Reg: 0x%02x, bytes: %d\\nB: 7 6 5 4 3 2 1 0\\n\", cmd, n); // TODO - tpye\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tbyte curByte = readBuf[i];\n\t\t\tsnprintf(&msgBuffer[b++], 2, \"%d\", (i + 1));\n\t\t\tmsgBuffer[b++] = (char)((i + 1) & 0xFF);\n\t\t\tmsgBuffer[b++] = ':';\n\t\t\tmsgBuffer[b++] = ' ';\n\t\t\tfor (j = 0; j < 8; j++)\n\t\t\t{\n\t\t\t\tmsgBuffer[b++] = ((curByte >> (7 - j)) & 0x01) ? '1' : '0';\n\t\t\t\tif (j < 7)\n\t\t\t\t{\n\t\t\t\t\tmsgBuffer[b++] = ' ';\n\t\t\t\t}\n\t\t\t\telse if (i < n - 1)\n\t\t\t\t{\n\t\t\t\t\tmsgBuffer[b++] = '\\n';\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmsgBuffer[b++] = '\\0';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmsgBuffer[b++] = '\\0';\n\t\tfree(readBuf);\n\t}\n#endif\n}"}}}Content-Length: 175

{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"}}}
>>>
Content-Length: 183

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///c:/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","diagnostics":[]},"jsonrpc":"2.0"}
<<<
Content-Length: 227

{"jsonrpc":"2.0","id":53,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":74,"character":12}}}
>>>
Content-Length: 39

{"id":53,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 239

{"jsonrpc":"2.0","id":54,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":74,"character":12}}}
>>>
Content-Length: 37

{"id":54,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 299

{"jsonrpc":"2.0","id":55,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"range":{"start":{"line":74,"character":0},"end":{"line":75,"character":0}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":55,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 232

{"jsonrpc":"2.0","id":56,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":74,"character":12}}}
>>>
Content-Length: 37

{"id":56,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 238

{"jsonrpc":"2.0","id":57,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":76,"character":7}}}
>>>
Content-Length: 37

{"id":57,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 299

{"jsonrpc":"2.0","id":58,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"range":{"start":{"line":76,"character":0},"end":{"line":77,"character":0}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":58,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 231

{"jsonrpc":"2.0","id":59,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":76,"character":8}}}
>>>
Content-Length: 37

{"id":59,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 239

{"jsonrpc":"2.0","id":60,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":74,"character":15}}}
>>>
Content-Length: 37

{"id":60,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 227

{"jsonrpc":"2.0","id":61,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":74,"character":15}}}
>>>
Content-Length: 39

{"id":61,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 299

{"jsonrpc":"2.0","id":62,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"range":{"start":{"line":74,"character":0},"end":{"line":75,"character":0}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":62,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 232

{"jsonrpc":"2.0","id":63,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":73,"character":16}}}
>>>
Content-Length: 37

{"id":63,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 239

{"jsonrpc":"2.0","id":64,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":74,"character":20}}}
>>>
Content-Length: 37

{"id":64,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 299

{"jsonrpc":"2.0","id":65,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"range":{"start":{"line":74,"character":0},"end":{"line":75,"character":0}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":65,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 232

{"jsonrpc":"2.0","id":66,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":73,"character":14}}}
>>>
Content-Length: 37

{"id":66,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 227

{"jsonrpc":"2.0","id":67,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":76,"character":10}}}
>>>
Content-Length: 39

{"id":67,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 238

{"jsonrpc":"2.0","id":68,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":76,"character":7}}}
>>>
Content-Length: 37

{"id":68,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 300

{"jsonrpc":"2.0","id":69,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"range":{"start":{"line":76,"character":5},"end":{"line":76,"character":10}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":69,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 299

{"jsonrpc":"2.0","id":70,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"range":{"start":{"line":76,"character":0},"end":{"line":77,"character":0}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":70,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 226

{"jsonrpc":"2.0","id":71,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":75,"character":9}}}
>>>
Content-Length: 39

{"id":71,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 227

{"jsonrpc":"2.0","id":72,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":74,"character":11}}}
>>>
Content-Length: 39

{"id":72,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 239

{"jsonrpc":"2.0","id":73,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":74,"character":12}}}
>>>
Content-Length: 37

{"id":73,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 299

{"jsonrpc":"2.0","id":74,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"range":{"start":{"line":74,"character":0},"end":{"line":75,"character":0}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":74,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 227

{"jsonrpc":"2.0","id":75,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":73,"character":12}}}
>>>
Content-Length: 39

{"id":75,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 232

{"jsonrpc":"2.0","id":76,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":73,"character":13}}}
>>>
Content-Length: 37

{"id":76,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 301

{"jsonrpc":"2.0","id":77,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"range":{"start":{"line":67,"character":51},"end":{"line":67,"character":51}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":77,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 227

{"jsonrpc":"2.0","id":78,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":68,"character":18}}}
>>>
Content-Length: 606

{"id":78,"result":{"contents":{"kind":"markdown","value":"### function `getPrintableExtendedUniqueIdentifier`  \n\n---\nâ†’ `void`  \nParameters:  \n- `char * msgBuffer`\n\nGenerates a String representation of the extended unique identifier (EUI) of the chip.  \n@param[out] msgBuffer The String buffer to be filled with printable device information.  \nProvide 128 bytes, this should be sufficient.  \n\n---\n```cpp\n// In namespace DW1000Ng\nvoid getPrintableExtendedUniqueIdentifier(char msgBuffer[])\n```"},"range":{"start":{"line":68,"character":12},"end":{"line":68,"character":48}}},"jsonrpc":"2.0"}
<<<
Content-Length: 226

{"jsonrpc":"2.0","id":79,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":64,"character":9}}}
>>>
Content-Length: 39

{"id":79,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 238

{"jsonrpc":"2.0","id":80,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":64,"character":7}}}
>>>
Content-Length: 37

{"id":80,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 299

{"jsonrpc":"2.0","id":81,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"range":{"start":{"line":64,"character":0},"end":{"line":65,"character":0}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":81,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 231

{"jsonrpc":"2.0","id":82,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":64,"character":7}}}
>>>
Content-Length: 37

{"id":82,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 227

{"jsonrpc":"2.0","id":83,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":63,"character":43}}}
>>>
Content-Length: 39

{"id":83,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 301

{"jsonrpc":"2.0","id":84,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"range":{"start":{"line":63,"character":44},"end":{"line":63,"character":44}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":84,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 227

{"jsonrpc":"2.0","id":85,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":51,"character":30}}}
>>>
Content-Length: 39

{"id":85,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 227

{"jsonrpc":"2.0","id":86,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":51,"character":30}}}
>>>
Content-Length: 39

{"id":86,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 238

{"jsonrpc":"2.0","id":87,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":46,"character":8}}}
>>>
Content-Length: 37

{"id":87,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 299

{"jsonrpc":"2.0","id":88,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"range":{"start":{"line":46,"character":8},"end":{"line":46,"character":8}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 37

{"id":88,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 227

{"jsonrpc":"2.0","id":89,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":19,"character":40}}}
>>>
Content-Length: 39

{"id":89,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 227

{"jsonrpc":"2.0","id":90,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":16,"character":37}}}
>>>
Content-Length: 39

{"id":90,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 227

{"jsonrpc":"2.0","id":91,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":17,"character":26}}}
>>>
Content-Length: 39

{"id":91,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 227

{"jsonrpc":"2.0","id":92,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":17,"character":26}}}
>>>
Content-Length: 39

{"id":92,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 227

{"jsonrpc":"2.0","id":93,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":17,"character":26}}}
>>>
Content-Length: 39

{"id":93,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 227

{"jsonrpc":"2.0","id":94,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":35,"character":36}}}
>>>
Content-Length: 39

{"id":94,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 227

{"jsonrpc":"2.0","id":95,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":35,"character":36}}}
>>>
Content-Length: 39

{"id":95,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 227

{"jsonrpc":"2.0","id":96,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":42,"character":39}}}
>>>
Content-Length: 39

{"id":96,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 227

{"jsonrpc":"2.0","id":97,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":42,"character":40}}}
>>>
Content-Length: 39

{"id":97,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 239

{"jsonrpc":"2.0","id":98,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":53,"character":25}}}
>>>
Content-Length: 125

{"id":98,"result":[{"range":{"start":{"line":53,"character":12},"end":{"line":53,"character":33}},"kind":1}],"jsonrpc":"2.0"}
<<<
Content-Length: 301

{"jsonrpc":"2.0","id":99,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"range":{"start":{"line":53,"character":12},"end":{"line":53,"character":33}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 484

{"id":99,"result":[{"title":"Add using-declaration for initializeNoInterrupt and remove qualifier","kind":"refactor","command":{"title":"Add using-declaration for initializeNoInterrupt and remove qualifier","command":"clangd.applyTweak","arguments":[{"tweakID":"AddUsing","file":"file:///C:/Users/ltp/AppData/Local/Temp/arduino-language-server801712847/sketch/BasicSender.ino.cpp","selection":{"start":{"line":62,"character":12},"end":{"line":62,"character":33}}}]}}],"jsonrpc":"2.0"}
<<<
Content-Length: 228

{"jsonrpc":"2.0","id":100,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":57,"character":63}}}
>>>
Content-Length: 40

{"id":100,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 228

{"jsonrpc":"2.0","id":101,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":57,"character":63}}}
>>>
Content-Length: 40

{"id":101,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 228

{"jsonrpc":"2.0","id":102,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":54,"character":25}}}
>>>
Content-Length: 40

{"id":102,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 228

{"jsonrpc":"2.0","id":103,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":54,"character":48}}}
>>>
Content-Length: 40

{"id":103,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 228

{"jsonrpc":"2.0","id":104,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":56,"character":43}}}
>>>
Content-Length: 905

{"id":104,"result":{"contents":{"kind":"markdown","value":"### variable `DEFAULT_CONFIG`  \n\n---\nType: `device_configuration_t`  \nPassed as config  \n\n---\n```cpp\ndevice_configuration_t DEFAULT_CONFIG = {false,\n                                         true,\n                                         true,\n                                         true,\n                                         false,\n                                         SFDMode::STANDARD_SFD,\n                                         Channel::CHANNEL_5,\n                                         DataRate::RATE_850KBPS,\n                                         PulseFrequency::FREQ_16MHZ,\n                                         PreambleLength::LEN_256,\n                                         PreambleCode::CODE_3}\n```"},"range":{"start":{"line":56,"character":31},"end":{"line":56,"character":45}}},"jsonrpc":"2.0"}
<<<
Content-Length: 228

{"jsonrpc":"2.0","id":105,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":57,"character":31}}}
>>>
Content-Length: 40

{"id":105,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 228

{"jsonrpc":"2.0","id":106,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":53,"character":25}}}
>>>
Content-Length: 771

{"id":106,"result":{"contents":{"kind":"markdown","value":"### function `initializeNoInterrupt`  \n\n---\nâ†’ `void`  \nParameters:  \n- `uint8_t ss`\n- `uint8_t rst = 255`\n\nInitiates and starts a sessions with a DW1000 without interrupt. If rst is not set or value 0xff, a soft resets (i.e. command triggered) are used and it is assumed that no reset line is wired.  \n@param[in] ss The SPI Selection pin used to identify the specific connection  \n@param[in] rst The reset line/pin for hard resets of ICs that connect to the Arduino. Value 0xff means soft reset.  \n\n---\n```cpp\n// In namespace DW1000Ng\nvoid initializeNoInterrupt(uint8_t ss, uint8_t rst = 255)\n```"},"range":{"start":{"line":53,"character":12},"end":{"line":53,"character":33}}},"jsonrpc":"2.0"}
<<<
Content-Length: 228

{"jsonrpc":"2.0","id":107,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":53,"character":23}}}
>>>
Content-Length: 771

{"id":107,"result":{"contents":{"kind":"markdown","value":"### function `initializeNoInterrupt`  \n\n---\nâ†’ `void`  \nParameters:  \n- `uint8_t ss`\n- `uint8_t rst = 255`\n\nInitiates and starts a sessions with a DW1000 without interrupt. If rst is not set or value 0xff, a soft resets (i.e. command triggered) are used and it is assumed that no reset line is wired.  \n@param[in] ss The SPI Selection pin used to identify the specific connection  \n@param[in] rst The reset line/pin for hard resets of ICs that connect to the Arduino. Value 0xff means soft reset.  \n\n---\n```cpp\n// In namespace DW1000Ng\nvoid initializeNoInterrupt(uint8_t ss, uint8_t rst = 255)\n```"},"range":{"start":{"line":53,"character":12},"end":{"line":53,"character":33}}},"jsonrpc":"2.0"}
<<<
Content-Length: 302

{"jsonrpc":"2.0","id":108,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"range":{"start":{"line":53,"character":12},"end":{"line":53,"character":33}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 485

{"id":108,"result":[{"title":"Add using-declaration for initializeNoInterrupt and remove qualifier","kind":"refactor","command":{"title":"Add using-declaration for initializeNoInterrupt and remove qualifier","command":"clangd.applyTweak","arguments":[{"tweakID":"AddUsing","file":"file:///C:/Users/ltp/AppData/Local/Temp/arduino-language-server801712847/sketch/BasicSender.ino.cpp","selection":{"start":{"line":62,"character":12},"end":{"line":62,"character":33}}}]}}],"jsonrpc":"2.0"}
<<<
Content-Length: 233

{"jsonrpc":"2.0","id":109,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":54,"character":24}}}
>>>
Content-Length: 38

{"id":109,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 233

{"jsonrpc":"2.0","id":110,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":54,"character":25}}}
>>>
Content-Length: 38

{"id":110,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 228

{"jsonrpc":"2.0","id":111,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":54,"character":24}}}
>>>
Content-Length: 40

{"id":111,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 233

{"jsonrpc":"2.0","id":112,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":53,"character":27}}}
>>>
Content-Length: 215

{"id":112,"result":[{"uri":"file:///C:/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","range":{"start":{"line":1643,"character":6},"end":{"line":1643,"character":27}}}],"jsonrpc":"2.0"}
<<<
Content-Length: 82613

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","languageId":"cpp","version":1,"text":"/*\n * MIT License\n *\n * Copyright (c) 2018 Michele Biondi, Andrea Salvatori\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n/*\n * Copyright (c) 2015 by Thomas Trojer <thomas@trojer.net>\n * Decawave DW1000Ng library for arduino.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @file DW1000Ng.cpp\n * Arduino driver library (source file) for the Decawave DW1000Ng UWB transceiver Module.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"DW1000Ng.hpp\"\n#include \"DW1000NgUtils.hpp\"\n#include \"DW1000NgConstants.hpp\"\n#include \"DW1000NgRegisters.hpp\"\n#include \"SPIporting.hpp\"\n\nnamespace DW1000Ng\n{\n\n\t/* anonymous namespace to host private-like variables and methods */\n\tnamespace\n\t{\n\n\t\t/* ########################### PRIVATE VARIABLES ################################# */\n\n\t\t/* SPI select pin and interrupt pin*/\n\t\tuint8_t _ss = 0xff;\n\t\tuint8_t _irq = 0xff;\n\t\tuint8_t _rst = 0xff;\n\n\t\t/* IRQ callbacks */\n\t\tvoid (*_handleSent)(void) = nullptr;\n\t\tvoid (*_handleError)(void) = nullptr;\n\t\tvoid (*_handleReceived)(void) = nullptr;\n\t\tvoid (*_handleReceiveFailed)(void) = nullptr;\n\t\tvoid (*_handleReceiveTimeout)(void) = nullptr;\n\t\tvoid (*_handleReceiveTimestampAvailable)(void) = nullptr;\n\n\t\t/* registers */\n\t\tbyte _syscfg[LEN_SYS_CFG];\n\t\tbyte _sysctrl[LEN_SYS_CTRL];\n\t\tbyte _sysstatus[LEN_SYS_STATUS];\n\t\tbyte _txfctrl[LEN_TX_FCTRL];\n\t\tbyte _sysmask[LEN_SYS_MASK];\n\t\tbyte _chanctrl[LEN_CHAN_CTRL];\n\t\tbyte _networkAndAddress[LEN_PANADR];\n\n\t\t/* Temperature and Voltage monitoring */\n\t\tbyte _vmeas3v3 = 0;\n\t\tbyte _tmeas23C = 0;\n\n\t\t/* Driver Internal State Trackers */\n\t\tbyte _extendedFrameLength;\n\t\tPacSize _pacSize;\n\t\tPulseFrequency _pulseFrequency;\n\t\tDataRate _dataRate;\n\t\tPreambleLength _preambleLength;\n\t\tPreambleCode _preambleCode;\n\t\tChannel _channel;\n\t\tboolean _smartPower;\n\t\tboolean _frameCheck;\n\t\tboolean _debounceClockEnabled = false;\n\t\tboolean _nlos = false;\n\t\tboolean _standardSFD = true;\n\t\tboolean _autoTXPower = true;\n\t\tboolean _autoTCPGDelay = true;\n\t\tboolean _wait4resp = false;\n\t\tuint16_t _antennaTxDelay = 0;\n\t\tuint16_t _antennaRxDelay = 0;\n\n\t\t/* ############################# PRIVATE METHODS ################################### */\n\t\t/*\n\t\t * Write bytes to the DW1000Ng. Single bytes can be written to registers via sub-addressing.\n\t\t * @param cmd\n\t\t * \t\tThe register address (see Chapter 7 in the DW1000Ng user manual).\n\t\t * @param offset\n\t\t *\t\tThe offset to select register sub-parts for writing, or 0x00 to disable\n\t\t * \t\tsub-adressing.\n\t\t * @param data\n\t\t *\t\tThe data array to be written.\n\t\t * @param data_size\n\t\t *\t\tThe number of bytes to be written (take care not to go out of bounds of\n\t\t * \t\tthe register).\n\t\t */\n\t\t// TODO offset really bigger than byte?\n\n\t\tvoid _writeBytesToRegister(byte cmd, uint16_t offset, byte data[], uint16_t data_size)\n\t\t{\n\t\t\tbyte header[3];\n\t\t\tuint8_t headerLen = 1;\n\n\t\t\t// TODO proper error handling: address out of bounds\n\t\t\t// build SPI header\n\t\t\tif (offset == NO_SUB)\n\t\t\t{\n\t\t\t\theader[0] = WRITE | cmd;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\theader[0] = WRITE_SUB | cmd;\n\t\t\t\tif (offset < 128)\n\t\t\t\t{\n\t\t\t\t\theader[1] = (byte)offset;\n\t\t\t\t\theaderLen++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\theader[1] = RW_SUB_EXT | (byte)offset;\n\t\t\t\t\theader[2] = (byte)(offset >> 7);\n\t\t\t\t\theaderLen += 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSPIporting::writeToSPI(_ss, headerLen, header, data_size, data);\n\t\t}\n\n\t\tvoid _writeToRegister(byte cmd, uint16_t offset, uint32_t data, uint16_t data_size)\n\t\t{\n\t\t\tbyte dataBytes[data_size];\n\t\t\tDW1000NgUtils::writeValueToBytes(dataBytes, data, data_size);\n\t\t\t_writeBytesToRegister(cmd, offset, dataBytes, data_size);\n\t\t}\n\n\t\t// Helper to set a single register\n\t\tvoid _writeByte(byte cmd, uint16_t offset, byte data)\n\t\t{\n\t\t\t_writeBytesToRegister(cmd, offset, &data, 1);\n\t\t}\n\n\t\t/*\n\t\t * Read bytes from the DW1000Ng. Number of bytes depend on register length.\n\t\t * @param cmd\n\t\t * \t\tThe register address (see Chapter 7 in the DW1000Ng user manual).\n\t\t * @param data\n\t\t *\t\tThe data array to be read into.\n\t\t * @param n\n\t\t *\t\tThe number of bytes expected to be received.\n\t\t */\n\t\t// TODO incomplete doc\n\t\tvoid _readBytes(byte cmd, uint16_t offset, byte data[], uint16_t data_size)\n\t\t{\n\t\t\tbyte header[3];\n\t\t\tuint8_t headerLen = 1;\n\n\t\t\t// build SPI header\n\t\t\tif (offset == NO_SUB)\n\t\t\t{\n\t\t\t\theader[0] = READ | cmd;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\theader[0] = READ_SUB | cmd;\n\t\t\t\tif (offset < 128)\n\t\t\t\t{\n\t\t\t\t\theader[1] = (byte)offset;\n\t\t\t\t\theaderLen++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\theader[1] = RW_SUB_EXT | (byte)offset;\n\t\t\t\t\theader[2] = (byte)(offset >> 7);\n\t\t\t\t\theaderLen += 2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSPIporting::readFromSPI(_ss, headerLen, header, data_size, data);\n\t\t}\n\n\t\t// always 4 bytes\n\t\t// TODO why always 4 bytes? can be different, see p. 58 table 10 otp memory map\n\t\tvoid _readBytesOTP(uint16_t address, byte data[])\n\t\t{\n\t\t\tbyte addressBytes[LEN_OTP_ADDR];\n\n\t\t\t// p60 - 6.3.3 Reading a value from OTP memory\n\t\t\t// bytes of address\n\t\t\taddressBytes[0] = (address & 0xFF);\n\t\t\taddressBytes[1] = ((address >> 8) & 0xFF);\n\t\t\t// set address\n\t\t\t_writeBytesToRegister(OTP_IF, OTP_ADDR_SUB, addressBytes, LEN_OTP_ADDR);\n\t\t\t// switch into read mode\n\t\t\t_writeByte(OTP_IF, OTP_CTRL_SUB, 0x03); // OTPRDEN | OTPREAD\n\t\t\t_writeByte(OTP_IF, OTP_CTRL_SUB, 0x01); // OTPRDEN\n\t\t\t// read value/block - 4 bytes\n\t\t\t_readBytes(OTP_IF, OTP_RDAT_SUB, data, LEN_OTP_RDAT);\n\t\t\t// end read mode\n\t\t\t_writeByte(OTP_IF, OTP_CTRL_SUB, 0x00);\n\t\t}\n\n\t\tvoid _writeBitToRegister(byte bitRegister, uint16_t RegisterOffset, uint16_t bitRegister_LEN, uint16_t selectedBit, boolean value)\n\t\t{\n\t\t\tuint16_t idx;\n\t\t\tuint8_t bitPosition;\n\n\t\t\tidx = selectedBit / 8;\n\t\t\tif (idx >= bitRegister_LEN)\n\t\t\t{\n\t\t\t\treturn; // TODO proper error handling: out of bounds\n\t\t\t}\n\t\t\tbyte targetByte;\n\t\t\tmemset(&targetByte, 0, 1);\n\t\t\tbitPosition = selectedBit % 8;\n\t\t\t_readBytes(bitRegister, RegisterOffset + idx, &targetByte, 1);\n\n\t\t\tvalue ? bitSet(targetByte, bitPosition) : bitClear(targetByte, bitPosition);\n\n\t\t\tif (RegisterOffset == NO_SUB)\n\t\t\t\tRegisterOffset = 0x00;\n\n\t\t\t_writeBytesToRegister(bitRegister, RegisterOffset + idx, &targetByte, 1);\n\t\t}\n\n\t\tvoid _enableClock(byte clock)\n\t\t{\n\t\t\tbyte pmscctrl0[LEN_PMSC_CTRL0];\n\t\t\tmemset(pmscctrl0, 0, LEN_PMSC_CTRL0);\n\t\t\t_readBytes(PMSC, PMSC_CTRL0_SUB, pmscctrl0, LEN_PMSC_CTRL0);\n\t\t\tif (clock == SYS_AUTO_CLOCK)\n\t\t\t{\n\t\t\t\tpmscctrl0[0] = SYS_AUTO_CLOCK;\n\t\t\t\tpmscctrl0[1] &= 0xFE;\n\t\t\t}\n\t\t\telse if (clock == SYS_XTI_CLOCK)\n\t\t\t{\n\t\t\t\tpmscctrl0[0] &= 0xFC;\n\t\t\t\tpmscctrl0[0] |= SYS_XTI_CLOCK;\n\t\t\t}\n\t\t\telse if (clock == SYS_PLL_CLOCK)\n\t\t\t{\n\t\t\t\tpmscctrl0[0] &= 0xFC;\n\t\t\t\tpmscctrl0[0] |= SYS_PLL_CLOCK;\n\t\t\t}\n\t\t\telse if (clock == TX_PLL_CLOCK)\n\t\t\t{\n\t\t\t\tpmscctrl0[0] &= 0xCF;\n\t\t\t\tpmscctrl0[0] |= TX_PLL_CLOCK;\n\t\t\t}\n\t\t\telse if (clock == LDE_CLOCK)\n\t\t\t{\n\t\t\t\tpmscctrl0[0] = SYS_XTI_CLOCK;\n\t\t\t\tpmscctrl0[1] = 0x03;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO deliver proper warning\n\t\t\t}\n\t\t\t_writeBytesToRegister(PMSC, PMSC_CTRL0_SUB, pmscctrl0, 2);\n\t\t}\n\n\t\t/* Steps used to get Temp and Voltage */\n\t\tvoid _vbatAndTempSteps()\n\t\t{\n\t\t\tbyte step1 = 0x80;\n\t\t\t_writeBytesToRegister(RF_CONF, 0x11, &step1, 1);\n\t\t\tbyte step2 = 0x0A;\n\t\t\t_writeBytesToRegister(RF_CONF, 0x12, &step2, 1);\n\t\t\tbyte step3 = 0x0F;\n\t\t\t_writeBytesToRegister(RF_CONF, 0x12, &step3, 1);\n\t\t\tbyte step4 = 0x01;\n\t\t\t_writeBytesToRegister(TX_CAL, NO_SUB, &step4, 1);\n\t\t\tbyte step5 = 0x00;\n\t\t\t_writeBytesToRegister(TX_CAL, NO_SUB, &step5, 1);\n\t\t}\n\n\t\t/* AGC_TUNE1 - reg:0x23, sub-reg:0x04, table 24 */\n\t\tvoid _agctune1()\n\t\t{\n\t\t\tbyte agctune1[LEN_AGC_TUNE1];\n\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(agctune1, 0x8870, LEN_AGC_TUNE1);\n\t\t\t}\n\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(agctune1, 0x889B, LEN_AGC_TUNE1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(AGC_TUNE, AGC_TUNE1_SUB, agctune1, LEN_AGC_TUNE1);\n\t\t}\n\n\t\t/* AGC_TUNE2 - reg:0x23, sub-reg:0x0C, table 25 */\n\t\tvoid _agctune2()\n\t\t{\n\t\t\tbyte agctune2[LEN_AGC_TUNE2];\n\t\t\tDW1000NgUtils::writeValueToBytes(agctune2, 0x2502A907L, LEN_AGC_TUNE2);\n\t\t\t_writeBytesToRegister(AGC_TUNE, AGC_TUNE2_SUB, agctune2, LEN_AGC_TUNE2);\n\t\t}\n\n\t\t/* AGC_TUNE3 - reg:0x23, sub-reg:0x12, table 26 */\n\t\tvoid _agctune3()\n\t\t{\n\t\t\tbyte agctune3[LEN_AGC_TUNE3];\n\t\t\tDW1000NgUtils::writeValueToBytes(agctune3, 0x0035, LEN_AGC_TUNE3);\n\t\t\t_writeBytesToRegister(AGC_TUNE, AGC_TUNE3_SUB, agctune3, LEN_AGC_TUNE3);\n\t\t}\n\n\t\t/* DRX_TUNE0b - reg:0x27, sub-reg:0x02, table 30 */\n\t\tvoid _drxtune0b()\n\t\t{\n\t\t\tbyte drxtune0b[LEN_DRX_TUNE0b];\n\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t{\n\t\t\t\tif (!_standardSFD)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune0b, 0x0016, LEN_DRX_TUNE0b);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune0b, 0x000A, LEN_DRX_TUNE0b);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_dataRate == DataRate::RATE_850KBPS)\n\t\t\t{\n\t\t\t\tif (!_standardSFD)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune0b, 0x0006, LEN_DRX_TUNE0b);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune0b, 0x0001, LEN_DRX_TUNE0b);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_dataRate == DataRate::RATE_6800KBPS)\n\t\t\t{\n\t\t\t\tif (!_standardSFD)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune0b, 0x0002, LEN_DRX_TUNE0b);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune0b, 0x0001, LEN_DRX_TUNE0b);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(DRX_TUNE, DRX_TUNE0b_SUB, drxtune0b, LEN_DRX_TUNE0b);\n\t\t}\n\n\t\t/* DRX_TUNE1a - reg:0x27, sub-reg:0x04, table 31 */\n\t\tvoid _drxtune1a()\n\t\t{\n\t\t\tbyte drxtune1a[LEN_DRX_TUNE1a];\n\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune1a, 0x0087, LEN_DRX_TUNE1a);\n\t\t\t}\n\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune1a, 0x008D, LEN_DRX_TUNE1a);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(DRX_TUNE, DRX_TUNE1a_SUB, drxtune1a, LEN_DRX_TUNE1a);\n\t\t}\n\n\t\t/* DRX_TUNE1b - reg:0x27, sub-reg:0x06, table 32 */\n\t\tvoid _drxtune1b()\n\t\t{\n\t\t\tbyte drxtune1b[LEN_DRX_TUNE1b];\n\t\t\tif (_preambleLength == PreambleLength::LEN_1536 || _preambleLength == PreambleLength::LEN_2048 ||\n\t\t\t\t_preambleLength == PreambleLength::LEN_4096)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune1b, 0x0064, LEN_DRX_TUNE1b);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleLength != PreambleLength::LEN_64)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_850KBPS || _dataRate == DataRate::RATE_6800KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune1b, 0x0020, LEN_DRX_TUNE1b);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_6800KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune1b, 0x0010, LEN_DRX_TUNE1b);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\t_writeBytesToRegister(DRX_TUNE, DRX_TUNE1b_SUB, drxtune1b, LEN_DRX_TUNE1b);\n\t\t}\n\n\t\t/* DRX_TUNE2 - reg:0x27, sub-reg:0x08, table 33 */\n\t\tvoid _drxtune2()\n\t\t{\n\t\t\tbyte drxtune2[LEN_DRX_TUNE2];\n\t\t\tif (_pacSize == PacSize::SIZE_8)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune2, 0x311A002DL, LEN_DRX_TUNE2);\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune2, 0x313B006BL, LEN_DRX_TUNE2);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_pacSize == PacSize::SIZE_16)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune2, 0x331A0052L, LEN_DRX_TUNE2);\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune2, 0x333B00BEL, LEN_DRX_TUNE2);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_pacSize == PacSize::SIZE_32)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune2, 0x351A009AL, LEN_DRX_TUNE2);\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune2, 0x353B015EL, LEN_DRX_TUNE2);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_pacSize == PacSize::SIZE_64)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune2, 0x371A011DL, LEN_DRX_TUNE2);\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune2, 0x373B0296L, LEN_DRX_TUNE2);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(DRX_TUNE, DRX_TUNE2_SUB, drxtune2, LEN_DRX_TUNE2);\n\t\t}\n\n\t\t/* DRX_TUNE4H - reg:0x27, sub-reg:0x26, table 34 */\n\t\tvoid _drxtune4H()\n\t\t{\n\t\t\tbyte drxtune4H[LEN_DRX_TUNE4H];\n\t\t\tif (_preambleLength == PreambleLength::LEN_64)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune4H, 0x0010, LEN_DRX_TUNE4H);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune4H, 0x0028, LEN_DRX_TUNE4H);\n\t\t\t}\n\t\t\t_writeBytesToRegister(DRX_TUNE, DRX_TUNE4H_SUB, drxtune4H, LEN_DRX_TUNE4H);\n\t\t}\n\n\t\t/* LDE_CFG1 - reg 0x2E, sub-reg:0x0806 */\n\t\tvoid _ldecfg1()\n\t\t{\n\t\t\tbyte ldecfg1[LEN_LDE_CFG1];\n\t\t\t_nlos == true ? DW1000NgUtils::writeValueToBytes(ldecfg1, 0x7, LEN_LDE_CFG1) : DW1000NgUtils::writeValueToBytes(ldecfg1, 0xD, LEN_LDE_CFG1);\n\t\t\t_writeBytesToRegister(LDE_IF, LDE_CFG1_SUB, ldecfg1, LEN_LDE_CFG1);\n\t\t}\n\n\t\t/* LDE_CFG2 - reg 0x2E, sub-reg:0x1806, table 50 */\n\t\tvoid _ldecfg2()\n\t\t{\n\t\t\tbyte ldecfg2[LEN_LDE_CFG2];\n\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t{\n\t\t\t\t_nlos == true ? DW1000NgUtils::writeValueToBytes(ldecfg2, 0x0003, LEN_LDE_CFG2) : DW1000NgUtils::writeValueToBytes(ldecfg2, 0x1607, LEN_LDE_CFG2);\n\t\t\t}\n\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(ldecfg2, 0x0607, LEN_LDE_CFG2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(LDE_IF, LDE_CFG2_SUB, ldecfg2, LEN_LDE_CFG2);\n\t\t}\n\n\t\t/* LDE_REPC - reg 0x2E, sub-reg:0x2804, table 51 */\n\t\tvoid _lderepc()\n\t\t{\n\t\t\tbyte lderepc[LEN_LDE_REPC];\n\t\t\tif (_preambleCode == PreambleCode::CODE_1 || _preambleCode == PreambleCode::CODE_2)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x5998 >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x5998, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_3 || _preambleCode == PreambleCode::CODE_8)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x51EA >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x51EA, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_4)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x428E >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x428E, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_5)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x451E >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x451E, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_6)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x2E14 >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x2E14, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_7)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x8000 >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x8000, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_9)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x28F4 >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x28F4, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_10 || _preambleCode == PreambleCode::CODE_17)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x3332 >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x3332, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_11)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x3AE0 >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x3AE0, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_12)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x3D70 >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x3D70, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_18 || _preambleCode == PreambleCode::CODE_19)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x35C2 >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x35C2, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_20)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x47AE >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x47AE, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\n\t\t\t_writeBytesToRegister(LDE_IF, LDE_REPC_SUB, lderepc, LEN_LDE_REPC);\n\t\t}\n\n\t\t/* TX_POWER (enabled smart transmit power control) - reg:0x1E, tables 19-20\n\t\t * These values are based on a typical IC and an assumed IC to antenna loss of 1.5 dB with a 0 dBi antenna */\n\t\tvoid _txpowertune()\n\t\t{\n\t\t\tbyte txpower[LEN_TX_POWER];\n\t\t\tif (_channel == Channel::CHANNEL_1 || _channel == Channel::CHANNEL_2)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x1B153555L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x15355575L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x55555555L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x75757575L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x0D072747L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x07274767L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x47474747L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x67676767L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_3)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x150F2F4FL, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x0F2F4F6FL, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x4F4F4F4FL, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x6F6F6F6FL, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x0B2B4B6BL, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x2B4B6B8BL, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x6B6B6B6BL, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x8B8B8B8BL, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_4)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x1F1F1F3FL, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x1F1F3F5FL, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x3F3F3F3FL, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x5F5F5F5FL, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x1A3A5A7AL, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x3A5A7A9AL, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x7A7A7A7AL, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x9A9A9A9AL, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_5)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x140E0828L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x0E082848L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x28282828L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x48484848L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x05254565L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x25456585L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x65656565L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x85858585L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_7)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x12325272L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x32527292L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x72727272L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x92929292L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x315191B1L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x5171B1D1L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0xB1B1B1B1L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0xD1D1D1D1L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(TX_POWER, NO_SUB, txpower, LEN_TX_POWER);\n\t\t}\n\n\t\t/* RF_RXCTRLH - reg:0x28, sub-reg:0x0B, table 37 */\n\t\tvoid _rfrxctrlh()\n\t\t{\n\t\t\tbyte rfrxctrlh[LEN_RF_RXCTRLH];\n\t\t\tif (_channel != Channel::CHANNEL_4 && _channel != Channel::CHANNEL_7)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(rfrxctrlh, 0xD8, LEN_RF_RXCTRLH);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(rfrxctrlh, 0xBC, LEN_RF_RXCTRLH);\n\t\t\t}\n\t\t\t_writeBytesToRegister(RF_CONF, RF_RXCTRLH_SUB, rfrxctrlh, LEN_RF_RXCTRLH);\n\t\t}\n\n\t\t/* RX_TXCTRL - reg:0x28, sub-reg:0x0C */\n\t\tvoid _rftxctrl()\n\t\t{\n\t\t\tbyte rftxctrl[LEN_RF_TXCTRL];\n\t\t\tif (_channel == Channel::CHANNEL_1)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(rftxctrl, 0x00005C40L, LEN_RF_TXCTRL);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_2)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(rftxctrl, 0x00045CA0L, LEN_RF_TXCTRL);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_3)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(rftxctrl, 0x00086CC0L, LEN_RF_TXCTRL);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_4)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(rftxctrl, 0x00045C80L, LEN_RF_TXCTRL);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_5)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(rftxctrl, 0x001E3FE0L, LEN_RF_TXCTRL);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_7)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(rftxctrl, 0x001E7DE0L, LEN_RF_TXCTRL);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(RF_CONF, RF_TXCTRL_SUB, rftxctrl, LEN_RF_TXCTRL);\n\t\t}\n\n\t\t/* TC_PGDELAY - reg:0x2A, sub-reg:0x0B, table 40 */\n\t\tvoid _tcpgdelaytune()\n\t\t{\n\t\t\tbyte tcpgdelay[LEN_TC_PGDELAY];\n\t\t\tif (_channel == Channel::CHANNEL_1)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(tcpgdelay, 0xC9, LEN_TC_PGDELAY);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_2)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(tcpgdelay, 0xC2, LEN_TC_PGDELAY);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_3)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(tcpgdelay, 0xC5, LEN_TC_PGDELAY);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_4)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(tcpgdelay, 0x95, LEN_TC_PGDELAY);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_5)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(tcpgdelay, 0xC0, LEN_TC_PGDELAY);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_7)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(tcpgdelay, 0x93, LEN_TC_PGDELAY);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(TX_CAL, TC_PGDELAY_SUB, tcpgdelay, LEN_TC_PGDELAY);\n\t\t}\n\n\t\t// FS_PLLCFG and FS_PLLTUNE - reg:0x2B, sub-reg:0x07-0x0B, tables 43-44\n\t\tvoid _fspll()\n\t\t{\n\t\t\tbyte fspllcfg[LEN_FS_PLLCFG];\n\t\t\tbyte fsplltune[LEN_FS_PLLTUNE];\n\t\t\tif (_channel == Channel::CHANNEL_1)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fspllcfg, 0x09000407L, LEN_FS_PLLCFG);\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fsplltune, 0x1E, LEN_FS_PLLTUNE);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_2 || _channel == Channel::CHANNEL_4)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fspllcfg, 0x08400508L, LEN_FS_PLLCFG);\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fsplltune, 0x26, LEN_FS_PLLTUNE);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_3)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fspllcfg, 0x08401009L, LEN_FS_PLLCFG);\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fsplltune, 0x56, LEN_FS_PLLTUNE);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_5 || _channel == Channel::CHANNEL_7)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fspllcfg, 0x0800041DL, LEN_FS_PLLCFG);\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fsplltune, 0xBE, LEN_FS_PLLTUNE);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(FS_CTRL, FS_PLLTUNE_SUB, fsplltune, LEN_FS_PLLTUNE);\n\t\t\t_writeBytesToRegister(FS_CTRL, FS_PLLCFG_SUB, fspllcfg, LEN_FS_PLLCFG);\n\t\t}\n\n\t\tvoid _tune()\n\t\t{\n\t\t\t// these registers are going to be tuned/configured\n\t\t\t_agctune1();\n\t\t\t_agctune2();\n\t\t\t_agctune3();\n\t\t\t_drxtune0b();\n\t\t\t_drxtune1a();\n\t\t\t_drxtune1b();\n\t\t\t_drxtune2();\n\t\t\t_drxtune4H();\n\t\t\t_ldecfg1();\n\t\t\t_ldecfg2();\n\t\t\t_lderepc();\n\t\t\tif (_autoTXPower)\n\t\t\t\t_txpowertune();\n\t\t\t_rfrxctrlh();\n\t\t\t_rftxctrl();\n\t\t\tif (_autoTCPGDelay)\n\t\t\t\t_tcpgdelaytune();\n\t\t\t_fspll();\n\t\t}\n\n\t\tvoid _writeNetworkIdAndDeviceAddress()\n\t\t{\n\t\t\t_writeBytesToRegister(PANADR, NO_SUB, _networkAndAddress, LEN_PANADR);\n\t\t}\n\n\t\tvoid _writeSystemConfigurationRegister()\n\t\t{\n\t\t\t_writeBytesToRegister(SYS_CFG, NO_SUB, _syscfg, LEN_SYS_CFG);\n\t\t}\n\n\t\tvoid _writeChannelControlRegister()\n\t\t{\n\t\t\t_writeBytesToRegister(CHAN_CTRL, NO_SUB, _chanctrl, LEN_CHAN_CTRL);\n\t\t}\n\n\t\tvoid _writeTransmitFrameControlRegister()\n\t\t{\n\t\t\t_writeBytesToRegister(TX_FCTRL, NO_SUB, _txfctrl, LEN_TX_FCTRL);\n\t\t}\n\n\t\tvoid _writeSystemEventMaskRegister()\n\t\t{\n\t\t\t_writeBytesToRegister(SYS_MASK, NO_SUB, _sysmask, LEN_SYS_MASK);\n\t\t}\n\n\t\tvoid _writeAntennaDelayRegisters()\n\t\t{\n\t\t\tbyte antennaTxDelayBytes[2];\n\t\t\tbyte antennaRxDelayBytes[2];\n\t\t\tDW1000NgUtils::writeValueToBytes(antennaTxDelayBytes, _antennaTxDelay, LEN_TX_ANTD);\n\t\t\tDW1000NgUtils::writeValueToBytes(antennaRxDelayBytes, _antennaRxDelay, LEN_LDE_RXANTD);\n\t\t\t_writeBytesToRegister(TX_ANTD, NO_SUB, antennaTxDelayBytes, LEN_TX_ANTD);\n\t\t\t_writeBytesToRegister(LDE_IF, LDE_RXANTD_SUB, antennaRxDelayBytes, LEN_LDE_RXANTD);\n\t\t}\n\n\t\tvoid _writeConfiguration()\n\t\t{\n\t\t\t// write all configurations back to device\n\t\t\t_writeSystemConfigurationRegister();\n\t\t\t_writeChannelControlRegister();\n\t\t\t_writeTransmitFrameControlRegister();\n\t\t}\n\n\t\tvoid _useExtendedFrameLength(boolean val)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, PHR_MODE_0_BIT, val);\n\t\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, PHR_MODE_1_BIT, val);\n\t\t}\n\n\t\tvoid _setReceiverAutoReenable(boolean val)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, RXAUTR_BIT, val);\n\t\t}\n\n\t\tvoid _useFrameCheck(boolean val)\n\t\t{\n\t\t\t_frameCheck = val;\n\t\t}\n\n\t\tvoid _setNlosOptimization(boolean val)\n\t\t{\n\t\t\t_nlos = val;\n\t\t\tif (_nlos)\n\t\t\t{\n\t\t\t\t_ldecfg1();\n\t\t\t\t_ldecfg2();\n\t\t\t}\n\t\t}\n\n\t\tvoid _useSmartPower(boolean smartPower)\n\t\t{\n\t\t\t_smartPower = smartPower;\n\t\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, DIS_STXP_BIT, !smartPower);\n\t\t\t_writeSystemConfigurationRegister();\n\t\t\tif (_autoTXPower)\n\t\t\t\t_txpowertune();\n\t\t}\n\n\t\tvoid _setSFDMode(SFDMode mode)\n\t\t{\n\t\t\tswitch (mode)\n\t\t\t{\n\t\t\tcase SFDMode::STANDARD_SFD:\n\t\t\t\tDW1000NgUtils::setBit(_chanctrl, LEN_CHAN_CTRL, DWSFD_BIT, false);\n\t\t\t\tDW1000NgUtils::setBit(_chanctrl, LEN_CHAN_CTRL, TNSSFD_BIT, false);\n\t\t\t\tDW1000NgUtils::setBit(_chanctrl, LEN_CHAN_CTRL, RNSSFD_BIT, false);\n\t\t\t\t_standardSFD = true;\n\t\t\t\tbreak;\n\t\t\tcase SFDMode::DECAWAVE_SFD:\n\t\t\t\tDW1000NgUtils::setBit(_chanctrl, LEN_CHAN_CTRL, DWSFD_BIT, true);\n\t\t\t\tDW1000NgUtils::setBit(_chanctrl, LEN_CHAN_CTRL, TNSSFD_BIT, true);\n\t\t\t\tDW1000NgUtils::setBit(_chanctrl, LEN_CHAN_CTRL, RNSSFD_BIT, true);\n\t\t\t\t_standardSFD = false;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn; // TODO Proper error handling\n\t\t\t}\n\t\t}\n\n\t\tvoid _setChannel(Channel channel)\n\t\t{\n\t\t\tbyte chan = static_cast<byte>(channel);\n\t\t\tchan &= 0xF;\n\t\t\t_chanctrl[0] = ((chan | (chan << 4)) & 0xFF);\n\n\t\t\t_channel = channel;\n\t\t}\n\n\t\tvoid _setDataRate(DataRate data_rate)\n\t\t{\n\t\t\tbyte rate = static_cast<byte>(data_rate);\n\t\t\trate &= 0x03;\n\t\t\t_txfctrl[1] &= 0x83;\n\t\t\t_txfctrl[1] |= (byte)((rate << 5) & 0xFF);\n\t\t\t// special 110kbps flag\n\t\t\tif (data_rate == DataRate::RATE_110KBPS)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, RXM110K_BIT, true);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, RXM110K_BIT, false);\n\t\t\t}\n\t\t\t_dataRate = data_rate;\n\t\t}\n\n\t\tvoid _setPulseFrequency(PulseFrequency frequency)\n\t\t{\n\t\t\tbyte freq = static_cast<byte>(frequency);\n\t\t\tfreq &= 0x03;\n\t\t\t_txfctrl[2] &= 0xFC;\n\t\t\t_txfctrl[2] |= (byte)(freq & 0xFF);\n\t\t\t_chanctrl[2] &= 0xF3;\n\t\t\t_chanctrl[2] |= (byte)((freq << 2) & 0xFF);\n\n\t\t\t_pulseFrequency = frequency;\n\t\t}\n\n\t\tvoid _setPreambleLength(PreambleLength preamble_length)\n\t\t{\n\t\t\tbyte prealen = static_cast<byte>(preamble_length);\n\t\t\tprealen &= 0x0F;\n\t\t\t_txfctrl[2] &= 0xC3;\n\t\t\t_txfctrl[2] |= (byte)((prealen << 2) & 0xFF);\n\n\t\t\tswitch (preamble_length)\n\t\t\t{\n\t\t\tcase PreambleLength::LEN_64:\n\t\t\t\t_pacSize = PacSize::SIZE_8;\n\t\t\t\tbreak;\n\t\t\tcase PreambleLength::LEN_128:\n\t\t\t\t_pacSize = PacSize::SIZE_8;\n\t\t\t\tbreak;\n\t\t\tcase PreambleLength::LEN_256:\n\t\t\t\t_pacSize = PacSize::SIZE_16;\n\t\t\t\tbreak;\n\t\t\tcase PreambleLength::LEN_512:\n\t\t\t\t_pacSize = PacSize::SIZE_16;\n\t\t\t\tbreak;\n\t\t\tcase PreambleLength::LEN_1024:\n\t\t\t\t_pacSize = PacSize::SIZE_32;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t_pacSize = PacSize::SIZE_64; // In case of 1536, 2048 or 4096 preamble length.\n\t\t\t}\n\n\t\t\t_preambleLength = preamble_length;\n\t\t}\n\n\t\tvoid _setPreambleCode(PreambleCode preamble_code)\n\t\t{\n\t\t\tbyte preacode = static_cast<byte>(preamble_code);\n\t\t\tpreacode &= 0x1F;\n\t\t\t_chanctrl[2] &= 0x3F;\n\t\t\t_chanctrl[2] |= ((preacode << 6) & 0xFF);\n\t\t\t_chanctrl[3] = 0x00;\n\t\t\t_chanctrl[3] = ((((preacode >> 2) & 0x07) | (preacode << 3)) & 0xFF);\n\n\t\t\t_preambleCode = preamble_code;\n\t\t}\n\n\t\tboolean _checkPreambleCodeValidity()\n\t\t{\n\t\t\tbyte preacode = static_cast<byte>(_preambleCode);\n\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t{\n\t\t\t\tfor (auto i = 0; i < 2; i++)\n\t\t\t\t{\n\t\t\t\t\tif (preacode == preamble_validity_matrix_PRF16[(int)_channel][i])\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t{\n\t\t\t\tfor (auto i = 0; i < 4; i++)\n\t\t\t\t{\n\t\t\t\t\tif (preacode == preamble_validity_matrix_PRF64[(int)_channel][i])\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn false; // TODO Proper error handling\n\t\t\t}\n\t\t}\n\n\t\tvoid _setValidPreambleCode()\n\t\t{\n\t\t\tPreambleCode preamble_code;\n\n\t\t\tswitch (_channel)\n\t\t\t{\n\t\t\tcase Channel::CHANNEL_1:\n\t\t\t\tpreamble_code = _pulseFrequency == PulseFrequency::FREQ_16MHZ ? PreambleCode::CODE_2 : PreambleCode::CODE_10;\n\t\t\t\tbreak;\n\t\t\tcase Channel::CHANNEL_3:\n\t\t\t\tpreamble_code = _pulseFrequency == PulseFrequency::FREQ_16MHZ ? PreambleCode::CODE_6 : PreambleCode::CODE_10;\n\t\t\t\tbreak;\n\t\t\tcase Channel::CHANNEL_4:\n\t\t\tcase Channel::CHANNEL_7:\n\t\t\t\tpreamble_code = _pulseFrequency == PulseFrequency::FREQ_16MHZ ? PreambleCode::CODE_8 : PreambleCode::CODE_18;\n\t\t\t\tbreak;\n\t\t\tcase Channel::CHANNEL_2:\n\t\t\tcase Channel::CHANNEL_5:\n\t\t\t\tpreamble_code = _pulseFrequency == PulseFrequency::FREQ_16MHZ ? PreambleCode::CODE_3 : PreambleCode::CODE_10;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn; // TODO Proper Error Handling\n\t\t\t}\n\t\t\tbyte preacode = static_cast<byte>(preamble_code);\n\t\t\tpreacode &= 0x1F;\n\t\t\t_chanctrl[2] &= 0x3F;\n\t\t\t_chanctrl[2] |= ((preacode << 6) & 0xFF);\n\t\t\t_chanctrl[3] = 0x00;\n\t\t\t_chanctrl[3] = ((((preacode >> 2) & 0x07) | (preacode << 3)) & 0xFF);\n\n\t\t\t_preambleCode = preamble_code;\n\t\t}\n\n\t\tvoid _setNonStandardSFDLength()\n\t\t{\n\t\t\tswitch (_dataRate)\n\t\t\t{\n\t\t\tcase DataRate::RATE_6800KBPS:\n\t\t\t\t_writeByte(USR_SFD, SFD_LENGTH_SUB, 0x08);\n\t\t\t\tbreak;\n\t\t\tcase DataRate::RATE_850KBPS:\n\t\t\t\t_writeByte(USR_SFD, SFD_LENGTH_SUB, 0x10);\n\t\t\t\tbreak;\n\t\t\tcase DataRate::RATE_110KBPS:\n\t\t\t\t_writeByte(USR_SFD, SFD_LENGTH_SUB, 0x40);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn; // TODO Proper error handling\n\t\t\t}\n\t\t}\n\n\t\tvoid _interruptOnSent(boolean val)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_MASK, TXFRS_BIT, val);\n\t\t}\n\n\t\tvoid _interruptOnReceived(boolean val)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_MASK, RXDFR_BIT, val);\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_MASK, RXFCG_BIT, val);\n\t\t}\n\n\t\tvoid _interruptOnReceiveFailed(boolean val)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_STATUS, RXPHE_BIT, val);\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_STATUS, RXFCE_BIT, val);\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_STATUS, RXRFSL_BIT, val);\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_STATUS, LDEERR_BIT, val);\n\t\t}\n\n\t\tvoid _interruptOnReceiveTimeout(boolean val)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_MASK, RXRFTO_BIT, val);\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_MASK, RXPTO_BIT, val);\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_MASK, RXSFDTO_BIT, val);\n\t\t}\n\n\t\tvoid _interruptOnReceiveTimestampAvailable(boolean val)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_MASK, LDEDONE_BIT, val);\n\t\t}\n\n\t\tvoid _interruptOnAutomaticAcknowledgeTrigger(boolean val)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_MASK, AAT_BIT, val);\n\t\t}\n\n\t\tvoid _manageLDE()\n\t\t{\n\t\t\t// transfer any ldo tune values\n\t\t\tbyte ldoTune[LEN_OTP_RDAT];\n\t\t\tuint16_t LDOTUNE_ADDRESS = 0x04;\n\t\t\t_readBytesOTP(LDOTUNE_ADDRESS, ldoTune); // TODO #define\n\t\t\tif (ldoTune[0] != 0)\n\t\t\t{\n\t\t\t\t// TODO tuning available, copy over to RAM: use OTP_LDO bit\n\t\t\t}\n\t\t\t// tell the chip to load the LDE microcode\n\t\t\t// TODO remove clock-related code (PMSC_CTRL) as handled separately\n\t\t\tbyte pmscctrl0[LEN_PMSC_CTRL0];\n\t\t\tbyte otpctrl[LEN_OTP_CTRL];\n\t\t\tmemset(pmscctrl0, 0, LEN_PMSC_CTRL0);\n\t\t\tmemset(otpctrl, 0, LEN_OTP_CTRL);\n\t\t\t_readBytes(PMSC, PMSC_CTRL0_SUB, pmscctrl0, LEN_PMSC_CTRL0);\n\t\t\t_readBytes(OTP_IF, OTP_CTRL_SUB, otpctrl, LEN_OTP_CTRL);\n\t\t\tpmscctrl0[0] = 0x01;\n\t\t\tpmscctrl0[1] = 0x03;\n\t\t\totpctrl[1] = 0x80;\n\t\t\t_writeBytesToRegister(PMSC, PMSC_CTRL0_SUB, pmscctrl0, 2);\n\t\t\t// uCode\n\t\t\t_enableClock(LDE_CLOCK);\n\t\t\tdelay(5);\n\t\t\t_writeBytesToRegister(OTP_IF, OTP_CTRL_SUB, otpctrl, 2);\n\t\t\tdelay(1);\n\t\t\t_enableClock(SYS_AUTO_CLOCK);\n\t\t\tdelay(5);\n\t\t\tpmscctrl0[0] = 0x00;\n\t\t\tpmscctrl0[1] &= 0x02;\n\t\t\t_writeBytesToRegister(PMSC, PMSC_CTRL0_SUB, pmscctrl0, 2);\n\t\t}\n\n\t\t/* Crystal calibration from OTP (if available)\n\t\t * FS_XTALT - reg:0x2B, sub-reg:0x0E\n\t\t * OTP(one-time-programmable) memory map - table 10 */\n\t\tvoid _fsxtalt()\n\t\t{\n\t\t\tbyte fsxtalt[LEN_FS_XTALT];\n\t\t\tbyte buf_otp[4];\n\t\t\t_readBytesOTP(0x01E, buf_otp); // 0x01E -> byte[0]=XTAL_Trim\n\t\t\tif (buf_otp[0] == 0)\n\t\t\t{\n\t\t\t\t// No trim value available from OTP, use midrange value of 0x10\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fsxtalt, ((0x10 & 0x1F) | 0x60), LEN_FS_XTALT);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fsxtalt, ((buf_otp[0] & 0x1F) | 0x60), LEN_FS_XTALT);\n\t\t\t}\n\t\t\t// write configuration back to chip\n\t\t\t_writeBytesToRegister(FS_CTRL, FS_XTALT_SUB, fsxtalt, LEN_FS_XTALT);\n\t\t}\n\n\t\tvoid _clearReceiveStatus()\n\t\t{\n\t\t\t// clear latched RX bits (i.e. write 1 to clear)\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXDFR_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXFCG_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXPRD_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXSFDD_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXPHD_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, LDEDONE_BIT, true);\n\t\t\t_writeBytesToRegister(SYS_STATUS, NO_SUB, _sysstatus, LEN_SYS_STATUS);\n\t\t}\n\n\t\tvoid _clearReceiveTimestampAvailableStatus()\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, LDEDONE_BIT, true);\n\t\t\t_writeBytesToRegister(SYS_STATUS, NO_SUB, _sysstatus, LEN_SYS_STATUS);\n\t\t}\n\n\t\tvoid _clearReceiveTimeoutStatus()\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXRFTO_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXPTO_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXSFDTO_BIT, true);\n\t\t\t_writeBytesToRegister(SYS_STATUS, NO_SUB, _sysstatus, LEN_SYS_STATUS);\n\t\t}\n\n\t\tvoid _clearReceiveFailedStatus()\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXPHE_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXFCE_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXRFSL_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, AFFREJ_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, LDEERR_BIT, true);\n\t\t\t_writeBytesToRegister(SYS_STATUS, NO_SUB, _sysstatus, LEN_SYS_STATUS);\n\t\t}\n\n\t\tvoid _clearTransmitStatus()\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, AAT_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, TXFRB_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, TXPRS_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, TXPHS_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, TXFRS_BIT, true);\n\t\t\t_writeBytesToRegister(SYS_STATUS, NO_SUB, _sysstatus, LEN_SYS_STATUS);\n\t\t}\n\n\t\tvoid _resetReceiver()\n\t\t{\n\t\t\t/* Set to 0 only bit 28 */\n\t\t\t_writeToRegister(PMSC, PMSC_SOFTRESET_SUB, 0xE0, LEN_PMSC_SOFTRESET);\n\t\t\t/* Set SOFTRESET to all ones */\n\t\t\t_writeToRegister(PMSC, PMSC_SOFTRESET_SUB, 0xF0, LEN_PMSC_SOFTRESET);\n\t\t}\n\n\t\t/* Internal helpers to read configuration */\n\n\t\tvoid _readSystemConfigurationRegister()\n\t\t{\n\t\t\t_readBytes(SYS_CFG, NO_SUB, _syscfg, LEN_SYS_CFG);\n\t\t}\n\n\t\tvoid _readSystemEventStatusRegister()\n\t\t{\n\t\t\t_readBytes(SYS_STATUS, NO_SUB, _sysstatus, LEN_SYS_STATUS);\n\t\t}\n\n\t\tvoid _readNetworkIdAndDeviceAddress()\n\t\t{\n\t\t\t_readBytes(PANADR, NO_SUB, _networkAndAddress, LEN_PANADR);\n\t\t}\n\n\t\tvoid _readSystemEventMaskRegister()\n\t\t{\n\t\t\t_readBytes(SYS_MASK, NO_SUB, _sysmask, LEN_SYS_MASK);\n\t\t}\n\n\t\tvoid _readChannelControlRegister()\n\t\t{\n\t\t\t_readBytes(CHAN_CTRL, NO_SUB, _chanctrl, LEN_CHAN_CTRL);\n\t\t}\n\n\t\tvoid _readTransmitFrameControlRegister()\n\t\t{\n\t\t\t_readBytes(TX_FCTRL, NO_SUB, _txfctrl, LEN_TX_FCTRL);\n\t\t}\n\n\t\tboolean _isTransmitDone()\n\t\t{\n\t\t\treturn DW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, TXFRS_BIT);\n\t\t}\n\n\t\tboolean _isReceiveTimestampAvailable()\n\t\t{\n\t\t\treturn DW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, LDEDONE_BIT);\n\t\t}\n\n\t\tboolean _isReceiveDone()\n\t\t{\n\t\t\tif (_frameCheck)\n\t\t\t{\n\t\t\t\treturn (DW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXFCG_BIT) &&\n\t\t\t\t\t\tDW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXDFR_BIT));\n\t\t\t}\n\t\t\treturn DW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXDFR_BIT);\n\t\t}\n\n\t\tboolean _isReceiveFailed()\n\t\t{\n\t\t\treturn (DW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXPHE_BIT) ||\n\t\t\t\t\tDW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXFCE_BIT) ||\n\t\t\t\t\tDW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXRFSL_BIT) ||\n\t\t\t\t\tDW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, LDEERR_BIT));\n\t\t}\n\n\t\tboolean _isReceiveTimeout()\n\t\t{\n\t\t\treturn (DW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXRFTO_BIT) ||\n\t\t\t\t\tDW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXPTO_BIT) ||\n\t\t\t\t\tDW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXSFDTO_BIT));\n\t\t}\n\n\t\tboolean _isClockProblem()\n\t\t{\n\t\t\treturn (DW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, CLKPLL_LL_BIT) ||\n\t\t\t\t\tDW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RFPLL_LL_BIT));\n\t\t}\n\n\t\tvoid _disableSequencing()\n\t\t{\n\t\t\t_enableClock(SYS_XTI_CLOCK);\n\t\t\tbyte zero[2];\n\t\t\tDW1000NgUtils::writeValueToBytes(zero, 0x0000, 2);\n\t\t\t_writeBytesToRegister(PMSC, PMSC_CTRL1_SUB, zero, 2); // To re-enable write 0xE7\n\t\t}\n\n\t\tvoid _configureRFTransmitPowerSpectrumTestMode()\n\t\t{\n\t\t\t/* Enabled TXFEN, PLLFEN, LDOFEN and set TXRXSW to TX */\n\t\t\tbyte enable_mask[4];\n\t\t\tDW1000NgUtils::writeValueToBytes(enable_mask, 0x005FFF00, LEN_RX_CONF_SUB);\n\t\t\t_writeBytesToRegister(RF_CONF, RF_CONF_SUB, enable_mask, LEN_RX_CONF_SUB);\n\t\t}\n\n\t\tvoid _uploadConfigToAON()\n\t\t{\n\t\t\t/* Write 1 in UPL_CFG_BIT */\n\t\t\t_writeToRegister(AON, AON_CTRL_SUB, 0x04, LEN_AON_CTRL);\n\t\t\t/* Clear the register */\n\t\t\t_writeToRegister(AON, AON_CTRL_SUB, 0x00, LEN_AON_CTRL);\n\t\t}\n\t}\n\n\t/* ####################### PUBLIC ###################### */\n\n\tvoid initialize(uint8_t ss, uint8_t irq, uint8_t rst)\n\t{\n\t\t// generous initial init/wake-up-idle delay\n\t\tdelay(5);\n\t\t_ss = ss;\n\t\t_irq = irq;\n\t\t_rst = rst;\n\n\t\tif (rst != 0xff)\n\t\t{\n\t\t\t// DW1000 data sheet v2.08 Â§5.6.1 page 20, the RSTn pin should not be driven high but left floating.\n\t\t\tpinMode(_rst, INPUT);\n\t\t}\n\n\t\tSPIporting::SPIinit();\n\t\t// pin and basic member setup\n\t\t// attach interrupt\n\t\t// TODO throw error if pin is not a interrupt pin\n\t\tif (_irq != 0xff)\n\t\t{\n\t\t\tattachInterrupt(digitalPinToInterrupt(_irq), interruptServiceRoutine, RISING);\n\t\t\t// attachInterrupt(digitalPinToInterrupt(_irq), interruptServiceRoutine, FALLING);\n\t\t}\n\n\t\tSPIporting::SPIselect(_ss, _irq);\n\t\t// reset chip (either soft or hard)\n\t\treset();\n\n\t\tSPIporting::setSPIspeed(SPIClock::SLOW);\n\t\t_enableClock(SYS_XTI_CLOCK);\n\t\tdelay(5);\n\n\t\t// Configure the CPLL lock detect\n\t\t_writeBitToRegister(EXT_SYNC, EC_CTRL_SUB, LEN_EC_CTRL, PLLLDT_BIT, true);\n\n\t\t// Configure XTAL trim\n\t\t_fsxtalt();\n\n\t\t// load LDE micro-code\n\t\t_manageLDE();\n\n\t\t// read the temp and vbat readings from OTP that were recorded during production test\n\t\t// see 6.3.1 OTP memory map\n\t\tbyte buf_otp[4];\n\t\t_readBytesOTP(0x008, buf_otp); // the stored 3.3 V reading\n\t\t_vmeas3v3 = buf_otp[0];\n\t\t// Serial.printf(\"_vmeas3v3=%d\\r\\n\", _vmeas3v3);\n\t\t_readBytesOTP(0x009, buf_otp); // the stored 23C reading\n\t\t_tmeas23C = buf_otp[0];\n\t\t// Serial.printf(\"_tmeas23C=%d\\r\\n\", _tmeas23C);\n\n\t\t_enableClock(SYS_AUTO_CLOCK);\n\t\tdelay(5);\n\t\tSPIporting::setSPIspeed(SPIClock::FAST);\n\n\t\t_readNetworkIdAndDeviceAddress();\n\t\t_readSystemConfigurationRegister();\n\t\t_readChannelControlRegister();\n\t\t_readTransmitFrameControlRegister();\n\t\t_readSystemEventMaskRegister();\n\n\t\t/* Cleared AON:CFG1(0x2C:0x0A) for proper operation of deepSleep */\n\t\t_writeToRegister(AON, AON_CFG1_SUB, 0x00, LEN_AON_CFG1);\n\t}\n\n\tvoid initializeNoInterrupt(uint8_t ss, uint8_t rst)\n\t{\n\t\tinitialize(ss, 0xff, rst);\n\t}\n\n\t/* callback handler management. */\n\tvoid attachErrorHandler(void (*handleError)(void))\n\t{\n\t\t_handleError = handleError;\n\t}\n\n\tvoid attachSentHandler(void (*handleSent)(void))\n\t{\n\t\t_handleSent = handleSent;\n\t}\n\n\tvoid attachReceivedHandler(void (*handleReceived)(void))\n\t{\n\t\t_handleReceived = handleReceived;\n\t}\n\n\tvoid attachReceiveFailedHandler(void (*handleReceiveFailed)(void))\n\t{\n\t\t_handleReceiveFailed = handleReceiveFailed;\n\t}\n\n\tvoid attachReceiveTimeoutHandler(void (*handleReceiveTimeout)(void))\n\t{\n\t\t_handleReceiveTimeout = handleReceiveTimeout;\n\t}\n\n\tvoid attachReceiveTimestampAvailableHandler(void (*handleReceiveTimestampAvailable)(void))\n\t{\n\t\t_handleReceiveTimestampAvailable = handleReceiveTimestampAvailable;\n\t}\n\n\tvoid interruptServiceRoutine()\n\t{\n\t\t// Serial.printf(\"test----------------------------0\\r\\n\");\n\t\t// read current status and handle via callbacks\n\t\t_readSystemEventStatusRegister();\n\t\tif (_isClockProblem() /* TODO and others */ && _handleError != 0)\n\t\t{\n\t\t\t(*_handleError)();\n\t\t\t// Serial.printf(\"interrupt----------------------------1\\r\\n\");\n\t\t}\n\t\tif (_isTransmitDone())\n\t\t{\n\t\t\t_clearTransmitStatus();\n\t\t\tif (_handleSent != nullptr)\n\t\t\t{\n\t\t\t\t(*_handleSent)();\n\t\t\t\t// Serial.printf(\"interrupt----------------------------2\\r\\n\");\n\t\t\t}\n\t\t}\n\t\tif (_isReceiveTimestampAvailable())\n\t\t{\n\t\t\t_clearReceiveTimestampAvailableStatus();\n\t\t\tif (_handleReceiveTimestampAvailable != nullptr)\n\t\t\t{\n\t\t\t\t(*_handleReceiveTimestampAvailable)();\n\t\t\t\t// Serial.printf(\"interrupt----------------------------3\\r\\n\");\n\t\t\t}\n\t\t}\n\t\tif (_isReceiveFailed())\n\t\t{\n\t\t\t_clearReceiveFailedStatus();\n\t\t\tforceTRxOff();\n\t\t\t_resetReceiver();\n\t\t\tif (_handleReceiveFailed != nullptr)\n\t\t\t{\n\t\t\t\t(*_handleReceiveFailed)();\n\t\t\t\t// Serial.printf(\"interrupt----------------------------4\\r\\n\");\n\t\t\t}\n\t\t}\n\t\telse if (_isReceiveTimeout())\n\t\t{\n\t\t\t_clearReceiveTimeoutStatus();\n\t\t\tforceTRxOff();\n\t\t\t_resetReceiver();\n\t\t\tif (_handleReceiveTimeout != nullptr)\n\t\t\t{\n\t\t\t\t(*_handleReceiveTimeout)();\n\t\t\t\t// Serial.printf(\"interrupt----------------------------5\\r\\n\");\n\t\t\t}\n\t\t}\n\t\telse if (_isReceiveDone())\n\t\t{\n\t\t\t_clearReceiveStatus();\n\t\t\tif (_handleReceived != nullptr)\n\t\t\t{\n\t\t\t\t(*_handleReceived)();\n\t\t\t\t// Serial.printf(\"interrupt----------------------------6\\r\\n\");\n\t\t\t}\n\t\t}\n\t\t// Latched bits in status register are reset by writing 1 to them\n\t\tmemset(_sysstatus, 0xff, LEN_SYS_STATUS);\n\t\t_writeBytesToRegister(SYS_STATUS, NO_SUB, _sysstatus, LEN_SYS_STATUS);\n\t}\n\n\tboolean isTransmitDone()\n\t{\n\t\t_readSystemEventStatusRegister();\n\t\treturn _isTransmitDone();\n\t}\n\n\tvoid clearTransmitStatus()\n\t{\n\t\t_clearTransmitStatus();\n\t}\n\n\tboolean isReceiveDone()\n\t{\n\t\t_readSystemEventStatusRegister();\n\t\treturn _isReceiveDone();\n\t}\n\n\tvoid clearReceiveStatus()\n\t{\n\t\t_clearReceiveStatus();\n\t}\n\n\tboolean isReceiveFailed()\n\t{\n\t\t_readSystemEventStatusRegister();\n\t\treturn _isReceiveFailed();\n\t}\n\n\tvoid clearReceiveFailedStatus()\n\t{\n\t\t_clearReceiveFailedStatus();\n\t\tforceTRxOff();\n\t\t_resetReceiver();\n\t}\n\n\tboolean isReceiveTimeout()\n\t{\n\t\t_readSystemEventMaskRegister();\n\t\treturn _isReceiveTimeout();\n\t}\n\n\tvoid clearReceiveTimeoutStatus()\n\t{\n\t\t_clearReceiveTimeoutStatus();\n\t\tforceTRxOff();\n\t\t_resetReceiver();\n\t}\n\n\tvoid enableDebounceClock()\n\t{\n\t\tbyte pmscctrl0[LEN_PMSC_CTRL0];\n\t\tmemset(pmscctrl0, 0, LEN_PMSC_CTRL0);\n\t\t_readBytes(PMSC, PMSC_CTRL0_SUB, pmscctrl0, LEN_PMSC_CTRL0);\n\t\tDW1000NgUtils::setBit(pmscctrl0, LEN_PMSC_CTRL0, GPDCE_BIT, 1);\n\t\tDW1000NgUtils::setBit(pmscctrl0, LEN_PMSC_CTRL0, KHZCLKEN_BIT, 1);\n\t\t_writeBytesToRegister(PMSC, PMSC_CTRL0_SUB, pmscctrl0, LEN_PMSC_CTRL0);\n\t\t_debounceClockEnabled = true;\n\t}\n\n\tvoid enableLedBlinking()\n\t{\n\t\tbyte pmscledc[LEN_PMSC_LEDC];\n\t\tmemset(pmscledc, 0, LEN_PMSC_LEDC);\n\t\t_readBytes(PMSC, PMSC_LEDC_SUB, pmscledc, LEN_PMSC_LEDC);\n\t\tDW1000NgUtils::setBit(pmscledc, LEN_PMSC_LEDC, BLNKEN, 1);\n\t\t_writeBytesToRegister(PMSC, PMSC_LEDC_SUB, pmscledc, LEN_PMSC_LEDC);\n\t}\n\n\tvoid setGPIOMode(uint8_t msgp, uint8_t mode)\n\t{\n\t\tbyte gpiomode[LEN_GPIO_MODE];\n\t\tmemset(gpiomode, 0, LEN_GPIO_MODE);\n\t\t_readBytes(GPIO_CTRL, GPIO_MODE_SUB, gpiomode, LEN_GPIO_MODE);\n\t\tfor (char i = 0; i < 2; i++)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(gpiomode, LEN_GPIO_MODE, msgp + i, (mode >> i) & 1);\n\t\t}\n\t\t_writeBytesToRegister(GPIO_CTRL, GPIO_MODE_SUB, gpiomode, LEN_GPIO_MODE);\n\t}\n\n\tvoid applySleepConfiguration(sleep_configuration_t sleep_config)\n\t{\n\t\tbyte aon_wcfg[LEN_AON_WCFG];\n\t\t_readBytes(AON, AON_WCFG_SUB, aon_wcfg, LEN_AON_WCFG);\n\t\tbyte aon_cfg0[1];\n\t\tmemset(aon_cfg0, 0, 1);\n\n\t\tDW1000NgUtils::setBit(aon_wcfg, LEN_AON_WCFG, ONW_RADC_BIT, sleep_config.onWakeUpRunADC);\n\t\tDW1000NgUtils::setBit(aon_wcfg, LEN_AON_WCFG, ONW_RX_BIT, sleep_config.onWakeUpReceive);\n\t\tDW1000NgUtils::setBit(aon_wcfg, LEN_AON_WCFG, ONW_LEUI_BIT, sleep_config.onWakeUpLoadEUI);\n\t\tDW1000NgUtils::setBit(aon_wcfg, LEN_AON_WCFG, ONW_LDC_BIT, true);\n\t\tDW1000NgUtils::setBit(aon_wcfg, LEN_AON_WCFG, ONW_L64P_BIT, sleep_config.onWakeUpLoadL64Param);\n\t\tDW1000NgUtils::setBit(aon_wcfg, LEN_AON_WCFG, ONW_PRES_SLEEP_BIT, sleep_config.preserveSleep);\n\t\tDW1000NgUtils::setBit(aon_wcfg, LEN_AON_WCFG, ONW_LLDE_BIT, true);\n\t\tDW1000NgUtils::setBit(aon_wcfg, LEN_AON_WCFG, ONW_LLDO_BIT, true);\n\t\t_writeBytesToRegister(AON, AON_WCFG_SUB, aon_wcfg, LEN_AON_WCFG);\n\n\t\tDW1000NgUtils::setBit(aon_cfg0, 1, WAKE_PIN_BIT, sleep_config.enableWakePIN);\n\t\tDW1000NgUtils::setBit(aon_cfg0, 1, WAKE_SPI_BIT, sleep_config.enableWakeSPI);\n\t\tDW1000NgUtils::setBit(aon_cfg0, 1, WAKE_CNT_BIT, false);\n\t\tDW1000NgUtils::setBit(aon_cfg0, 1, SLEEP_EN_BIT, sleep_config.enableSLP);\n\t\t_writeBytesToRegister(AON, AON_CFG0_SUB, aon_cfg0, 1); // Deletes 3 bits of the unused LPCLKDIVA\n\t}\n\n\t/*Puts the device into sleep/deepSleep mode. This function also upload sleep config to AON. */\n\tvoid deepSleep()\n\t{\n\t\t/* Clear the register */\n\t\t_writeToRegister(AON, AON_CTRL_SUB, 0x00, LEN_AON_CTRL);\n\t\t/* Write 1 in SAVE_BIT */\n\t\t_writeToRegister(AON, AON_CTRL_SUB, 0x02, LEN_AON_CTRL);\n\t}\n\n\tvoid spiWakeup()\n\t{\n\t\tbyte deviceId[LEN_DEV_ID];\n\t\tbyte expectedDeviceId[LEN_DEV_ID];\n\t\tDW1000NgUtils::writeValueToBytes(expectedDeviceId, 0xDECA0130, LEN_DEV_ID);\n\t\t_readBytes(DEV_ID, NO_SUB, deviceId, LEN_DEV_ID);\n\t\tif (memcmp(deviceId, expectedDeviceId, LEN_DEV_ID))\n\t\t{\n\t\t\tdigitalWrite(_ss, LOW);\n\t\t\tdelay(1);\n\t\t\tdigitalWrite(_ss, HIGH);\n\t\t\tdelay(5);\n\t\t\tsetTxAntennaDelay(_antennaTxDelay);\n\t\t\tif (_debounceClockEnabled)\n\t\t\t{\n\t\t\t\tenableDebounceClock();\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid reset()   \n\t{\n\t\tif (_rst == 0xff)\n\t\t{ /* Fallback to Software Reset */\n\t\t\tsoftwareReset();\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// DW1000Ng data sheet v2.08 Â§5.6.1 page 20, the RSTn pin should not be driven high but left floating.\n\t\t\tpinMode(_rst, OUTPUT);\n\t\t\tdigitalWrite(_rst, LOW);\n\t\t\tdelay(2); // DW1000Ng data sheet v2.08 Â§5.6.1 page 20: nominal 50ns, to be safe take more time\n\t\t\tpinMode(_rst, INPUT);\n\t\t\tdelay(5); // dw1000Ng data sheet v1.2 page 5: nominal 3 ms, to be safe take more time\n\t\t}\n\t}\n\n\tvoid softwareReset()\n\t{\n\t\tSPIporting::setSPIspeed(SPIClock::SLOW);\n\n\t\t/* Disable sequencing and go to state \"INIT\" - (a) Sets SYSCLKS to 01 */\n\t\t_disableSequencing();\n\t\t/* Clear AON and WakeUp configuration */\n\t\t_writeToRegister(AON, AON_WCFG_SUB, 0x00, LEN_AON_WCFG);\n\t\t_writeToRegister(AON, AON_CFG0_SUB, 0x00, LEN_AON_CFG0);\n\t\t// TODO change this with uploadToAON\n\t\t_writeToRegister(AON, AON_CTRL_SUB, 0x00, LEN_AON_CTRL);\n\t\t_writeToRegister(AON, AON_CTRL_SUB, 0x02, LEN_AON_CTRL);\n\t\t/* (b) Clear SOFTRESET to all zeroâ€™s */\n\t\t_writeToRegister(PMSC, PMSC_SOFTRESET_SUB, 0x00, LEN_PMSC_SOFTRESET);\n\t\tdelay(1);\n\t\t/* (c) Set SOFTRESET to all ones */\n\t\t_writeToRegister(PMSC, PMSC_SOFTRESET_SUB, 0xF0, LEN_PMSC_SOFTRESET);\n\t}\n\n\t/* ###########################################################################\n\t * #### Pretty printed device information ####################################\n\t * ######################################################################### */\n\n\tvoid getPrintableDeviceIdentifier(char msgBuffer[])\n\t{\n\t\tbyte data[LEN_DEV_ID];\n\t\t_readBytes(DEV_ID, NO_SUB, data, LEN_DEV_ID);\n\t\tsprintf(msgBuffer, \"%02X - model: %d, version: %d, revision: %d\",\n\t\t\t\t(uint16_t)((data[3] << 8) | data[2]), data[1], (data[0] >> 4) & 0x0F, data[0] & 0x0F);\n\t}\n\n\tvoid getPrintableExtendedUniqueIdentifier(char msgBuffer[])\n\t{\n\t\tbyte data[LEN_EUI];\n\t\t_readBytes(EUI, NO_SUB, data, LEN_EUI);\n\t\tsprintf(msgBuffer, \"%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X\",\n\t\t\t\tdata[7], data[6], data[5], data[4], data[3], data[2], data[1], data[0]);\n\t}\n\n\tvoid getPrintableNetworkIdAndShortAddress(char msgBuffer[])\n\t{\n\t\tbyte data[LEN_PANADR];\n\t\t_readBytes(PANADR, NO_SUB, data, LEN_PANADR);\n\t\tsprintf(msgBuffer, \"PAN: %02X, Short Address: %02X\",\n\t\t\t\t(uint16_t)((data[3] << 8) | data[2]), (uint16_t)((data[1] << 8) | data[0]));\n\t}\n\n\tvoid getPrintableDeviceMode(char msgBuffer[])\n\t{\n\t\tuint16_t dr;\n\t\tuint8_t prf;\n\t\tuint16_t plen;\n\t\tuint8_t pcode;\n\t\tuint8_t ch;\n\t\tbyte chan_ctrl[LEN_CHAN_CTRL];\n\t\tbyte tx_fctrl[LEN_TX_FCTRL];\n\t\t_readBytes(CHAN_CTRL, NO_SUB, chan_ctrl, LEN_CHAN_CTRL);\n\t\t_readBytes(TX_FCTRL, NO_SUB, tx_fctrl, LEN_TX_FCTRL);\n\t\t/* Data Rate from 0x08 bits:13-14(tx_fctrl) */\n\t\tdr = (uint16_t)(tx_fctrl[1] >> 5 & 0x3);\n\t\tswitch (dr)\n\t\t{\n\t\tcase 0x00:\n\t\t\tdr = 110;\n\t\t\tbreak;\n\t\tcase 0x01:\n\t\t\tdr = 850;\n\t\t\tbreak;\n\t\tcase 0x02:\n\t\t\tdr = 6800;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn; // TODO Error handling\n\t\t}\n\t\t/* PRF(16 or 64) from 0x1F bits:18-19(chan_ctrl) */\n\t\tprf = (uint8_t)(chan_ctrl[2] >> 2 & 0x03);\n\t\tif (prf == 0x01)\n\t\t{\n\t\t\tprf = 16;\n\t\t}\n\t\telse if (prf == 0x02)\n\t\t{\n\t\t\tprf = 64;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn; // TODO Error handling\n\t\t}\n\t\t/* PreambleLength from 0x08 bits:18-21(tx_fctrl) */\n\t\tplen = (uint16_t)(tx_fctrl[2] >> 2 & 0xF);\n\t\tswitch (plen)\n\t\t{\n\t\tcase 0x01:\n\t\t\tplen = 64;\n\t\t\tbreak;\n\t\tcase 0x05:\n\t\t\tplen = 128;\n\t\t\tbreak;\n\t\tcase 0x09:\n\t\t\tplen = 256;\n\t\t\tbreak;\n\t\tcase 0x0D:\n\t\t\tplen = 512;\n\t\t\tbreak;\n\t\tcase 0x02:\n\t\t\tplen = 1024;\n\t\t\tbreak;\n\t\tcase 0x06:\n\t\t\tplen = 1536;\n\t\t\tbreak;\n\t\tcase 0x0A:\n\t\t\tplen = 2048;\n\t\t\tbreak;\n\t\tcase 0x03:\n\t\t\tplen = 4096;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn; // TODO Error handling\n\t\t}\n\t\t/* Channel from 0x1F bits:0-4(tx_chan) */\n\t\tch = (uint8_t)(chan_ctrl[0] & 0xF);\n\t\t/* Preamble Code from 0x1F bits:24-31(chan_ctrl) */\n\t\tpcode = (uint8_t)(chan_ctrl[3] >> 3 & 0x1F);\n\t\tsprintf(msgBuffer, \"Data rate: %u kb/s, PRF: %u MHz, Preamble: %u symbols, Channel: #%u, Preamble code #%u\", dr, prf, plen, ch, pcode);\n\t}\n\n\t/* ###########################################################################\n\t * #### DW1000Ng operation functions ###########################################\n\t * ######################################################################### */\n\n\tvoid setNetworkId(uint16_t val)\n\t{\n\t\t_networkAndAddress[2] = (byte)(val & 0xFF);\n\t\t_networkAndAddress[3] = (byte)((val >> 8) & 0xFF);\n\t\t_writeNetworkIdAndDeviceAddress();\n\t}\n\n\tvoid getNetworkId(byte id[])\n\t{\n\t\t_readNetworkIdAndDeviceAddress();\n\t\tid[0] = _networkAndAddress[2];\n\t\tid[1] = _networkAndAddress[3];\n\t}\n\n\tvoid setDeviceAddress(uint16_t val)\n\t{\n\t\t_networkAndAddress[0] = (byte)(val & 0xFF);\n\t\t_networkAndAddress[1] = (byte)((val >> 8) & 0xFF);\n\t\t_writeNetworkIdAndDeviceAddress();\n\t}\n\n\tvoid getDeviceAddress(byte address[])\n\t{\n\t\t_readNetworkIdAndDeviceAddress();\n\t\taddress[0] = _networkAndAddress[0];\n\t\taddress[1] = _networkAndAddress[1];\n\t}\n\n\tvoid setEUI(char eui[])\n\t{\n\t\tbyte eui_byte[LEN_EUI];\n\t\tDW1000NgUtils::convertToByte(eui, eui_byte);\n\t\tsetEUI(eui_byte);\n\t}\n\n\tvoid setEUI(byte eui[])\n\t{\n\t\t// we reverse the address->\n\t\tbyte reverseEUI[8];\n\t\tuint8_t size = 8;\n\t\tfor (uint8_t i = 0; i < size; i++)\n\t\t{\n\t\t\t*(reverseEUI + i) = *(eui + size - i - 1);\n\t\t}\n\t\t_writeBytesToRegister(EUI, NO_SUB, reverseEUI, LEN_EUI);\n\t}\n\n\tvoid getEUI(byte eui[])\n\t{\n\t\t_readBytes(EUI, NO_SUB, eui, LEN_EUI);\n\t}\n\n\tfloat getTemperature()\n\t{\n\t\t_vbatAndTempSteps();\n\t\tbyte sar_ltemp = 0;\n\t\t_readBytes(TX_CAL, 0x04, &sar_ltemp, 1);\n\t\treturn (sar_ltemp - _tmeas23C) * 1.14f + 23.0f;\n\t}\n\n\tfloat getBatteryVoltage()\n\t{\n\t\t_vbatAndTempSteps();\n\t\tbyte sar_lvbat = 0;\n\t\t_readBytes(TX_CAL, 0x03, &sar_lvbat, 1);\n\t\treturn (sar_lvbat - _vmeas3v3) / 173.0f + 3.3f;\n\t}\n\n\tvoid getTemperatureAndBatteryVoltage(float &temp, float &vbat)\n\t{\n\t\t// follow the procedure from section 6.4 of the User Manual\n\t\t_vbatAndTempSteps();\n\t\tdelay(1);\n\t\tbyte sar_lvbat = 0;\n\t\t_readBytes(TX_CAL, 0x03, &sar_lvbat, 1);\n\t\tbyte sar_ltemp = 0;\n\t\t_readBytes(TX_CAL, 0x04, &sar_ltemp, 1);\n\n\t\t// calculate voltage and temperature\n\t\tvbat = (sar_lvbat - _vmeas3v3) / 173.0f + 3.3f;\n\t\ttemp = (sar_ltemp - _tmeas23C) * 1.14f + 23.0f;\n\t}\n\n\tvoid enableFrameFiltering(frame_filtering_configuration_t config)\n\t{\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFEN_BIT, true);\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFBC_BIT, config.behaveAsCoordinator);\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFAB_BIT, config.allowBeacon);\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFAD_BIT, config.allowData);\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFAA_BIT, config.allowAcknowledgement);\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFAM_BIT, config.allowMacCommand);\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFAR_BIT, config.allowAllReserved);\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFA4_BIT, config.allowReservedFour);\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFA5_BIT, config.allowReservedFive);\n\n\t\t_writeSystemConfigurationRegister();\n\t}\n\n\tvoid disableFrameFiltering()\n\t{\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFEN_BIT, false);\n\t\t_writeSystemConfigurationRegister();\n\t}\n\n\tvoid setDoubleBuffering(boolean val)\n\t{\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, DIS_DRXB_BIT, !val);\n\t}\n\n\tvoid setAntennaDelay(uint16_t value)\n\t{\n\t\t_antennaTxDelay = value;\n\t\t_antennaRxDelay = value;\n\t\t_writeAntennaDelayRegisters();\n\t}\n\n\tvoid setTxAntennaDelay(uint16_t value)\n\t{\n\t\t_antennaTxDelay = value;\n\t\t_writeAntennaDelayRegisters();\n\t}\n\tvoid setRxAntennaDelay(uint16_t value)\n\t{\n\t\t_antennaRxDelay = value;\n\t\t_writeAntennaDelayRegisters();\n\t}\n\n\tuint16_t getTxAntennaDelay()\n\t{\n\t\treturn _antennaTxDelay;\n\t}\n\tuint16_t getRxAntennaDelay()\n\t{\n\t\treturn _antennaRxDelay;\n\t}\n\n\tvoid forceTRxOff()\n\t{\n\t\tmemset(_sysctrl, 0, LEN_SYS_CTRL);\n\t\tDW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, TRXOFF_BIT, true);\n\t\t_writeBytesToRegister(SYS_CTRL, NO_SUB, _sysctrl, LEN_SYS_CTRL);\n\t}\n\n\tvoid startReceive(ReceiveMode mode)\n\t{\n\t\tmemset(_sysctrl, 0, LEN_SYS_CTRL);\n\t\tDW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, SFCST_BIT, !_frameCheck);\n\t\tif (mode == ReceiveMode::DELAYED)\n\t\t\tDW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, RXDLYS_BIT, true);\n\t\tDW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, RXENAB_BIT, true);\n\t\t_writeBytesToRegister(SYS_CTRL, NO_SUB, _sysctrl, LEN_SYS_CTRL);\n\t}\n\n\tvoid startTransmit(TransmitMode mode)\n\t{\n\t\tmemset(_sysctrl, 0, LEN_SYS_CTRL);\n\t\tDW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, SFCST_BIT, !_frameCheck);\n\t\tif (mode == TransmitMode::DELAYED)\n\t\t\tDW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, TXDLYS_BIT, true);\n\t\tif (_wait4resp)\n\t\t\tDW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, WAIT4RESP_BIT, true);\n\n\t\tDW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, TXSTRT_BIT, true);\n\t\t_writeBytesToRegister(SYS_CTRL, NO_SUB, _sysctrl, LEN_SYS_CTRL);\n\t}\n\n\tvoid setInterruptPolarity(boolean val)\n\t{\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, HIRQ_POL_BIT, val);\n\t\t_writeSystemConfigurationRegister();\n\t}\n\n\tvoid applyConfiguration(device_configuration_t config)\n\t{\n\t\tforceTRxOff();\n\n\t\t_useExtendedFrameLength(config.extendedFrameLength);\n\t\t_setReceiverAutoReenable(config.receiverAutoReenable);\n\t\t_useSmartPower(config.smartPower);\n\t\t_useFrameCheck(config.frameCheck);\n\t\t_setNlosOptimization(config.nlos);\n\t\t_setSFDMode(config.sfd);\n\t\t_setChannel(config.channel);\n\t\t_setDataRate(config.dataRate);\n\t\t_setPulseFrequency(config.pulseFreq);\n\t\t_setPreambleLength(config.preambleLen);\n\t\t_setPreambleCode(config.preaCode);\n\n\t\tif (!_checkPreambleCodeValidity())\n\t\t\t_setValidPreambleCode();\n\n\t\tif (!_standardSFD)\n\t\t\t_setNonStandardSFDLength();\n\n\t\t// writes configuration to registers\n\t\t_writeConfiguration();\n\t\t// tune according to configuration\n\t\t_tune();\n\t}\n\n\tChannel getChannel()\n\t{\n\t\treturn _channel;\n\t}\n\n\tPulseFrequency getPulseFrequency()\n\t{\n\t\treturn _pulseFrequency;\n\t}\n\n\tvoid setPreambleDetectionTimeout(uint16_t pacSize)\n\t{\n\t\tbyte drx_pretoc[LEN_DRX_PRETOC];\n\t\tDW1000NgUtils::writeValueToBytes(drx_pretoc, pacSize, LEN_DRX_PRETOC);\n\t\t_writeBytesToRegister(DRX_TUNE, DRX_PRETOC_SUB, drx_pretoc, LEN_DRX_PRETOC);\n\t}\n\n\tvoid setSfdDetectionTimeout(uint16_t preambleSymbols)\n\t{\n\t\tbyte drx_sfdtoc[LEN_DRX_SFDTOC];\n\t\tDW1000NgUtils::writeValueToBytes(drx_sfdtoc, preambleSymbols, LEN_DRX_SFDTOC);\n\t\t_writeBytesToRegister(DRX_TUNE, DRX_SFDTOC_SUB, drx_sfdtoc, LEN_DRX_SFDTOC);\n\t}\n\n\tvoid setReceiveFrameWaitTimeoutPeriod(uint16_t timeMicroSeconds)\n\t{\n\t\tif (timeMicroSeconds > 0)\n\t\t{\n\t\t\tbyte rx_wfto[LEN_RX_WFTO];\n\t\t\tDW1000NgUtils::writeValueToBytes(rx_wfto, timeMicroSeconds, LEN_RX_WFTO);\n\t\t\t_writeBytesToRegister(RX_WFTO, NO_SUB, rx_wfto, LEN_RX_WFTO);\n\t\t\t/* enable frame wait timeout bit */\n\t\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, RXWTOE_BIT, true);\n\t\t\t_writeSystemConfigurationRegister();\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* disable frame wait timeout bit */\n\t\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, RXWTOE_BIT, false);\n\t\t\t_writeSystemConfigurationRegister();\n\t\t}\n\t}\n\n\tvoid applyInterruptConfiguration(interrupt_configuration_t interrupt_config)\n\t{\n\t\tforceTRxOff();\n\n\t\t_interruptOnSent(interrupt_config.interruptOnSent);\n\t\t_interruptOnReceived(interrupt_config.interruptOnReceived);\n\t\t_interruptOnReceiveFailed(interrupt_config.interruptOnReceiveFailed);\n\t\t_interruptOnReceiveTimeout(interrupt_config.interruptOnReceiveTimeout);\n\t\t_interruptOnReceiveTimestampAvailable(interrupt_config.interruptOnReceiveTimestampAvailable);\n\t\t_interruptOnAutomaticAcknowledgeTrigger(interrupt_config.interruptOnAutomaticAcknowledgeTrigger);\n\n\t\t_writeSystemEventMaskRegister();\n\t}\n\n\tvoid setWait4Response(uint32_t timeMicroSeconds)\n\t{\n\t\t_wait4resp = timeMicroSeconds == 0 ? false : true;\n\n\t\t/* Check if it overflows 20 bits */\n\t\tif (timeMicroSeconds > 1048575)\n\t\t\ttimeMicroSeconds = 1048575;\n\n\t\tbyte W4R_TIME[LEN_ACK_RESP_T_W4R_TIME_SUB];\n\t\tDW1000NgUtils::writeValueToBytes(W4R_TIME, timeMicroSeconds, LEN_ACK_RESP_T_W4R_TIME_SUB);\n\t\tW4R_TIME[2] &= 0x0F;\n\t\t_writeBytesToRegister(ACK_RESP_T, ACK_RESP_T_W4R_TIME_SUB, W4R_TIME, LEN_ACK_RESP_T_W4R_TIME_SUB);\n\t}\n\n\tvoid setTXPower(byte power[])\n\t{\n\t\t// TODO Check byte length\n\t\t_writeBytesToRegister(TX_POWER, NO_SUB, power, LEN_TX_POWER);\n\t\t_autoTXPower = false;\n\t}\n\n\tvoid setTXPower(int32_t power)\n\t{\n\t\tbyte txpower[LEN_TX_POWER];\n\t\tDW1000NgUtils::writeValueToBytes(txpower, power, LEN_TX_POWER);\n\t\tsetTXPower(txpower);\n\t}\n\n\tvoid setTXPower(DriverAmplifierValue driver_amplifier, TransmitMixerValue mixer)\n\t{\n\t\tbyte txpower[LEN_TX_POWER];\n\t\tbyte pwr = 0x00;\n\n\t\tpwr |= ((byte)driver_amplifier << 5);\n\t\tpwr |= (byte)mixer;\n\n\t\tfor (auto i = 0; i < LEN_TX_POWER; i++)\n\t\t{\n\t\t\ttxpower[i] = pwr;\n\t\t}\n\n\t\tsetTXPower(txpower);\n\t}\n\n\tvoid setTXPowerAuto()\n\t{\n\t\t_autoTXPower = true;\n\t\t_txpowertune();\n\t}\n\n\tvoid setTCPGDelay(byte tcpgdelay)\n\t{\n\t\tbyte tcpgBytes[LEN_TC_PGDELAY];\n\t\tDW1000NgUtils::writeValueToBytes(tcpgBytes, tcpgdelay, LEN_TC_PGDELAY);\n\t\t_writeBytesToRegister(TX_CAL, TC_PGDELAY_SUB, tcpgBytes, LEN_TC_PGDELAY);\n\t\t_autoTCPGDelay = false;\n\t}\n\n\tvoid setTCPGDelayAuto()\n\t{\n\t\t_tcpgdelaytune();\n\t\t_autoTCPGDelay = true;\n\t}\n\n\tvoid enableTransmitPowerSpectrumTestMode(int32_t repeat_interval)\n\t{\n\t\t/* DW1000 clocks must be set to crystal speed so SPI rate have to be lowered and will\n\t\tnot be increased again */\n\t\tSPIporting::setSPIspeed(SPIClock::SLOW);\n\n\t\t_disableSequencing();\n\t\t_configureRFTransmitPowerSpectrumTestMode();\n\t\t_enableClock(SYS_PLL_CLOCK);\n\t\t_enableClock(TX_PLL_CLOCK);\n\n\t\tif (repeat_interval < 4)\n\t\t\trepeat_interval = 4;\n\n\t\t/* In diagnostic transmit power  mode (set next) the bytes 31:0 only are used for DX_TIME register */\n\t\tbyte delayBytes[4];\n\t\tDW1000NgUtils::writeValueToBytes(delayBytes, repeat_interval, 4);\n\t\t_writeBytesToRegister(DX_TIME, NO_SUB, delayBytes, 4);\n\n\t\t/* Enable Transmit Power Spectrum Test Mode */\n\t\tbyte diagnosticBytes[2];\n\t\tDW1000NgUtils::writeValueToBytes(diagnosticBytes, 0x0010, LEN_DIAG_TMC);\n\t\t_writeBytesToRegister(DIG_DIAG, DIAG_TMC_SUB, diagnosticBytes, LEN_DIAG_TMC);\n\t}\n\n\tvoid setDelayedTRX(byte futureTimeBytes[])\n\t{\n\t\t/* the least significant 9-bits are ignored in DX_TIME in functional modes */\n\t\t_writeBytesToRegister(DX_TIME, NO_SUB, futureTimeBytes, LEN_DX_TIME);\n\t}\n\n\tvoid setTransmitData(byte data[], uint16_t n)\n\t{\n\t\tif (_frameCheck)\n\t\t{\n\t\t\tn += 2; // two bytes CRC-16\n\t\t}\n\t\tif (n > LEN_EXT_UWB_FRAMES)\n\t\t{\n\t\t\treturn; // TODO proper error handling: frame/buffer size\n\t\t}\n\t\tif (n > LEN_UWB_FRAMES && !_extendedFrameLength)\n\t\t{\n\t\t\treturn; // TODO proper error handling: frame/buffer size\n\t\t}\n\t\t// transmit data and length\n\t\t_writeBytesToRegister(TX_BUFFER, NO_SUB, data, n);\n\n\t\t/* Sets up transmit frame control length based on data length */\n\t\t_txfctrl[0] = (byte)(n & 0xFF); // 1 byte (regular length + 1 bit)\n\t\t_txfctrl[1] &= 0xE0;\n\t\t_txfctrl[1] |= (byte)((n >> 8) & 0x03); // 2 added bits if extended length\n\t\t_writeTransmitFrameControlRegister();\n\t}\n\n\tvoid setTransmitData(const String &data)\n\t{\n\t\tuint16_t n = data.length() + 1;\n\t\tbyte *dataBytes = (byte *)malloc(n);\n\t\tdata.getBytes(dataBytes, n);\n\t\tsetTransmitData(dataBytes, n);\n\t\tfree(dataBytes);\n\t}\n\n\t// TODO reorder\n\tuint16_t getReceivedDataLength()\n\t{\n\t\tuint16_t len = 0;\n\n\t\t// 10 bits of RX frame control register\n\t\tbyte rxFrameInfo[LEN_RX_FINFO];\n\t\t_readBytes(RX_FINFO, NO_SUB, rxFrameInfo, LEN_RX_FINFO);\n\t\tlen = ((((uint16_t)rxFrameInfo[1] << 8) | (uint16_t)rxFrameInfo[0]) & 0x03FF);\n\n\t\tif (_frameCheck && len > 2)\n\t\t{\n\t\t\treturn len - 2;\n\t\t}\n\t\treturn len;\n\t}\n\n\tvoid getReceivedData(byte data[], uint16_t n)\n\t{\n\t\tif (n <= 0)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\t_readBytes(RX_BUFFER, NO_SUB, data, n);\n\t}\n\n\tvoid getReceivedData(String &data)\n\t{\n\t\tuint16_t i;\n\t\tuint16_t n = getReceivedDataLength(); // number of bytes w/o the two FCS ones\n\t\tif (n <= 0)\n\t\t{ // TODO\n\t\t\treturn;\n\t\t}\n\t\tbyte *dataBytes = (byte *)malloc(n);\n\t\tgetReceivedData(dataBytes, n);\n\t\t// clear string\n\t\tdata.remove(0);\n\t\tdata = \"\";\n\t\t// append to string\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tdata += (char)dataBytes[i];\n\t\t}\n\t\tfree(dataBytes);\n\t}\n\n\tuint64_t getTransmitTimestamp()\n\t{\n\t\tbyte data[LENGTH_TIMESTAMP];\n\t\tmemset(data, 0, LENGTH_TIMESTAMP);\n\t\t_readBytes(TX_TIME, TX_STAMP_SUB, data, LEN_TX_STAMP);\n\t\treturn DW1000NgUtils::bytesAsValue(data, LEN_TX_STAMP);\n\t}\n\n\tuint64_t getReceiveTimestamp()\n\t{\n\t\tbyte data[LEN_RX_STAMP];\n\t\tmemset(data, 0, LEN_RX_STAMP);\n\t\t_readBytes(RX_TIME, RX_STAMP_SUB, data, LEN_RX_STAMP);\n\t\treturn DW1000NgUtils::bytesAsValue(data, LEN_RX_STAMP);\n\t}\n\n\tuint64_t getSystemTimestamp()\n\t{\n\t\tbyte data[LEN_SYS_TIME];\n\t\tmemset(data, 0, LEN_SYS_TIME);\n\t\t_readBytes(SYS_TIME, NO_SUB, data, LEN_SYS_TIME);\n\t\treturn DW1000NgUtils::bytesAsValue(data, LEN_SYS_TIME);\n\t}\n\n\tfloat getReceiveQuality()\n\t{\n\t\tbyte noiseBytes[LEN_STD_NOISE];\n\t\tbyte fpAmpl2Bytes[LEN_FP_AMPL2];\n\t\tuint16_t noise, f2;\n\t\t_readBytes(RX_FQUAL, STD_NOISE_SUB, noiseBytes, LEN_STD_NOISE);\n\t\t_readBytes(RX_FQUAL, FP_AMPL2_SUB, fpAmpl2Bytes, LEN_FP_AMPL2);\n\t\tnoise = (uint16_t)noiseBytes[0] | ((uint16_t)noiseBytes[1] << 8);\n\t\tf2 = (uint16_t)fpAmpl2Bytes[0] | ((uint16_t)fpAmpl2Bytes[1] << 8);\n\t\treturn (float)f2 / noise;\n\t}\n\n\tfloat getFirstPathPower()\n\t{\n\t\tbyte fpAmpl1Bytes[LEN_FP_AMPL1];\n\t\tbyte fpAmpl2Bytes[LEN_FP_AMPL2];\n\t\tbyte fpAmpl3Bytes[LEN_FP_AMPL3];\n\t\tbyte rxFrameInfo[LEN_RX_FINFO];\n\t\tuint16_t f1, f2, f3, N;\n\t\tfloat A, corrFac;\n\t\t_readBytes(RX_TIME, FP_AMPL1_SUB, fpAmpl1Bytes, LEN_FP_AMPL1);\n\t\t_readBytes(RX_FQUAL, FP_AMPL2_SUB, fpAmpl2Bytes, LEN_FP_AMPL2);\n\t\t_readBytes(RX_FQUAL, FP_AMPL3_SUB, fpAmpl3Bytes, LEN_FP_AMPL3);\n\t\t_readBytes(RX_FINFO, NO_SUB, rxFrameInfo, LEN_RX_FINFO);\n\t\tf1 = (uint16_t)fpAmpl1Bytes[0] | ((uint16_t)fpAmpl1Bytes[1] << 8);\n\t\tf2 = (uint16_t)fpAmpl2Bytes[0] | ((uint16_t)fpAmpl2Bytes[1] << 8);\n\t\tf3 = (uint16_t)fpAmpl3Bytes[0] | ((uint16_t)fpAmpl3Bytes[1] << 8);\n\t\tN = (((uint16_t)rxFrameInfo[2] >> 4) & 0xFF) | ((uint16_t)rxFrameInfo[3] << 4);\n\n\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t{\n\t\t\tA = 113.77;\n\t\t\tcorrFac = 2.3334;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tA = 121.74;\n\t\t\tcorrFac = 1.1667;\n\t\t}\n\t\tfloat estFpPwr = 10.0 * log10(((float)f1 * (float)f1 + (float)f2 * (float)f2 + (float)f3 * (float)f3) / ((float)N * (float)N)) - A;\n\t\tif (estFpPwr <= -88)\n\t\t{\n\t\t\treturn estFpPwr;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// approximation of Fig. 22 in user manual for dbm correction\n\t\t\testFpPwr += (estFpPwr + 88) * corrFac;\n\t\t}\n\t\treturn estFpPwr;\n\t}\n\n\tfloat getReceivePower()\n\t{\n\t\tbyte cirPwrBytes[LEN_CIR_PWR];\n\t\tbyte rxFrameInfo[LEN_RX_FINFO];\n\t\tuint32_t twoPower17 = 131072;\n\t\tuint16_t C, N;\n\t\tfloat A, corrFac;\n\t\t_readBytes(RX_FQUAL, CIR_PWR_SUB, cirPwrBytes, LEN_CIR_PWR);\n\t\t_readBytes(RX_FINFO, NO_SUB, rxFrameInfo, LEN_RX_FINFO);\n\t\tC = (uint16_t)cirPwrBytes[0] | ((uint16_t)cirPwrBytes[1] << 8);\n\t\tN = (((uint16_t)rxFrameInfo[2] >> 4) & 0xFF) | ((uint16_t)rxFrameInfo[3] << 4);\n\n\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t{\n\t\t\tA = 113.77;\n\t\t\tcorrFac = 2.3334;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tA = 121.74;\n\t\t\tcorrFac = 1.1667;\n\t\t}\n\n\t\tfloat estRxPwr = 10.0 * log10(((float)C * (float)twoPower17) / ((float)N * (float)N)) - A;\n\t\tif (estRxPwr <= -88)\n\t\t{\n\t\t\treturn estRxPwr;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// approximation of Fig. 22 in user manual for dbm correction\n\t\t\testRxPwr += (estRxPwr + 88) * corrFac;\n\t\t}\n\t\treturn estRxPwr;\n\t}\n\n#if DW1000NG_DEBUG\n\tvoid getPrettyBytes(byte data[], char msgBuffer[], uint16_t n)\n\t{\n\t\tuint16_t i, j, b;\n\t\tb = sprintf(msgBuffer, \"Data, bytes: %d\\nB: 7 6 5 4 3 2 1 0\\n\", n); // TODO - type\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tbyte curByte = data[i];\n\t\t\tsnprintf(&msgBuffer[b++], 2, \"%d\", (i + 1));\n\t\t\tmsgBuffer[b++] = (char)((i + 1) & 0xFF);\n\t\t\tmsgBuffer[b++] = ':';\n\t\t\tmsgBuffer[b++] = ' ';\n\t\t\tfor (j = 0; j < 8; j++)\n\t\t\t{\n\t\t\t\tmsgBuffer[b++] = ((curByte >> (7 - j)) & 0x01) ? '1' : '0';\n\t\t\t\tif (j < 7)\n\t\t\t\t{\n\t\t\t\t\tmsgBuffer[b++] = ' ';\n\t\t\t\t}\n\t\t\t\telse if (i < n - 1)\n\t\t\t\t{\n\t\t\t\t\tmsgBuffer[b++] = '\\n';\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmsgBuffer[b++] = '\\0';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmsgBuffer[b++] = '\\0';\n\t}\n\n\tvoid getPrettyBytes(byte cmd, uint16_t offset, char msgBuffer[], uint16_t n)\n\t{\n\t\tuint16_t i, j, b;\n\t\tbyte *readBuf = (byte *)malloc(n);\n\t\t_readBytes(cmd, offset, readBuf, n);\n\t\tb = sprintf(msgBuffer, \"Reg: 0x%02x, bytes: %d\\nB: 7 6 5 4 3 2 1 0\\n\", cmd, n); // TODO - tpye\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tbyte curByte = readBuf[i];\n\t\t\tsnprintf(&msgBuffer[b++], 2, \"%d\", (i + 1));\n\t\t\tmsgBuffer[b++] = (char)((i + 1) & 0xFF);\n\t\t\tmsgBuffer[b++] = ':';\n\t\t\tmsgBuffer[b++] = ' ';\n\t\t\tfor (j = 0; j < 8; j++)\n\t\t\t{\n\t\t\t\tmsgBuffer[b++] = ((curByte >> (7 - j)) & 0x01) ? '1' : '0';\n\t\t\t\tif (j < 7)\n\t\t\t\t{\n\t\t\t\t\tmsgBuffer[b++] = ' ';\n\t\t\t\t}\n\t\t\t\telse if (i < n - 1)\n\t\t\t\t{\n\t\t\t\t\tmsgBuffer[b++] = '\\n';\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmsgBuffer[b++] = '\\0';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmsgBuffer[b++] = '\\0';\n\t\tfree(readBuf);\n\t}\n#endif\n}"}}}Content-Length: 175

{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"}}}
>>>
Content-Length: 183

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///c:/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","diagnostics":[]},"jsonrpc":"2.0"}
<<<
Content-Length: 233

{"jsonrpc":"2.0","id":113,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":54,"character":40}}}
>>>
Content-Length: 38

{"id":113,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 233

{"jsonrpc":"2.0","id":114,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":54,"character":37}}}
>>>
Content-Length: 38

{"id":114,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 233

{"jsonrpc":"2.0","id":115,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":53,"character":33}}}
>>>
Content-Length: 215

{"id":115,"result":[{"uri":"file:///C:/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","range":{"start":{"line":1643,"character":6},"end":{"line":1643,"character":27}}}],"jsonrpc":"2.0"}
<<<
Content-Length: 82613

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","languageId":"cpp","version":1,"text":"/*\n * MIT License\n *\n * Copyright (c) 2018 Michele Biondi, Andrea Salvatori\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n/*\n * Copyright (c) 2015 by Thomas Trojer <thomas@trojer.net>\n * Decawave DW1000Ng library for arduino.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @file DW1000Ng.cpp\n * Arduino driver library (source file) for the Decawave DW1000Ng UWB transceiver Module.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"DW1000Ng.hpp\"\n#include \"DW1000NgUtils.hpp\"\n#include \"DW1000NgConstants.hpp\"\n#include \"DW1000NgRegisters.hpp\"\n#include \"SPIporting.hpp\"\n\nnamespace DW1000Ng\n{\n\n\t/* anonymous namespace to host private-like variables and methods */\n\tnamespace\n\t{\n\n\t\t/* ########################### PRIVATE VARIABLES ################################# */\n\n\t\t/* SPI select pin and interrupt pin*/\n\t\tuint8_t _ss = 0xff;\n\t\tuint8_t _irq = 0xff;\n\t\tuint8_t _rst = 0xff;\n\n\t\t/* IRQ callbacks */\n\t\tvoid (*_handleSent)(void) = nullptr;\n\t\tvoid (*_handleError)(void) = nullptr;\n\t\tvoid (*_handleReceived)(void) = nullptr;\n\t\tvoid (*_handleReceiveFailed)(void) = nullptr;\n\t\tvoid (*_handleReceiveTimeout)(void) = nullptr;\n\t\tvoid (*_handleReceiveTimestampAvailable)(void) = nullptr;\n\n\t\t/* registers */\n\t\tbyte _syscfg[LEN_SYS_CFG];\n\t\tbyte _sysctrl[LEN_SYS_CTRL];\n\t\tbyte _sysstatus[LEN_SYS_STATUS];\n\t\tbyte _txfctrl[LEN_TX_FCTRL];\n\t\tbyte _sysmask[LEN_SYS_MASK];\n\t\tbyte _chanctrl[LEN_CHAN_CTRL];\n\t\tbyte _networkAndAddress[LEN_PANADR];\n\n\t\t/* Temperature and Voltage monitoring */\n\t\tbyte _vmeas3v3 = 0;\n\t\tbyte _tmeas23C = 0;\n\n\t\t/* Driver Internal State Trackers */\n\t\tbyte _extendedFrameLength;\n\t\tPacSize _pacSize;\n\t\tPulseFrequency _pulseFrequency;\n\t\tDataRate _dataRate;\n\t\tPreambleLength _preambleLength;\n\t\tPreambleCode _preambleCode;\n\t\tChannel _channel;\n\t\tboolean _smartPower;\n\t\tboolean _frameCheck;\n\t\tboolean _debounceClockEnabled = false;\n\t\tboolean _nlos = false;\n\t\tboolean _standardSFD = true;\n\t\tboolean _autoTXPower = true;\n\t\tboolean _autoTCPGDelay = true;\n\t\tboolean _wait4resp = false;\n\t\tuint16_t _antennaTxDelay = 0;\n\t\tuint16_t _antennaRxDelay = 0;\n\n\t\t/* ############################# PRIVATE METHODS ################################### */\n\t\t/*\n\t\t * Write bytes to the DW1000Ng. Single bytes can be written to registers via sub-addressing.\n\t\t * @param cmd\n\t\t * \t\tThe register address (see Chapter 7 in the DW1000Ng user manual).\n\t\t * @param offset\n\t\t *\t\tThe offset to select register sub-parts for writing, or 0x00 to disable\n\t\t * \t\tsub-adressing.\n\t\t * @param data\n\t\t *\t\tThe data array to be written.\n\t\t * @param data_size\n\t\t *\t\tThe number of bytes to be written (take care not to go out of bounds of\n\t\t * \t\tthe register).\n\t\t */\n\t\t// TODO offset really bigger than byte?\n\n\t\tvoid _writeBytesToRegister(byte cmd, uint16_t offset, byte data[], uint16_t data_size)\n\t\t{\n\t\t\tbyte header[3];\n\t\t\tuint8_t headerLen = 1;\n\n\t\t\t// TODO proper error handling: address out of bounds\n\t\t\t// build SPI header\n\t\t\tif (offset == NO_SUB)\n\t\t\t{\n\t\t\t\theader[0] = WRITE | cmd;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\theader[0] = WRITE_SUB | cmd;\n\t\t\t\tif (offset < 128)\n\t\t\t\t{\n\t\t\t\t\theader[1] = (byte)offset;\n\t\t\t\t\theaderLen++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\theader[1] = RW_SUB_EXT | (byte)offset;\n\t\t\t\t\theader[2] = (byte)(offset >> 7);\n\t\t\t\t\theaderLen += 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSPIporting::writeToSPI(_ss, headerLen, header, data_size, data);\n\t\t}\n\n\t\tvoid _writeToRegister(byte cmd, uint16_t offset, uint32_t data, uint16_t data_size)\n\t\t{\n\t\t\tbyte dataBytes[data_size];\n\t\t\tDW1000NgUtils::writeValueToBytes(dataBytes, data, data_size);\n\t\t\t_writeBytesToRegister(cmd, offset, dataBytes, data_size);\n\t\t}\n\n\t\t// Helper to set a single register\n\t\tvoid _writeByte(byte cmd, uint16_t offset, byte data)\n\t\t{\n\t\t\t_writeBytesToRegister(cmd, offset, &data, 1);\n\t\t}\n\n\t\t/*\n\t\t * Read bytes from the DW1000Ng. Number of bytes depend on register length.\n\t\t * @param cmd\n\t\t * \t\tThe register address (see Chapter 7 in the DW1000Ng user manual).\n\t\t * @param data\n\t\t *\t\tThe data array to be read into.\n\t\t * @param n\n\t\t *\t\tThe number of bytes expected to be received.\n\t\t */\n\t\t// TODO incomplete doc\n\t\tvoid _readBytes(byte cmd, uint16_t offset, byte data[], uint16_t data_size)\n\t\t{\n\t\t\tbyte header[3];\n\t\t\tuint8_t headerLen = 1;\n\n\t\t\t// build SPI header\n\t\t\tif (offset == NO_SUB)\n\t\t\t{\n\t\t\t\theader[0] = READ | cmd;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\theader[0] = READ_SUB | cmd;\n\t\t\t\tif (offset < 128)\n\t\t\t\t{\n\t\t\t\t\theader[1] = (byte)offset;\n\t\t\t\t\theaderLen++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\theader[1] = RW_SUB_EXT | (byte)offset;\n\t\t\t\t\theader[2] = (byte)(offset >> 7);\n\t\t\t\t\theaderLen += 2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSPIporting::readFromSPI(_ss, headerLen, header, data_size, data);\n\t\t}\n\n\t\t// always 4 bytes\n\t\t// TODO why always 4 bytes? can be different, see p. 58 table 10 otp memory map\n\t\tvoid _readBytesOTP(uint16_t address, byte data[])\n\t\t{\n\t\t\tbyte addressBytes[LEN_OTP_ADDR];\n\n\t\t\t// p60 - 6.3.3 Reading a value from OTP memory\n\t\t\t// bytes of address\n\t\t\taddressBytes[0] = (address & 0xFF);\n\t\t\taddressBytes[1] = ((address >> 8) & 0xFF);\n\t\t\t// set address\n\t\t\t_writeBytesToRegister(OTP_IF, OTP_ADDR_SUB, addressBytes, LEN_OTP_ADDR);\n\t\t\t// switch into read mode\n\t\t\t_writeByte(OTP_IF, OTP_CTRL_SUB, 0x03); // OTPRDEN | OTPREAD\n\t\t\t_writeByte(OTP_IF, OTP_CTRL_SUB, 0x01); // OTPRDEN\n\t\t\t// read value/block - 4 bytes\n\t\t\t_readBytes(OTP_IF, OTP_RDAT_SUB, data, LEN_OTP_RDAT);\n\t\t\t// end read mode\n\t\t\t_writeByte(OTP_IF, OTP_CTRL_SUB, 0x00);\n\t\t}\n\n\t\tvoid _writeBitToRegister(byte bitRegister, uint16_t RegisterOffset, uint16_t bitRegister_LEN, uint16_t selectedBit, boolean value)\n\t\t{\n\t\t\tuint16_t idx;\n\t\t\tuint8_t bitPosition;\n\n\t\t\tidx = selectedBit / 8;\n\t\t\tif (idx >= bitRegister_LEN)\n\t\t\t{\n\t\t\t\treturn; // TODO proper error handling: out of bounds\n\t\t\t}\n\t\t\tbyte targetByte;\n\t\t\tmemset(&targetByte, 0, 1);\n\t\t\tbitPosition = selectedBit % 8;\n\t\t\t_readBytes(bitRegister, RegisterOffset + idx, &targetByte, 1);\n\n\t\t\tvalue ? bitSet(targetByte, bitPosition) : bitClear(targetByte, bitPosition);\n\n\t\t\tif (RegisterOffset == NO_SUB)\n\t\t\t\tRegisterOffset = 0x00;\n\n\t\t\t_writeBytesToRegister(bitRegister, RegisterOffset + idx, &targetByte, 1);\n\t\t}\n\n\t\tvoid _enableClock(byte clock)\n\t\t{\n\t\t\tbyte pmscctrl0[LEN_PMSC_CTRL0];\n\t\t\tmemset(pmscctrl0, 0, LEN_PMSC_CTRL0);\n\t\t\t_readBytes(PMSC, PMSC_CTRL0_SUB, pmscctrl0, LEN_PMSC_CTRL0);\n\t\t\tif (clock == SYS_AUTO_CLOCK)\n\t\t\t{\n\t\t\t\tpmscctrl0[0] = SYS_AUTO_CLOCK;\n\t\t\t\tpmscctrl0[1] &= 0xFE;\n\t\t\t}\n\t\t\telse if (clock == SYS_XTI_CLOCK)\n\t\t\t{\n\t\t\t\tpmscctrl0[0] &= 0xFC;\n\t\t\t\tpmscctrl0[0] |= SYS_XTI_CLOCK;\n\t\t\t}\n\t\t\telse if (clock == SYS_PLL_CLOCK)\n\t\t\t{\n\t\t\t\tpmscctrl0[0] &= 0xFC;\n\t\t\t\tpmscctrl0[0] |= SYS_PLL_CLOCK;\n\t\t\t}\n\t\t\telse if (clock == TX_PLL_CLOCK)\n\t\t\t{\n\t\t\t\tpmscctrl0[0] &= 0xCF;\n\t\t\t\tpmscctrl0[0] |= TX_PLL_CLOCK;\n\t\t\t}\n\t\t\telse if (clock == LDE_CLOCK)\n\t\t\t{\n\t\t\t\tpmscctrl0[0] = SYS_XTI_CLOCK;\n\t\t\t\tpmscctrl0[1] = 0x03;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO deliver proper warning\n\t\t\t}\n\t\t\t_writeBytesToRegister(PMSC, PMSC_CTRL0_SUB, pmscctrl0, 2);\n\t\t}\n\n\t\t/* Steps used to get Temp and Voltage */\n\t\tvoid _vbatAndTempSteps()\n\t\t{\n\t\t\tbyte step1 = 0x80;\n\t\t\t_writeBytesToRegister(RF_CONF, 0x11, &step1, 1);\n\t\t\tbyte step2 = 0x0A;\n\t\t\t_writeBytesToRegister(RF_CONF, 0x12, &step2, 1);\n\t\t\tbyte step3 = 0x0F;\n\t\t\t_writeBytesToRegister(RF_CONF, 0x12, &step3, 1);\n\t\t\tbyte step4 = 0x01;\n\t\t\t_writeBytesToRegister(TX_CAL, NO_SUB, &step4, 1);\n\t\t\tbyte step5 = 0x00;\n\t\t\t_writeBytesToRegister(TX_CAL, NO_SUB, &step5, 1);\n\t\t}\n\n\t\t/* AGC_TUNE1 - reg:0x23, sub-reg:0x04, table 24 */\n\t\tvoid _agctune1()\n\t\t{\n\t\t\tbyte agctune1[LEN_AGC_TUNE1];\n\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(agctune1, 0x8870, LEN_AGC_TUNE1);\n\t\t\t}\n\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(agctune1, 0x889B, LEN_AGC_TUNE1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(AGC_TUNE, AGC_TUNE1_SUB, agctune1, LEN_AGC_TUNE1);\n\t\t}\n\n\t\t/* AGC_TUNE2 - reg:0x23, sub-reg:0x0C, table 25 */\n\t\tvoid _agctune2()\n\t\t{\n\t\t\tbyte agctune2[LEN_AGC_TUNE2];\n\t\t\tDW1000NgUtils::writeValueToBytes(agctune2, 0x2502A907L, LEN_AGC_TUNE2);\n\t\t\t_writeBytesToRegister(AGC_TUNE, AGC_TUNE2_SUB, agctune2, LEN_AGC_TUNE2);\n\t\t}\n\n\t\t/* AGC_TUNE3 - reg:0x23, sub-reg:0x12, table 26 */\n\t\tvoid _agctune3()\n\t\t{\n\t\t\tbyte agctune3[LEN_AGC_TUNE3];\n\t\t\tDW1000NgUtils::writeValueToBytes(agctune3, 0x0035, LEN_AGC_TUNE3);\n\t\t\t_writeBytesToRegister(AGC_TUNE, AGC_TUNE3_SUB, agctune3, LEN_AGC_TUNE3);\n\t\t}\n\n\t\t/* DRX_TUNE0b - reg:0x27, sub-reg:0x02, table 30 */\n\t\tvoid _drxtune0b()\n\t\t{\n\t\t\tbyte drxtune0b[LEN_DRX_TUNE0b];\n\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t{\n\t\t\t\tif (!_standardSFD)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune0b, 0x0016, LEN_DRX_TUNE0b);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune0b, 0x000A, LEN_DRX_TUNE0b);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_dataRate == DataRate::RATE_850KBPS)\n\t\t\t{\n\t\t\t\tif (!_standardSFD)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune0b, 0x0006, LEN_DRX_TUNE0b);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune0b, 0x0001, LEN_DRX_TUNE0b);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_dataRate == DataRate::RATE_6800KBPS)\n\t\t\t{\n\t\t\t\tif (!_standardSFD)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune0b, 0x0002, LEN_DRX_TUNE0b);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune0b, 0x0001, LEN_DRX_TUNE0b);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(DRX_TUNE, DRX_TUNE0b_SUB, drxtune0b, LEN_DRX_TUNE0b);\n\t\t}\n\n\t\t/* DRX_TUNE1a - reg:0x27, sub-reg:0x04, table 31 */\n\t\tvoid _drxtune1a()\n\t\t{\n\t\t\tbyte drxtune1a[LEN_DRX_TUNE1a];\n\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune1a, 0x0087, LEN_DRX_TUNE1a);\n\t\t\t}\n\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune1a, 0x008D, LEN_DRX_TUNE1a);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(DRX_TUNE, DRX_TUNE1a_SUB, drxtune1a, LEN_DRX_TUNE1a);\n\t\t}\n\n\t\t/* DRX_TUNE1b - reg:0x27, sub-reg:0x06, table 32 */\n\t\tvoid _drxtune1b()\n\t\t{\n\t\t\tbyte drxtune1b[LEN_DRX_TUNE1b];\n\t\t\tif (_preambleLength == PreambleLength::LEN_1536 || _preambleLength == PreambleLength::LEN_2048 ||\n\t\t\t\t_preambleLength == PreambleLength::LEN_4096)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune1b, 0x0064, LEN_DRX_TUNE1b);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleLength != PreambleLength::LEN_64)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_850KBPS || _dataRate == DataRate::RATE_6800KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune1b, 0x0020, LEN_DRX_TUNE1b);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_6800KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune1b, 0x0010, LEN_DRX_TUNE1b);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\t_writeBytesToRegister(DRX_TUNE, DRX_TUNE1b_SUB, drxtune1b, LEN_DRX_TUNE1b);\n\t\t}\n\n\t\t/* DRX_TUNE2 - reg:0x27, sub-reg:0x08, table 33 */\n\t\tvoid _drxtune2()\n\t\t{\n\t\t\tbyte drxtune2[LEN_DRX_TUNE2];\n\t\t\tif (_pacSize == PacSize::SIZE_8)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune2, 0x311A002DL, LEN_DRX_TUNE2);\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune2, 0x313B006BL, LEN_DRX_TUNE2);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_pacSize == PacSize::SIZE_16)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune2, 0x331A0052L, LEN_DRX_TUNE2);\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune2, 0x333B00BEL, LEN_DRX_TUNE2);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_pacSize == PacSize::SIZE_32)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune2, 0x351A009AL, LEN_DRX_TUNE2);\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune2, 0x353B015EL, LEN_DRX_TUNE2);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_pacSize == PacSize::SIZE_64)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune2, 0x371A011DL, LEN_DRX_TUNE2);\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune2, 0x373B0296L, LEN_DRX_TUNE2);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(DRX_TUNE, DRX_TUNE2_SUB, drxtune2, LEN_DRX_TUNE2);\n\t\t}\n\n\t\t/* DRX_TUNE4H - reg:0x27, sub-reg:0x26, table 34 */\n\t\tvoid _drxtune4H()\n\t\t{\n\t\t\tbyte drxtune4H[LEN_DRX_TUNE4H];\n\t\t\tif (_preambleLength == PreambleLength::LEN_64)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune4H, 0x0010, LEN_DRX_TUNE4H);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune4H, 0x0028, LEN_DRX_TUNE4H);\n\t\t\t}\n\t\t\t_writeBytesToRegister(DRX_TUNE, DRX_TUNE4H_SUB, drxtune4H, LEN_DRX_TUNE4H);\n\t\t}\n\n\t\t/* LDE_CFG1 - reg 0x2E, sub-reg:0x0806 */\n\t\tvoid _ldecfg1()\n\t\t{\n\t\t\tbyte ldecfg1[LEN_LDE_CFG1];\n\t\t\t_nlos == true ? DW1000NgUtils::writeValueToBytes(ldecfg1, 0x7, LEN_LDE_CFG1) : DW1000NgUtils::writeValueToBytes(ldecfg1, 0xD, LEN_LDE_CFG1);\n\t\t\t_writeBytesToRegister(LDE_IF, LDE_CFG1_SUB, ldecfg1, LEN_LDE_CFG1);\n\t\t}\n\n\t\t/* LDE_CFG2 - reg 0x2E, sub-reg:0x1806, table 50 */\n\t\tvoid _ldecfg2()\n\t\t{\n\t\t\tbyte ldecfg2[LEN_LDE_CFG2];\n\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t{\n\t\t\t\t_nlos == true ? DW1000NgUtils::writeValueToBytes(ldecfg2, 0x0003, LEN_LDE_CFG2) : DW1000NgUtils::writeValueToBytes(ldecfg2, 0x1607, LEN_LDE_CFG2);\n\t\t\t}\n\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(ldecfg2, 0x0607, LEN_LDE_CFG2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(LDE_IF, LDE_CFG2_SUB, ldecfg2, LEN_LDE_CFG2);\n\t\t}\n\n\t\t/* LDE_REPC - reg 0x2E, sub-reg:0x2804, table 51 */\n\t\tvoid _lderepc()\n\t\t{\n\t\t\tbyte lderepc[LEN_LDE_REPC];\n\t\t\tif (_preambleCode == PreambleCode::CODE_1 || _preambleCode == PreambleCode::CODE_2)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x5998 >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x5998, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_3 || _preambleCode == PreambleCode::CODE_8)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x51EA >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x51EA, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_4)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x428E >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x428E, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_5)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x451E >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x451E, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_6)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x2E14 >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x2E14, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_7)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x8000 >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x8000, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_9)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x28F4 >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x28F4, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_10 || _preambleCode == PreambleCode::CODE_17)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x3332 >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x3332, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_11)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x3AE0 >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x3AE0, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_12)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x3D70 >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x3D70, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_18 || _preambleCode == PreambleCode::CODE_19)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x35C2 >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x35C2, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_20)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x47AE >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x47AE, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\n\t\t\t_writeBytesToRegister(LDE_IF, LDE_REPC_SUB, lderepc, LEN_LDE_REPC);\n\t\t}\n\n\t\t/* TX_POWER (enabled smart transmit power control) - reg:0x1E, tables 19-20\n\t\t * These values are based on a typical IC and an assumed IC to antenna loss of 1.5 dB with a 0 dBi antenna */\n\t\tvoid _txpowertune()\n\t\t{\n\t\t\tbyte txpower[LEN_TX_POWER];\n\t\t\tif (_channel == Channel::CHANNEL_1 || _channel == Channel::CHANNEL_2)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x1B153555L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x15355575L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x55555555L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x75757575L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x0D072747L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x07274767L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x47474747L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x67676767L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_3)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x150F2F4FL, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x0F2F4F6FL, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x4F4F4F4FL, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x6F6F6F6FL, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x0B2B4B6BL, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x2B4B6B8BL, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x6B6B6B6BL, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x8B8B8B8BL, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_4)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x1F1F1F3FL, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x1F1F3F5FL, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x3F3F3F3FL, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x5F5F5F5FL, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x1A3A5A7AL, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x3A5A7A9AL, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x7A7A7A7AL, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x9A9A9A9AL, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_5)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x140E0828L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x0E082848L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x28282828L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x48484848L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x05254565L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x25456585L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x65656565L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x85858585L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_7)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x12325272L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x32527292L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x72727272L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x92929292L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x315191B1L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x5171B1D1L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0xB1B1B1B1L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0xD1D1D1D1L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(TX_POWER, NO_SUB, txpower, LEN_TX_POWER);\n\t\t}\n\n\t\t/* RF_RXCTRLH - reg:0x28, sub-reg:0x0B, table 37 */\n\t\tvoid _rfrxctrlh()\n\t\t{\n\t\t\tbyte rfrxctrlh[LEN_RF_RXCTRLH];\n\t\t\tif (_channel != Channel::CHANNEL_4 && _channel != Channel::CHANNEL_7)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(rfrxctrlh, 0xD8, LEN_RF_RXCTRLH);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(rfrxctrlh, 0xBC, LEN_RF_RXCTRLH);\n\t\t\t}\n\t\t\t_writeBytesToRegister(RF_CONF, RF_RXCTRLH_SUB, rfrxctrlh, LEN_RF_RXCTRLH);\n\t\t}\n\n\t\t/* RX_TXCTRL - reg:0x28, sub-reg:0x0C */\n\t\tvoid _rftxctrl()\n\t\t{\n\t\t\tbyte rftxctrl[LEN_RF_TXCTRL];\n\t\t\tif (_channel == Channel::CHANNEL_1)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(rftxctrl, 0x00005C40L, LEN_RF_TXCTRL);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_2)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(rftxctrl, 0x00045CA0L, LEN_RF_TXCTRL);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_3)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(rftxctrl, 0x00086CC0L, LEN_RF_TXCTRL);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_4)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(rftxctrl, 0x00045C80L, LEN_RF_TXCTRL);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_5)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(rftxctrl, 0x001E3FE0L, LEN_RF_TXCTRL);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_7)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(rftxctrl, 0x001E7DE0L, LEN_RF_TXCTRL);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(RF_CONF, RF_TXCTRL_SUB, rftxctrl, LEN_RF_TXCTRL);\n\t\t}\n\n\t\t/* TC_PGDELAY - reg:0x2A, sub-reg:0x0B, table 40 */\n\t\tvoid _tcpgdelaytune()\n\t\t{\n\t\t\tbyte tcpgdelay[LEN_TC_PGDELAY];\n\t\t\tif (_channel == Channel::CHANNEL_1)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(tcpgdelay, 0xC9, LEN_TC_PGDELAY);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_2)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(tcpgdelay, 0xC2, LEN_TC_PGDELAY);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_3)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(tcpgdelay, 0xC5, LEN_TC_PGDELAY);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_4)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(tcpgdelay, 0x95, LEN_TC_PGDELAY);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_5)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(tcpgdelay, 0xC0, LEN_TC_PGDELAY);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_7)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(tcpgdelay, 0x93, LEN_TC_PGDELAY);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(TX_CAL, TC_PGDELAY_SUB, tcpgdelay, LEN_TC_PGDELAY);\n\t\t}\n\n\t\t// FS_PLLCFG and FS_PLLTUNE - reg:0x2B, sub-reg:0x07-0x0B, tables 43-44\n\t\tvoid _fspll()\n\t\t{\n\t\t\tbyte fspllcfg[LEN_FS_PLLCFG];\n\t\t\tbyte fsplltune[LEN_FS_PLLTUNE];\n\t\t\tif (_channel == Channel::CHANNEL_1)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fspllcfg, 0x09000407L, LEN_FS_PLLCFG);\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fsplltune, 0x1E, LEN_FS_PLLTUNE);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_2 || _channel == Channel::CHANNEL_4)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fspllcfg, 0x08400508L, LEN_FS_PLLCFG);\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fsplltune, 0x26, LEN_FS_PLLTUNE);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_3)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fspllcfg, 0x08401009L, LEN_FS_PLLCFG);\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fsplltune, 0x56, LEN_FS_PLLTUNE);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_5 || _channel == Channel::CHANNEL_7)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fspllcfg, 0x0800041DL, LEN_FS_PLLCFG);\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fsplltune, 0xBE, LEN_FS_PLLTUNE);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(FS_CTRL, FS_PLLTUNE_SUB, fsplltune, LEN_FS_PLLTUNE);\n\t\t\t_writeBytesToRegister(FS_CTRL, FS_PLLCFG_SUB, fspllcfg, LEN_FS_PLLCFG);\n\t\t}\n\n\t\tvoid _tune()\n\t\t{\n\t\t\t// these registers are going to be tuned/configured\n\t\t\t_agctune1();\n\t\t\t_agctune2();\n\t\t\t_agctune3();\n\t\t\t_drxtune0b();\n\t\t\t_drxtune1a();\n\t\t\t_drxtune1b();\n\t\t\t_drxtune2();\n\t\t\t_drxtune4H();\n\t\t\t_ldecfg1();\n\t\t\t_ldecfg2();\n\t\t\t_lderepc();\n\t\t\tif (_autoTXPower)\n\t\t\t\t_txpowertune();\n\t\t\t_rfrxctrlh();\n\t\t\t_rftxctrl();\n\t\t\tif (_autoTCPGDelay)\n\t\t\t\t_tcpgdelaytune();\n\t\t\t_fspll();\n\t\t}\n\n\t\tvoid _writeNetworkIdAndDeviceAddress()\n\t\t{\n\t\t\t_writeBytesToRegister(PANADR, NO_SUB, _networkAndAddress, LEN_PANADR);\n\t\t}\n\n\t\tvoid _writeSystemConfigurationRegister()\n\t\t{\n\t\t\t_writeBytesToRegister(SYS_CFG, NO_SUB, _syscfg, LEN_SYS_CFG);\n\t\t}\n\n\t\tvoid _writeChannelControlRegister()\n\t\t{\n\t\t\t_writeBytesToRegister(CHAN_CTRL, NO_SUB, _chanctrl, LEN_CHAN_CTRL);\n\t\t}\n\n\t\tvoid _writeTransmitFrameControlRegister()\n\t\t{\n\t\t\t_writeBytesToRegister(TX_FCTRL, NO_SUB, _txfctrl, LEN_TX_FCTRL);\n\t\t}\n\n\t\tvoid _writeSystemEventMaskRegister()\n\t\t{\n\t\t\t_writeBytesToRegister(SYS_MASK, NO_SUB, _sysmask, LEN_SYS_MASK);\n\t\t}\n\n\t\tvoid _writeAntennaDelayRegisters()\n\t\t{\n\t\t\tbyte antennaTxDelayBytes[2];\n\t\t\tbyte antennaRxDelayBytes[2];\n\t\t\tDW1000NgUtils::writeValueToBytes(antennaTxDelayBytes, _antennaTxDelay, LEN_TX_ANTD);\n\t\t\tDW1000NgUtils::writeValueToBytes(antennaRxDelayBytes, _antennaRxDelay, LEN_LDE_RXANTD);\n\t\t\t_writeBytesToRegister(TX_ANTD, NO_SUB, antennaTxDelayBytes, LEN_TX_ANTD);\n\t\t\t_writeBytesToRegister(LDE_IF, LDE_RXANTD_SUB, antennaRxDelayBytes, LEN_LDE_RXANTD);\n\t\t}\n\n\t\tvoid _writeConfiguration()\n\t\t{\n\t\t\t// write all configurations back to device\n\t\t\t_writeSystemConfigurationRegister();\n\t\t\t_writeChannelControlRegister();\n\t\t\t_writeTransmitFrameControlRegister();\n\t\t}\n\n\t\tvoid _useExtendedFrameLength(boolean val)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, PHR_MODE_0_BIT, val);\n\t\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, PHR_MODE_1_BIT, val);\n\t\t}\n\n\t\tvoid _setReceiverAutoReenable(boolean val)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, RXAUTR_BIT, val);\n\t\t}\n\n\t\tvoid _useFrameCheck(boolean val)\n\t\t{\n\t\t\t_frameCheck = val;\n\t\t}\n\n\t\tvoid _setNlosOptimization(boolean val)\n\t\t{\n\t\t\t_nlos = val;\n\t\t\tif (_nlos)\n\t\t\t{\n\t\t\t\t_ldecfg1();\n\t\t\t\t_ldecfg2();\n\t\t\t}\n\t\t}\n\n\t\tvoid _useSmartPower(boolean smartPower)\n\t\t{\n\t\t\t_smartPower = smartPower;\n\t\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, DIS_STXP_BIT, !smartPower);\n\t\t\t_writeSystemConfigurationRegister();\n\t\t\tif (_autoTXPower)\n\t\t\t\t_txpowertune();\n\t\t}\n\n\t\tvoid _setSFDMode(SFDMode mode)\n\t\t{\n\t\t\tswitch (mode)\n\t\t\t{\n\t\t\tcase SFDMode::STANDARD_SFD:\n\t\t\t\tDW1000NgUtils::setBit(_chanctrl, LEN_CHAN_CTRL, DWSFD_BIT, false);\n\t\t\t\tDW1000NgUtils::setBit(_chanctrl, LEN_CHAN_CTRL, TNSSFD_BIT, false);\n\t\t\t\tDW1000NgUtils::setBit(_chanctrl, LEN_CHAN_CTRL, RNSSFD_BIT, false);\n\t\t\t\t_standardSFD = true;\n\t\t\t\tbreak;\n\t\t\tcase SFDMode::DECAWAVE_SFD:\n\t\t\t\tDW1000NgUtils::setBit(_chanctrl, LEN_CHAN_CTRL, DWSFD_BIT, true);\n\t\t\t\tDW1000NgUtils::setBit(_chanctrl, LEN_CHAN_CTRL, TNSSFD_BIT, true);\n\t\t\t\tDW1000NgUtils::setBit(_chanctrl, LEN_CHAN_CTRL, RNSSFD_BIT, true);\n\t\t\t\t_standardSFD = false;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn; // TODO Proper error handling\n\t\t\t}\n\t\t}\n\n\t\tvoid _setChannel(Channel channel)\n\t\t{\n\t\t\tbyte chan = static_cast<byte>(channel);\n\t\t\tchan &= 0xF;\n\t\t\t_chanctrl[0] = ((chan | (chan << 4)) & 0xFF);\n\n\t\t\t_channel = channel;\n\t\t}\n\n\t\tvoid _setDataRate(DataRate data_rate)\n\t\t{\n\t\t\tbyte rate = static_cast<byte>(data_rate);\n\t\t\trate &= 0x03;\n\t\t\t_txfctrl[1] &= 0x83;\n\t\t\t_txfctrl[1] |= (byte)((rate << 5) & 0xFF);\n\t\t\t// special 110kbps flag\n\t\t\tif (data_rate == DataRate::RATE_110KBPS)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, RXM110K_BIT, true);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, RXM110K_BIT, false);\n\t\t\t}\n\t\t\t_dataRate = data_rate;\n\t\t}\n\n\t\tvoid _setPulseFrequency(PulseFrequency frequency)\n\t\t{\n\t\t\tbyte freq = static_cast<byte>(frequency);\n\t\t\tfreq &= 0x03;\n\t\t\t_txfctrl[2] &= 0xFC;\n\t\t\t_txfctrl[2] |= (byte)(freq & 0xFF);\n\t\t\t_chanctrl[2] &= 0xF3;\n\t\t\t_chanctrl[2] |= (byte)((freq << 2) & 0xFF);\n\n\t\t\t_pulseFrequency = frequency;\n\t\t}\n\n\t\tvoid _setPreambleLength(PreambleLength preamble_length)\n\t\t{\n\t\t\tbyte prealen = static_cast<byte>(preamble_length);\n\t\t\tprealen &= 0x0F;\n\t\t\t_txfctrl[2] &= 0xC3;\n\t\t\t_txfctrl[2] |= (byte)((prealen << 2) & 0xFF);\n\n\t\t\tswitch (preamble_length)\n\t\t\t{\n\t\t\tcase PreambleLength::LEN_64:\n\t\t\t\t_pacSize = PacSize::SIZE_8;\n\t\t\t\tbreak;\n\t\t\tcase PreambleLength::LEN_128:\n\t\t\t\t_pacSize = PacSize::SIZE_8;\n\t\t\t\tbreak;\n\t\t\tcase PreambleLength::LEN_256:\n\t\t\t\t_pacSize = PacSize::SIZE_16;\n\t\t\t\tbreak;\n\t\t\tcase PreambleLength::LEN_512:\n\t\t\t\t_pacSize = PacSize::SIZE_16;\n\t\t\t\tbreak;\n\t\t\tcase PreambleLength::LEN_1024:\n\t\t\t\t_pacSize = PacSize::SIZE_32;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t_pacSize = PacSize::SIZE_64; // In case of 1536, 2048 or 4096 preamble length.\n\t\t\t}\n\n\t\t\t_preambleLength = preamble_length;\n\t\t}\n\n\t\tvoid _setPreambleCode(PreambleCode preamble_code)\n\t\t{\n\t\t\tbyte preacode = static_cast<byte>(preamble_code);\n\t\t\tpreacode &= 0x1F;\n\t\t\t_chanctrl[2] &= 0x3F;\n\t\t\t_chanctrl[2] |= ((preacode << 6) & 0xFF);\n\t\t\t_chanctrl[3] = 0x00;\n\t\t\t_chanctrl[3] = ((((preacode >> 2) & 0x07) | (preacode << 3)) & 0xFF);\n\n\t\t\t_preambleCode = preamble_code;\n\t\t}\n\n\t\tboolean _checkPreambleCodeValidity()\n\t\t{\n\t\t\tbyte preacode = static_cast<byte>(_preambleCode);\n\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t{\n\t\t\t\tfor (auto i = 0; i < 2; i++)\n\t\t\t\t{\n\t\t\t\t\tif (preacode == preamble_validity_matrix_PRF16[(int)_channel][i])\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t{\n\t\t\t\tfor (auto i = 0; i < 4; i++)\n\t\t\t\t{\n\t\t\t\t\tif (preacode == preamble_validity_matrix_PRF64[(int)_channel][i])\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn false; // TODO Proper error handling\n\t\t\t}\n\t\t}\n\n\t\tvoid _setValidPreambleCode()\n\t\t{\n\t\t\tPreambleCode preamble_code;\n\n\t\t\tswitch (_channel)\n\t\t\t{\n\t\t\tcase Channel::CHANNEL_1:\n\t\t\t\tpreamble_code = _pulseFrequency == PulseFrequency::FREQ_16MHZ ? PreambleCode::CODE_2 : PreambleCode::CODE_10;\n\t\t\t\tbreak;\n\t\t\tcase Channel::CHANNEL_3:\n\t\t\t\tpreamble_code = _pulseFrequency == PulseFrequency::FREQ_16MHZ ? PreambleCode::CODE_6 : PreambleCode::CODE_10;\n\t\t\t\tbreak;\n\t\t\tcase Channel::CHANNEL_4:\n\t\t\tcase Channel::CHANNEL_7:\n\t\t\t\tpreamble_code = _pulseFrequency == PulseFrequency::FREQ_16MHZ ? PreambleCode::CODE_8 : PreambleCode::CODE_18;\n\t\t\t\tbreak;\n\t\t\tcase Channel::CHANNEL_2:\n\t\t\tcase Channel::CHANNEL_5:\n\t\t\t\tpreamble_code = _pulseFrequency == PulseFrequency::FREQ_16MHZ ? PreambleCode::CODE_3 : PreambleCode::CODE_10;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn; // TODO Proper Error Handling\n\t\t\t}\n\t\t\tbyte preacode = static_cast<byte>(preamble_code);\n\t\t\tpreacode &= 0x1F;\n\t\t\t_chanctrl[2] &= 0x3F;\n\t\t\t_chanctrl[2] |= ((preacode << 6) & 0xFF);\n\t\t\t_chanctrl[3] = 0x00;\n\t\t\t_chanctrl[3] = ((((preacode >> 2) & 0x07) | (preacode << 3)) & 0xFF);\n\n\t\t\t_preambleCode = preamble_code;\n\t\t}\n\n\t\tvoid _setNonStandardSFDLength()\n\t\t{\n\t\t\tswitch (_dataRate)\n\t\t\t{\n\t\t\tcase DataRate::RATE_6800KBPS:\n\t\t\t\t_writeByte(USR_SFD, SFD_LENGTH_SUB, 0x08);\n\t\t\t\tbreak;\n\t\t\tcase DataRate::RATE_850KBPS:\n\t\t\t\t_writeByte(USR_SFD, SFD_LENGTH_SUB, 0x10);\n\t\t\t\tbreak;\n\t\t\tcase DataRate::RATE_110KBPS:\n\t\t\t\t_writeByte(USR_SFD, SFD_LENGTH_SUB, 0x40);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn; // TODO Proper error handling\n\t\t\t}\n\t\t}\n\n\t\tvoid _interruptOnSent(boolean val)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_MASK, TXFRS_BIT, val);\n\t\t}\n\n\t\tvoid _interruptOnReceived(boolean val)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_MASK, RXDFR_BIT, val);\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_MASK, RXFCG_BIT, val);\n\t\t}\n\n\t\tvoid _interruptOnReceiveFailed(boolean val)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_STATUS, RXPHE_BIT, val);\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_STATUS, RXFCE_BIT, val);\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_STATUS, RXRFSL_BIT, val);\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_STATUS, LDEERR_BIT, val);\n\t\t}\n\n\t\tvoid _interruptOnReceiveTimeout(boolean val)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_MASK, RXRFTO_BIT, val);\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_MASK, RXPTO_BIT, val);\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_MASK, RXSFDTO_BIT, val);\n\t\t}\n\n\t\tvoid _interruptOnReceiveTimestampAvailable(boolean val)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_MASK, LDEDONE_BIT, val);\n\t\t}\n\n\t\tvoid _interruptOnAutomaticAcknowledgeTrigger(boolean val)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_MASK, AAT_BIT, val);\n\t\t}\n\n\t\tvoid _manageLDE()\n\t\t{\n\t\t\t// transfer any ldo tune values\n\t\t\tbyte ldoTune[LEN_OTP_RDAT];\n\t\t\tuint16_t LDOTUNE_ADDRESS = 0x04;\n\t\t\t_readBytesOTP(LDOTUNE_ADDRESS, ldoTune); // TODO #define\n\t\t\tif (ldoTune[0] != 0)\n\t\t\t{\n\t\t\t\t// TODO tuning available, copy over to RAM: use OTP_LDO bit\n\t\t\t}\n\t\t\t// tell the chip to load the LDE microcode\n\t\t\t// TODO remove clock-related code (PMSC_CTRL) as handled separately\n\t\t\tbyte pmscctrl0[LEN_PMSC_CTRL0];\n\t\t\tbyte otpctrl[LEN_OTP_CTRL];\n\t\t\tmemset(pmscctrl0, 0, LEN_PMSC_CTRL0);\n\t\t\tmemset(otpctrl, 0, LEN_OTP_CTRL);\n\t\t\t_readBytes(PMSC, PMSC_CTRL0_SUB, pmscctrl0, LEN_PMSC_CTRL0);\n\t\t\t_readBytes(OTP_IF, OTP_CTRL_SUB, otpctrl, LEN_OTP_CTRL);\n\t\t\tpmscctrl0[0] = 0x01;\n\t\t\tpmscctrl0[1] = 0x03;\n\t\t\totpctrl[1] = 0x80;\n\t\t\t_writeBytesToRegister(PMSC, PMSC_CTRL0_SUB, pmscctrl0, 2);\n\t\t\t// uCode\n\t\t\t_enableClock(LDE_CLOCK);\n\t\t\tdelay(5);\n\t\t\t_writeBytesToRegister(OTP_IF, OTP_CTRL_SUB, otpctrl, 2);\n\t\t\tdelay(1);\n\t\t\t_enableClock(SYS_AUTO_CLOCK);\n\t\t\tdelay(5);\n\t\t\tpmscctrl0[0] = 0x00;\n\t\t\tpmscctrl0[1] &= 0x02;\n\t\t\t_writeBytesToRegister(PMSC, PMSC_CTRL0_SUB, pmscctrl0, 2);\n\t\t}\n\n\t\t/* Crystal calibration from OTP (if available)\n\t\t * FS_XTALT - reg:0x2B, sub-reg:0x0E\n\t\t * OTP(one-time-programmable) memory map - table 10 */\n\t\tvoid _fsxtalt()\n\t\t{\n\t\t\tbyte fsxtalt[LEN_FS_XTALT];\n\t\t\tbyte buf_otp[4];\n\t\t\t_readBytesOTP(0x01E, buf_otp); // 0x01E -> byte[0]=XTAL_Trim\n\t\t\tif (buf_otp[0] == 0)\n\t\t\t{\n\t\t\t\t// No trim value available from OTP, use midrange value of 0x10\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fsxtalt, ((0x10 & 0x1F) | 0x60), LEN_FS_XTALT);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fsxtalt, ((buf_otp[0] & 0x1F) | 0x60), LEN_FS_XTALT);\n\t\t\t}\n\t\t\t// write configuration back to chip\n\t\t\t_writeBytesToRegister(FS_CTRL, FS_XTALT_SUB, fsxtalt, LEN_FS_XTALT);\n\t\t}\n\n\t\tvoid _clearReceiveStatus()\n\t\t{\n\t\t\t// clear latched RX bits (i.e. write 1 to clear)\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXDFR_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXFCG_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXPRD_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXSFDD_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXPHD_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, LDEDONE_BIT, true);\n\t\t\t_writeBytesToRegister(SYS_STATUS, NO_SUB, _sysstatus, LEN_SYS_STATUS);\n\t\t}\n\n\t\tvoid _clearReceiveTimestampAvailableStatus()\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, LDEDONE_BIT, true);\n\t\t\t_writeBytesToRegister(SYS_STATUS, NO_SUB, _sysstatus, LEN_SYS_STATUS);\n\t\t}\n\n\t\tvoid _clearReceiveTimeoutStatus()\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXRFTO_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXPTO_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXSFDTO_BIT, true);\n\t\t\t_writeBytesToRegister(SYS_STATUS, NO_SUB, _sysstatus, LEN_SYS_STATUS);\n\t\t}\n\n\t\tvoid _clearReceiveFailedStatus()\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXPHE_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXFCE_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXRFSL_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, AFFREJ_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, LDEERR_BIT, true);\n\t\t\t_writeBytesToRegister(SYS_STATUS, NO_SUB, _sysstatus, LEN_SYS_STATUS);\n\t\t}\n\n\t\tvoid _clearTransmitStatus()\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, AAT_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, TXFRB_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, TXPRS_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, TXPHS_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, TXFRS_BIT, true);\n\t\t\t_writeBytesToRegister(SYS_STATUS, NO_SUB, _sysstatus, LEN_SYS_STATUS);\n\t\t}\n\n\t\tvoid _resetReceiver()\n\t\t{\n\t\t\t/* Set to 0 only bit 28 */\n\t\t\t_writeToRegister(PMSC, PMSC_SOFTRESET_SUB, 0xE0, LEN_PMSC_SOFTRESET);\n\t\t\t/* Set SOFTRESET to all ones */\n\t\t\t_writeToRegister(PMSC, PMSC_SOFTRESET_SUB, 0xF0, LEN_PMSC_SOFTRESET);\n\t\t}\n\n\t\t/* Internal helpers to read configuration */\n\n\t\tvoid _readSystemConfigurationRegister()\n\t\t{\n\t\t\t_readBytes(SYS_CFG, NO_SUB, _syscfg, LEN_SYS_CFG);\n\t\t}\n\n\t\tvoid _readSystemEventStatusRegister()\n\t\t{\n\t\t\t_readBytes(SYS_STATUS, NO_SUB, _sysstatus, LEN_SYS_STATUS);\n\t\t}\n\n\t\tvoid _readNetworkIdAndDeviceAddress()\n\t\t{\n\t\t\t_readBytes(PANADR, NO_SUB, _networkAndAddress, LEN_PANADR);\n\t\t}\n\n\t\tvoid _readSystemEventMaskRegister()\n\t\t{\n\t\t\t_readBytes(SYS_MASK, NO_SUB, _sysmask, LEN_SYS_MASK);\n\t\t}\n\n\t\tvoid _readChannelControlRegister()\n\t\t{\n\t\t\t_readBytes(CHAN_CTRL, NO_SUB, _chanctrl, LEN_CHAN_CTRL);\n\t\t}\n\n\t\tvoid _readTransmitFrameControlRegister()\n\t\t{\n\t\t\t_readBytes(TX_FCTRL, NO_SUB, _txfctrl, LEN_TX_FCTRL);\n\t\t}\n\n\t\tboolean _isTransmitDone()\n\t\t{\n\t\t\treturn DW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, TXFRS_BIT);\n\t\t}\n\n\t\tboolean _isReceiveTimestampAvailable()\n\t\t{\n\t\t\treturn DW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, LDEDONE_BIT);\n\t\t}\n\n\t\tboolean _isReceiveDone()\n\t\t{\n\t\t\tif (_frameCheck)\n\t\t\t{\n\t\t\t\treturn (DW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXFCG_BIT) &&\n\t\t\t\t\t\tDW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXDFR_BIT));\n\t\t\t}\n\t\t\treturn DW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXDFR_BIT);\n\t\t}\n\n\t\tboolean _isReceiveFailed()\n\t\t{\n\t\t\treturn (DW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXPHE_BIT) ||\n\t\t\t\t\tDW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXFCE_BIT) ||\n\t\t\t\t\tDW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXRFSL_BIT) ||\n\t\t\t\t\tDW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, LDEERR_BIT));\n\t\t}\n\n\t\tboolean _isReceiveTimeout()\n\t\t{\n\t\t\treturn (DW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXRFTO_BIT) ||\n\t\t\t\t\tDW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXPTO_BIT) ||\n\t\t\t\t\tDW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXSFDTO_BIT));\n\t\t}\n\n\t\tboolean _isClockProblem()\n\t\t{\n\t\t\treturn (DW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, CLKPLL_LL_BIT) ||\n\t\t\t\t\tDW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RFPLL_LL_BIT));\n\t\t}\n\n\t\tvoid _disableSequencing()\n\t\t{\n\t\t\t_enableClock(SYS_XTI_CLOCK);\n\t\t\tbyte zero[2];\n\t\t\tDW1000NgUtils::writeValueToBytes(zero, 0x0000, 2);\n\t\t\t_writeBytesToRegister(PMSC, PMSC_CTRL1_SUB, zero, 2); // To re-enable write 0xE7\n\t\t}\n\n\t\tvoid _configureRFTransmitPowerSpectrumTestMode()\n\t\t{\n\t\t\t/* Enabled TXFEN, PLLFEN, LDOFEN and set TXRXSW to TX */\n\t\t\tbyte enable_mask[4];\n\t\t\tDW1000NgUtils::writeValueToBytes(enable_mask, 0x005FFF00, LEN_RX_CONF_SUB);\n\t\t\t_writeBytesToRegister(RF_CONF, RF_CONF_SUB, enable_mask, LEN_RX_CONF_SUB);\n\t\t}\n\n\t\tvoid _uploadConfigToAON()\n\t\t{\n\t\t\t/* Write 1 in UPL_CFG_BIT */\n\t\t\t_writeToRegister(AON, AON_CTRL_SUB, 0x04, LEN_AON_CTRL);\n\t\t\t/* Clear the register */\n\t\t\t_writeToRegister(AON, AON_CTRL_SUB, 0x00, LEN_AON_CTRL);\n\t\t}\n\t}\n\n\t/* ####################### PUBLIC ###################### */\n\n\tvoid initialize(uint8_t ss, uint8_t irq, uint8_t rst)\n\t{\n\t\t// generous initial init/wake-up-idle delay\n\t\tdelay(5);\n\t\t_ss = ss;\n\t\t_irq = irq;\n\t\t_rst = rst;\n\n\t\tif (rst != 0xff)\n\t\t{\n\t\t\t// DW1000 data sheet v2.08 Â§5.6.1 page 20, the RSTn pin should not be driven high but left floating.\n\t\t\tpinMode(_rst, INPUT);\n\t\t}\n\n\t\tSPIporting::SPIinit();\n\t\t// pin and basic member setup\n\t\t// attach interrupt\n\t\t// TODO throw error if pin is not a interrupt pin\n\t\tif (_irq != 0xff)\n\t\t{\n\t\t\tattachInterrupt(digitalPinToInterrupt(_irq), interruptServiceRoutine, RISING);\n\t\t\t// attachInterrupt(digitalPinToInterrupt(_irq), interruptServiceRoutine, FALLING);\n\t\t}\n\n\t\tSPIporting::SPIselect(_ss, _irq);\n\t\t// reset chip (either soft or hard)\n\t\treset();\n\n\t\tSPIporting::setSPIspeed(SPIClock::SLOW);\n\t\t_enableClock(SYS_XTI_CLOCK);\n\t\tdelay(5);\n\n\t\t// Configure the CPLL lock detect\n\t\t_writeBitToRegister(EXT_SYNC, EC_CTRL_SUB, LEN_EC_CTRL, PLLLDT_BIT, true);\n\n\t\t// Configure XTAL trim\n\t\t_fsxtalt();\n\n\t\t// load LDE micro-code\n\t\t_manageLDE();\n\n\t\t// read the temp and vbat readings from OTP that were recorded during production test\n\t\t// see 6.3.1 OTP memory map\n\t\tbyte buf_otp[4];\n\t\t_readBytesOTP(0x008, buf_otp); // the stored 3.3 V reading\n\t\t_vmeas3v3 = buf_otp[0];\n\t\t// Serial.printf(\"_vmeas3v3=%d\\r\\n\", _vmeas3v3);\n\t\t_readBytesOTP(0x009, buf_otp); // the stored 23C reading\n\t\t_tmeas23C = buf_otp[0];\n\t\t// Serial.printf(\"_tmeas23C=%d\\r\\n\", _tmeas23C);\n\n\t\t_enableClock(SYS_AUTO_CLOCK);\n\t\tdelay(5);\n\t\tSPIporting::setSPIspeed(SPIClock::FAST);\n\n\t\t_readNetworkIdAndDeviceAddress();\n\t\t_readSystemConfigurationRegister();\n\t\t_readChannelControlRegister();\n\t\t_readTransmitFrameControlRegister();\n\t\t_readSystemEventMaskRegister();\n\n\t\t/* Cleared AON:CFG1(0x2C:0x0A) for proper operation of deepSleep */\n\t\t_writeToRegister(AON, AON_CFG1_SUB, 0x00, LEN_AON_CFG1);\n\t}\n\n\tvoid initializeNoInterrupt(uint8_t ss, uint8_t rst)\n\t{\n\t\tinitialize(ss, 0xff, rst);\n\t}\n\n\t/* callback handler management. */\n\tvoid attachErrorHandler(void (*handleError)(void))\n\t{\n\t\t_handleError = handleError;\n\t}\n\n\tvoid attachSentHandler(void (*handleSent)(void))\n\t{\n\t\t_handleSent = handleSent;\n\t}\n\n\tvoid attachReceivedHandler(void (*handleReceived)(void))\n\t{\n\t\t_handleReceived = handleReceived;\n\t}\n\n\tvoid attachReceiveFailedHandler(void (*handleReceiveFailed)(void))\n\t{\n\t\t_handleReceiveFailed = handleReceiveFailed;\n\t}\n\n\tvoid attachReceiveTimeoutHandler(void (*handleReceiveTimeout)(void))\n\t{\n\t\t_handleReceiveTimeout = handleReceiveTimeout;\n\t}\n\n\tvoid attachReceiveTimestampAvailableHandler(void (*handleReceiveTimestampAvailable)(void))\n\t{\n\t\t_handleReceiveTimestampAvailable = handleReceiveTimestampAvailable;\n\t}\n\n\tvoid interruptServiceRoutine()\n\t{\n\t\t// Serial.printf(\"test----------------------------0\\r\\n\");\n\t\t// read current status and handle via callbacks\n\t\t_readSystemEventStatusRegister();\n\t\tif (_isClockProblem() /* TODO and others */ && _handleError != 0)\n\t\t{\n\t\t\t(*_handleError)();\n\t\t\t// Serial.printf(\"interrupt----------------------------1\\r\\n\");\n\t\t}\n\t\tif (_isTransmitDone())\n\t\t{\n\t\t\t_clearTransmitStatus();\n\t\t\tif (_handleSent != nullptr)\n\t\t\t{\n\t\t\t\t(*_handleSent)();\n\t\t\t\t// Serial.printf(\"interrupt----------------------------2\\r\\n\");\n\t\t\t}\n\t\t}\n\t\tif (_isReceiveTimestampAvailable())\n\t\t{\n\t\t\t_clearReceiveTimestampAvailableStatus();\n\t\t\tif (_handleReceiveTimestampAvailable != nullptr)\n\t\t\t{\n\t\t\t\t(*_handleReceiveTimestampAvailable)();\n\t\t\t\t// Serial.printf(\"interrupt----------------------------3\\r\\n\");\n\t\t\t}\n\t\t}\n\t\tif (_isReceiveFailed())\n\t\t{\n\t\t\t_clearReceiveFailedStatus();\n\t\t\tforceTRxOff();\n\t\t\t_resetReceiver();\n\t\t\tif (_handleReceiveFailed != nullptr)\n\t\t\t{\n\t\t\t\t(*_handleReceiveFailed)();\n\t\t\t\t// Serial.printf(\"interrupt----------------------------4\\r\\n\");\n\t\t\t}\n\t\t}\n\t\telse if (_isReceiveTimeout())\n\t\t{\n\t\t\t_clearReceiveTimeoutStatus();\n\t\t\tforceTRxOff();\n\t\t\t_resetReceiver();\n\t\t\tif (_handleReceiveTimeout != nullptr)\n\t\t\t{\n\t\t\t\t(*_handleReceiveTimeout)();\n\t\t\t\t// Serial.printf(\"interrupt----------------------------5\\r\\n\");\n\t\t\t}\n\t\t}\n\t\telse if (_isReceiveDone())\n\t\t{\n\t\t\t_clearReceiveStatus();\n\t\t\tif (_handleReceived != nullptr)\n\t\t\t{\n\t\t\t\t(*_handleReceived)();\n\t\t\t\t// Serial.printf(\"interrupt----------------------------6\\r\\n\");\n\t\t\t}\n\t\t}\n\t\t// Latched bits in status register are reset by writing 1 to them\n\t\tmemset(_sysstatus, 0xff, LEN_SYS_STATUS);\n\t\t_writeBytesToRegister(SYS_STATUS, NO_SUB, _sysstatus, LEN_SYS_STATUS);\n\t}\n\n\tboolean isTransmitDone()\n\t{\n\t\t_readSystemEventStatusRegister();\n\t\treturn _isTransmitDone();\n\t}\n\n\tvoid clearTransmitStatus()\n\t{\n\t\t_clearTransmitStatus();\n\t}\n\n\tboolean isReceiveDone()\n\t{\n\t\t_readSystemEventStatusRegister();\n\t\treturn _isReceiveDone();\n\t}\n\n\tvoid clearReceiveStatus()\n\t{\n\t\t_clearReceiveStatus();\n\t}\n\n\tboolean isReceiveFailed()\n\t{\n\t\t_readSystemEventStatusRegister();\n\t\treturn _isReceiveFailed();\n\t}\n\n\tvoid clearReceiveFailedStatus()\n\t{\n\t\t_clearReceiveFailedStatus();\n\t\tforceTRxOff();\n\t\t_resetReceiver();\n\t}\n\n\tboolean isReceiveTimeout()\n\t{\n\t\t_readSystemEventMaskRegister();\n\t\treturn _isReceiveTimeout();\n\t}\n\n\tvoid clearReceiveTimeoutStatus()\n\t{\n\t\t_clearReceiveTimeoutStatus();\n\t\tforceTRxOff();\n\t\t_resetReceiver();\n\t}\n\n\tvoid enableDebounceClock()\n\t{\n\t\tbyte pmscctrl0[LEN_PMSC_CTRL0];\n\t\tmemset(pmscctrl0, 0, LEN_PMSC_CTRL0);\n\t\t_readBytes(PMSC, PMSC_CTRL0_SUB, pmscctrl0, LEN_PMSC_CTRL0);\n\t\tDW1000NgUtils::setBit(pmscctrl0, LEN_PMSC_CTRL0, GPDCE_BIT, 1);\n\t\tDW1000NgUtils::setBit(pmscctrl0, LEN_PMSC_CTRL0, KHZCLKEN_BIT, 1);\n\t\t_writeBytesToRegister(PMSC, PMSC_CTRL0_SUB, pmscctrl0, LEN_PMSC_CTRL0);\n\t\t_debounceClockEnabled = true;\n\t}\n\n\tvoid enableLedBlinking()\n\t{\n\t\tbyte pmscledc[LEN_PMSC_LEDC];\n\t\tmemset(pmscledc, 0, LEN_PMSC_LEDC);\n\t\t_readBytes(PMSC, PMSC_LEDC_SUB, pmscledc, LEN_PMSC_LEDC);\n\t\tDW1000NgUtils::setBit(pmscledc, LEN_PMSC_LEDC, BLNKEN, 1);\n\t\t_writeBytesToRegister(PMSC, PMSC_LEDC_SUB, pmscledc, LEN_PMSC_LEDC);\n\t}\n\n\tvoid setGPIOMode(uint8_t msgp, uint8_t mode)\n\t{\n\t\tbyte gpiomode[LEN_GPIO_MODE];\n\t\tmemset(gpiomode, 0, LEN_GPIO_MODE);\n\t\t_readBytes(GPIO_CTRL, GPIO_MODE_SUB, gpiomode, LEN_GPIO_MODE);\n\t\tfor (char i = 0; i < 2; i++)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(gpiomode, LEN_GPIO_MODE, msgp + i, (mode >> i) & 1);\n\t\t}\n\t\t_writeBytesToRegister(GPIO_CTRL, GPIO_MODE_SUB, gpiomode, LEN_GPIO_MODE);\n\t}\n\n\tvoid applySleepConfiguration(sleep_configuration_t sleep_config)\n\t{\n\t\tbyte aon_wcfg[LEN_AON_WCFG];\n\t\t_readBytes(AON, AON_WCFG_SUB, aon_wcfg, LEN_AON_WCFG);\n\t\tbyte aon_cfg0[1];\n\t\tmemset(aon_cfg0, 0, 1);\n\n\t\tDW1000NgUtils::setBit(aon_wcfg, LEN_AON_WCFG, ONW_RADC_BIT, sleep_config.onWakeUpRunADC);\n\t\tDW1000NgUtils::setBit(aon_wcfg, LEN_AON_WCFG, ONW_RX_BIT, sleep_config.onWakeUpReceive);\n\t\tDW1000NgUtils::setBit(aon_wcfg, LEN_AON_WCFG, ONW_LEUI_BIT, sleep_config.onWakeUpLoadEUI);\n\t\tDW1000NgUtils::setBit(aon_wcfg, LEN_AON_WCFG, ONW_LDC_BIT, true);\n\t\tDW1000NgUtils::setBit(aon_wcfg, LEN_AON_WCFG, ONW_L64P_BIT, sleep_config.onWakeUpLoadL64Param);\n\t\tDW1000NgUtils::setBit(aon_wcfg, LEN_AON_WCFG, ONW_PRES_SLEEP_BIT, sleep_config.preserveSleep);\n\t\tDW1000NgUtils::setBit(aon_wcfg, LEN_AON_WCFG, ONW_LLDE_BIT, true);\n\t\tDW1000NgUtils::setBit(aon_wcfg, LEN_AON_WCFG, ONW_LLDO_BIT, true);\n\t\t_writeBytesToRegister(AON, AON_WCFG_SUB, aon_wcfg, LEN_AON_WCFG);\n\n\t\tDW1000NgUtils::setBit(aon_cfg0, 1, WAKE_PIN_BIT, sleep_config.enableWakePIN);\n\t\tDW1000NgUtils::setBit(aon_cfg0, 1, WAKE_SPI_BIT, sleep_config.enableWakeSPI);\n\t\tDW1000NgUtils::setBit(aon_cfg0, 1, WAKE_CNT_BIT, false);\n\t\tDW1000NgUtils::setBit(aon_cfg0, 1, SLEEP_EN_BIT, sleep_config.enableSLP);\n\t\t_writeBytesToRegister(AON, AON_CFG0_SUB, aon_cfg0, 1); // Deletes 3 bits of the unused LPCLKDIVA\n\t}\n\n\t/*Puts the device into sleep/deepSleep mode. This function also upload sleep config to AON. */\n\tvoid deepSleep()\n\t{\n\t\t/* Clear the register */\n\t\t_writeToRegister(AON, AON_CTRL_SUB, 0x00, LEN_AON_CTRL);\n\t\t/* Write 1 in SAVE_BIT */\n\t\t_writeToRegister(AON, AON_CTRL_SUB, 0x02, LEN_AON_CTRL);\n\t}\n\n\tvoid spiWakeup()\n\t{\n\t\tbyte deviceId[LEN_DEV_ID];\n\t\tbyte expectedDeviceId[LEN_DEV_ID];\n\t\tDW1000NgUtils::writeValueToBytes(expectedDeviceId, 0xDECA0130, LEN_DEV_ID);\n\t\t_readBytes(DEV_ID, NO_SUB, deviceId, LEN_DEV_ID);\n\t\tif (memcmp(deviceId, expectedDeviceId, LEN_DEV_ID))\n\t\t{\n\t\t\tdigitalWrite(_ss, LOW);\n\t\t\tdelay(1);\n\t\t\tdigitalWrite(_ss, HIGH);\n\t\t\tdelay(5);\n\t\t\tsetTxAntennaDelay(_antennaTxDelay);\n\t\t\tif (_debounceClockEnabled)\n\t\t\t{\n\t\t\t\tenableDebounceClock();\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid reset()   \n\t{\n\t\tif (_rst == 0xff)\n\t\t{ /* Fallback to Software Reset */\n\t\t\tsoftwareReset();\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// DW1000Ng data sheet v2.08 Â§5.6.1 page 20, the RSTn pin should not be driven high but left floating.\n\t\t\tpinMode(_rst, OUTPUT);\n\t\t\tdigitalWrite(_rst, LOW);\n\t\t\tdelay(2); // DW1000Ng data sheet v2.08 Â§5.6.1 page 20: nominal 50ns, to be safe take more time\n\t\t\tpinMode(_rst, INPUT);\n\t\t\tdelay(5); // dw1000Ng data sheet v1.2 page 5: nominal 3 ms, to be safe take more time\n\t\t}\n\t}\n\n\tvoid softwareReset()\n\t{\n\t\tSPIporting::setSPIspeed(SPIClock::SLOW);\n\n\t\t/* Disable sequencing and go to state \"INIT\" - (a) Sets SYSCLKS to 01 */\n\t\t_disableSequencing();\n\t\t/* Clear AON and WakeUp configuration */\n\t\t_writeToRegister(AON, AON_WCFG_SUB, 0x00, LEN_AON_WCFG);\n\t\t_writeToRegister(AON, AON_CFG0_SUB, 0x00, LEN_AON_CFG0);\n\t\t// TODO change this with uploadToAON\n\t\t_writeToRegister(AON, AON_CTRL_SUB, 0x00, LEN_AON_CTRL);\n\t\t_writeToRegister(AON, AON_CTRL_SUB, 0x02, LEN_AON_CTRL);\n\t\t/* (b) Clear SOFTRESET to all zeroâ€™s */\n\t\t_writeToRegister(PMSC, PMSC_SOFTRESET_SUB, 0x00, LEN_PMSC_SOFTRESET);\n\t\tdelay(1);\n\t\t/* (c) Set SOFTRESET to all ones */\n\t\t_writeToRegister(PMSC, PMSC_SOFTRESET_SUB, 0xF0, LEN_PMSC_SOFTRESET);\n\t}\n\n\t/* ###########################################################################\n\t * #### Pretty printed device information ####################################\n\t * ######################################################################### */\n\n\tvoid getPrintableDeviceIdentifier(char msgBuffer[])\n\t{\n\t\tbyte data[LEN_DEV_ID];\n\t\t_readBytes(DEV_ID, NO_SUB, data, LEN_DEV_ID);\n\t\tsprintf(msgBuffer, \"%02X - model: %d, version: %d, revision: %d\",\n\t\t\t\t(uint16_t)((data[3] << 8) | data[2]), data[1], (data[0] >> 4) & 0x0F, data[0] & 0x0F);\n\t}\n\n\tvoid getPrintableExtendedUniqueIdentifier(char msgBuffer[])\n\t{\n\t\tbyte data[LEN_EUI];\n\t\t_readBytes(EUI, NO_SUB, data, LEN_EUI);\n\t\tsprintf(msgBuffer, \"%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X\",\n\t\t\t\tdata[7], data[6], data[5], data[4], data[3], data[2], data[1], data[0]);\n\t}\n\n\tvoid getPrintableNetworkIdAndShortAddress(char msgBuffer[])\n\t{\n\t\tbyte data[LEN_PANADR];\n\t\t_readBytes(PANADR, NO_SUB, data, LEN_PANADR);\n\t\tsprintf(msgBuffer, \"PAN: %02X, Short Address: %02X\",\n\t\t\t\t(uint16_t)((data[3] << 8) | data[2]), (uint16_t)((data[1] << 8) | data[0]));\n\t}\n\n\tvoid getPrintableDeviceMode(char msgBuffer[])\n\t{\n\t\tuint16_t dr;\n\t\tuint8_t prf;\n\t\tuint16_t plen;\n\t\tuint8_t pcode;\n\t\tuint8_t ch;\n\t\tbyte chan_ctrl[LEN_CHAN_CTRL];\n\t\tbyte tx_fctrl[LEN_TX_FCTRL];\n\t\t_readBytes(CHAN_CTRL, NO_SUB, chan_ctrl, LEN_CHAN_CTRL);\n\t\t_readBytes(TX_FCTRL, NO_SUB, tx_fctrl, LEN_TX_FCTRL);\n\t\t/* Data Rate from 0x08 bits:13-14(tx_fctrl) */\n\t\tdr = (uint16_t)(tx_fctrl[1] >> 5 & 0x3);\n\t\tswitch (dr)\n\t\t{\n\t\tcase 0x00:\n\t\t\tdr = 110;\n\t\t\tbreak;\n\t\tcase 0x01:\n\t\t\tdr = 850;\n\t\t\tbreak;\n\t\tcase 0x02:\n\t\t\tdr = 6800;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn; // TODO Error handling\n\t\t}\n\t\t/* PRF(16 or 64) from 0x1F bits:18-19(chan_ctrl) */\n\t\tprf = (uint8_t)(chan_ctrl[2] >> 2 & 0x03);\n\t\tif (prf == 0x01)\n\t\t{\n\t\t\tprf = 16;\n\t\t}\n\t\telse if (prf == 0x02)\n\t\t{\n\t\t\tprf = 64;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn; // TODO Error handling\n\t\t}\n\t\t/* PreambleLength from 0x08 bits:18-21(tx_fctrl) */\n\t\tplen = (uint16_t)(tx_fctrl[2] >> 2 & 0xF);\n\t\tswitch (plen)\n\t\t{\n\t\tcase 0x01:\n\t\t\tplen = 64;\n\t\t\tbreak;\n\t\tcase 0x05:\n\t\t\tplen = 128;\n\t\t\tbreak;\n\t\tcase 0x09:\n\t\t\tplen = 256;\n\t\t\tbreak;\n\t\tcase 0x0D:\n\t\t\tplen = 512;\n\t\t\tbreak;\n\t\tcase 0x02:\n\t\t\tplen = 1024;\n\t\t\tbreak;\n\t\tcase 0x06:\n\t\t\tplen = 1536;\n\t\t\tbreak;\n\t\tcase 0x0A:\n\t\t\tplen = 2048;\n\t\t\tbreak;\n\t\tcase 0x03:\n\t\t\tplen = 4096;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn; // TODO Error handling\n\t\t}\n\t\t/* Channel from 0x1F bits:0-4(tx_chan) */\n\t\tch = (uint8_t)(chan_ctrl[0] & 0xF);\n\t\t/* Preamble Code from 0x1F bits:24-31(chan_ctrl) */\n\t\tpcode = (uint8_t)(chan_ctrl[3] >> 3 & 0x1F);\n\t\tsprintf(msgBuffer, \"Data rate: %u kb/s, PRF: %u MHz, Preamble: %u symbols, Channel: #%u, Preamble code #%u\", dr, prf, plen, ch, pcode);\n\t}\n\n\t/* ###########################################################################\n\t * #### DW1000Ng operation functions ###########################################\n\t * ######################################################################### */\n\n\tvoid setNetworkId(uint16_t val)\n\t{\n\t\t_networkAndAddress[2] = (byte)(val & 0xFF);\n\t\t_networkAndAddress[3] = (byte)((val >> 8) & 0xFF);\n\t\t_writeNetworkIdAndDeviceAddress();\n\t}\n\n\tvoid getNetworkId(byte id[])\n\t{\n\t\t_readNetworkIdAndDeviceAddress();\n\t\tid[0] = _networkAndAddress[2];\n\t\tid[1] = _networkAndAddress[3];\n\t}\n\n\tvoid setDeviceAddress(uint16_t val)\n\t{\n\t\t_networkAndAddress[0] = (byte)(val & 0xFF);\n\t\t_networkAndAddress[1] = (byte)((val >> 8) & 0xFF);\n\t\t_writeNetworkIdAndDeviceAddress();\n\t}\n\n\tvoid getDeviceAddress(byte address[])\n\t{\n\t\t_readNetworkIdAndDeviceAddress();\n\t\taddress[0] = _networkAndAddress[0];\n\t\taddress[1] = _networkAndAddress[1];\n\t}\n\n\tvoid setEUI(char eui[])\n\t{\n\t\tbyte eui_byte[LEN_EUI];\n\t\tDW1000NgUtils::convertToByte(eui, eui_byte);\n\t\tsetEUI(eui_byte);\n\t}\n\n\tvoid setEUI(byte eui[])\n\t{\n\t\t// we reverse the address->\n\t\tbyte reverseEUI[8];\n\t\tuint8_t size = 8;\n\t\tfor (uint8_t i = 0; i < size; i++)\n\t\t{\n\t\t\t*(reverseEUI + i) = *(eui + size - i - 1);\n\t\t}\n\t\t_writeBytesToRegister(EUI, NO_SUB, reverseEUI, LEN_EUI);\n\t}\n\n\tvoid getEUI(byte eui[])\n\t{\n\t\t_readBytes(EUI, NO_SUB, eui, LEN_EUI);\n\t}\n\n\tfloat getTemperature()\n\t{\n\t\t_vbatAndTempSteps();\n\t\tbyte sar_ltemp = 0;\n\t\t_readBytes(TX_CAL, 0x04, &sar_ltemp, 1);\n\t\treturn (sar_ltemp - _tmeas23C) * 1.14f + 23.0f;\n\t}\n\n\tfloat getBatteryVoltage()\n\t{\n\t\t_vbatAndTempSteps();\n\t\tbyte sar_lvbat = 0;\n\t\t_readBytes(TX_CAL, 0x03, &sar_lvbat, 1);\n\t\treturn (sar_lvbat - _vmeas3v3) / 173.0f + 3.3f;\n\t}\n\n\tvoid getTemperatureAndBatteryVoltage(float &temp, float &vbat)\n\t{\n\t\t// follow the procedure from section 6.4 of the User Manual\n\t\t_vbatAndTempSteps();\n\t\tdelay(1);\n\t\tbyte sar_lvbat = 0;\n\t\t_readBytes(TX_CAL, 0x03, &sar_lvbat, 1);\n\t\tbyte sar_ltemp = 0;\n\t\t_readBytes(TX_CAL, 0x04, &sar_ltemp, 1);\n\n\t\t// calculate voltage and temperature\n\t\tvbat = (sar_lvbat - _vmeas3v3) / 173.0f + 3.3f;\n\t\ttemp = (sar_ltemp - _tmeas23C) * 1.14f + 23.0f;\n\t}\n\n\tvoid enableFrameFiltering(frame_filtering_configuration_t config)\n\t{\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFEN_BIT, true);\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFBC_BIT, config.behaveAsCoordinator);\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFAB_BIT, config.allowBeacon);\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFAD_BIT, config.allowData);\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFAA_BIT, config.allowAcknowledgement);\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFAM_BIT, config.allowMacCommand);\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFAR_BIT, config.allowAllReserved);\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFA4_BIT, config.allowReservedFour);\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFA5_BIT, config.allowReservedFive);\n\n\t\t_writeSystemConfigurationRegister();\n\t}\n\n\tvoid disableFrameFiltering()\n\t{\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFEN_BIT, false);\n\t\t_writeSystemConfigurationRegister();\n\t}\n\n\tvoid setDoubleBuffering(boolean val)\n\t{\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, DIS_DRXB_BIT, !val);\n\t}\n\n\tvoid setAntennaDelay(uint16_t value)\n\t{\n\t\t_antennaTxDelay = value;\n\t\t_antennaRxDelay = value;\n\t\t_writeAntennaDelayRegisters();\n\t}\n\n\tvoid setTxAntennaDelay(uint16_t value)\n\t{\n\t\t_antennaTxDelay = value;\n\t\t_writeAntennaDelayRegisters();\n\t}\n\tvoid setRxAntennaDelay(uint16_t value)\n\t{\n\t\t_antennaRxDelay = value;\n\t\t_writeAntennaDelayRegisters();\n\t}\n\n\tuint16_t getTxAntennaDelay()\n\t{\n\t\treturn _antennaTxDelay;\n\t}\n\tuint16_t getRxAntennaDelay()\n\t{\n\t\treturn _antennaRxDelay;\n\t}\n\n\tvoid forceTRxOff()\n\t{\n\t\tmemset(_sysctrl, 0, LEN_SYS_CTRL);\n\t\tDW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, TRXOFF_BIT, true);\n\t\t_writeBytesToRegister(SYS_CTRL, NO_SUB, _sysctrl, LEN_SYS_CTRL);\n\t}\n\n\tvoid startReceive(ReceiveMode mode)\n\t{\n\t\tmemset(_sysctrl, 0, LEN_SYS_CTRL);\n\t\tDW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, SFCST_BIT, !_frameCheck);\n\t\tif (mode == ReceiveMode::DELAYED)\n\t\t\tDW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, RXDLYS_BIT, true);\n\t\tDW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, RXENAB_BIT, true);\n\t\t_writeBytesToRegister(SYS_CTRL, NO_SUB, _sysctrl, LEN_SYS_CTRL);\n\t}\n\n\tvoid startTransmit(TransmitMode mode)\n\t{\n\t\tmemset(_sysctrl, 0, LEN_SYS_CTRL);\n\t\tDW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, SFCST_BIT, !_frameCheck);\n\t\tif (mode == TransmitMode::DELAYED)\n\t\t\tDW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, TXDLYS_BIT, true);\n\t\tif (_wait4resp)\n\t\t\tDW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, WAIT4RESP_BIT, true);\n\n\t\tDW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, TXSTRT_BIT, true);\n\t\t_writeBytesToRegister(SYS_CTRL, NO_SUB, _sysctrl, LEN_SYS_CTRL);\n\t}\n\n\tvoid setInterruptPolarity(boolean val)\n\t{\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, HIRQ_POL_BIT, val);\n\t\t_writeSystemConfigurationRegister();\n\t}\n\n\tvoid applyConfiguration(device_configuration_t config)\n\t{\n\t\tforceTRxOff();\n\n\t\t_useExtendedFrameLength(config.extendedFrameLength);\n\t\t_setReceiverAutoReenable(config.receiverAutoReenable);\n\t\t_useSmartPower(config.smartPower);\n\t\t_useFrameCheck(config.frameCheck);\n\t\t_setNlosOptimization(config.nlos);\n\t\t_setSFDMode(config.sfd);\n\t\t_setChannel(config.channel);\n\t\t_setDataRate(config.dataRate);\n\t\t_setPulseFrequency(config.pulseFreq);\n\t\t_setPreambleLength(config.preambleLen);\n\t\t_setPreambleCode(config.preaCode);\n\n\t\tif (!_checkPreambleCodeValidity())\n\t\t\t_setValidPreambleCode();\n\n\t\tif (!_standardSFD)\n\t\t\t_setNonStandardSFDLength();\n\n\t\t// writes configuration to registers\n\t\t_writeConfiguration();\n\t\t// tune according to configuration\n\t\t_tune();\n\t}\n\n\tChannel getChannel()\n\t{\n\t\treturn _channel;\n\t}\n\n\tPulseFrequency getPulseFrequency()\n\t{\n\t\treturn _pulseFrequency;\n\t}\n\n\tvoid setPreambleDetectionTimeout(uint16_t pacSize)\n\t{\n\t\tbyte drx_pretoc[LEN_DRX_PRETOC];\n\t\tDW1000NgUtils::writeValueToBytes(drx_pretoc, pacSize, LEN_DRX_PRETOC);\n\t\t_writeBytesToRegister(DRX_TUNE, DRX_PRETOC_SUB, drx_pretoc, LEN_DRX_PRETOC);\n\t}\n\n\tvoid setSfdDetectionTimeout(uint16_t preambleSymbols)\n\t{\n\t\tbyte drx_sfdtoc[LEN_DRX_SFDTOC];\n\t\tDW1000NgUtils::writeValueToBytes(drx_sfdtoc, preambleSymbols, LEN_DRX_SFDTOC);\n\t\t_writeBytesToRegister(DRX_TUNE, DRX_SFDTOC_SUB, drx_sfdtoc, LEN_DRX_SFDTOC);\n\t}\n\n\tvoid setReceiveFrameWaitTimeoutPeriod(uint16_t timeMicroSeconds)\n\t{\n\t\tif (timeMicroSeconds > 0)\n\t\t{\n\t\t\tbyte rx_wfto[LEN_RX_WFTO];\n\t\t\tDW1000NgUtils::writeValueToBytes(rx_wfto, timeMicroSeconds, LEN_RX_WFTO);\n\t\t\t_writeBytesToRegister(RX_WFTO, NO_SUB, rx_wfto, LEN_RX_WFTO);\n\t\t\t/* enable frame wait timeout bit */\n\t\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, RXWTOE_BIT, true);\n\t\t\t_writeSystemConfigurationRegister();\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* disable frame wait timeout bit */\n\t\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, RXWTOE_BIT, false);\n\t\t\t_writeSystemConfigurationRegister();\n\t\t}\n\t}\n\n\tvoid applyInterruptConfiguration(interrupt_configuration_t interrupt_config)\n\t{\n\t\tforceTRxOff();\n\n\t\t_interruptOnSent(interrupt_config.interruptOnSent);\n\t\t_interruptOnReceived(interrupt_config.interruptOnReceived);\n\t\t_interruptOnReceiveFailed(interrupt_config.interruptOnReceiveFailed);\n\t\t_interruptOnReceiveTimeout(interrupt_config.interruptOnReceiveTimeout);\n\t\t_interruptOnReceiveTimestampAvailable(interrupt_config.interruptOnReceiveTimestampAvailable);\n\t\t_interruptOnAutomaticAcknowledgeTrigger(interrupt_config.interruptOnAutomaticAcknowledgeTrigger);\n\n\t\t_writeSystemEventMaskRegister();\n\t}\n\n\tvoid setWait4Response(uint32_t timeMicroSeconds)\n\t{\n\t\t_wait4resp = timeMicroSeconds == 0 ? false : true;\n\n\t\t/* Check if it overflows 20 bits */\n\t\tif (timeMicroSeconds > 1048575)\n\t\t\ttimeMicroSeconds = 1048575;\n\n\t\tbyte W4R_TIME[LEN_ACK_RESP_T_W4R_TIME_SUB];\n\t\tDW1000NgUtils::writeValueToBytes(W4R_TIME, timeMicroSeconds, LEN_ACK_RESP_T_W4R_TIME_SUB);\n\t\tW4R_TIME[2] &= 0x0F;\n\t\t_writeBytesToRegister(ACK_RESP_T, ACK_RESP_T_W4R_TIME_SUB, W4R_TIME, LEN_ACK_RESP_T_W4R_TIME_SUB);\n\t}\n\n\tvoid setTXPower(byte power[])\n\t{\n\t\t// TODO Check byte length\n\t\t_writeBytesToRegister(TX_POWER, NO_SUB, power, LEN_TX_POWER);\n\t\t_autoTXPower = false;\n\t}\n\n\tvoid setTXPower(int32_t power)\n\t{\n\t\tbyte txpower[LEN_TX_POWER];\n\t\tDW1000NgUtils::writeValueToBytes(txpower, power, LEN_TX_POWER);\n\t\tsetTXPower(txpower);\n\t}\n\n\tvoid setTXPower(DriverAmplifierValue driver_amplifier, TransmitMixerValue mixer)\n\t{\n\t\tbyte txpower[LEN_TX_POWER];\n\t\tbyte pwr = 0x00;\n\n\t\tpwr |= ((byte)driver_amplifier << 5);\n\t\tpwr |= (byte)mixer;\n\n\t\tfor (auto i = 0; i < LEN_TX_POWER; i++)\n\t\t{\n\t\t\ttxpower[i] = pwr;\n\t\t}\n\n\t\tsetTXPower(txpower);\n\t}\n\n\tvoid setTXPowerAuto()\n\t{\n\t\t_autoTXPower = true;\n\t\t_txpowertune();\n\t}\n\n\tvoid setTCPGDelay(byte tcpgdelay)\n\t{\n\t\tbyte tcpgBytes[LEN_TC_PGDELAY];\n\t\tDW1000NgUtils::writeValueToBytes(tcpgBytes, tcpgdelay, LEN_TC_PGDELAY);\n\t\t_writeBytesToRegister(TX_CAL, TC_PGDELAY_SUB, tcpgBytes, LEN_TC_PGDELAY);\n\t\t_autoTCPGDelay = false;\n\t}\n\n\tvoid setTCPGDelayAuto()\n\t{\n\t\t_tcpgdelaytune();\n\t\t_autoTCPGDelay = true;\n\t}\n\n\tvoid enableTransmitPowerSpectrumTestMode(int32_t repeat_interval)\n\t{\n\t\t/* DW1000 clocks must be set to crystal speed so SPI rate have to be lowered and will\n\t\tnot be increased again */\n\t\tSPIporting::setSPIspeed(SPIClock::SLOW);\n\n\t\t_disableSequencing();\n\t\t_configureRFTransmitPowerSpectrumTestMode();\n\t\t_enableClock(SYS_PLL_CLOCK);\n\t\t_enableClock(TX_PLL_CLOCK);\n\n\t\tif (repeat_interval < 4)\n\t\t\trepeat_interval = 4;\n\n\t\t/* In diagnostic transmit power  mode (set next) the bytes 31:0 only are used for DX_TIME register */\n\t\tbyte delayBytes[4];\n\t\tDW1000NgUtils::writeValueToBytes(delayBytes, repeat_interval, 4);\n\t\t_writeBytesToRegister(DX_TIME, NO_SUB, delayBytes, 4);\n\n\t\t/* Enable Transmit Power Spectrum Test Mode */\n\t\tbyte diagnosticBytes[2];\n\t\tDW1000NgUtils::writeValueToBytes(diagnosticBytes, 0x0010, LEN_DIAG_TMC);\n\t\t_writeBytesToRegister(DIG_DIAG, DIAG_TMC_SUB, diagnosticBytes, LEN_DIAG_TMC);\n\t}\n\n\tvoid setDelayedTRX(byte futureTimeBytes[])\n\t{\n\t\t/* the least significant 9-bits are ignored in DX_TIME in functional modes */\n\t\t_writeBytesToRegister(DX_TIME, NO_SUB, futureTimeBytes, LEN_DX_TIME);\n\t}\n\n\tvoid setTransmitData(byte data[], uint16_t n)\n\t{\n\t\tif (_frameCheck)\n\t\t{\n\t\t\tn += 2; // two bytes CRC-16\n\t\t}\n\t\tif (n > LEN_EXT_UWB_FRAMES)\n\t\t{\n\t\t\treturn; // TODO proper error handling: frame/buffer size\n\t\t}\n\t\tif (n > LEN_UWB_FRAMES && !_extendedFrameLength)\n\t\t{\n\t\t\treturn; // TODO proper error handling: frame/buffer size\n\t\t}\n\t\t// transmit data and length\n\t\t_writeBytesToRegister(TX_BUFFER, NO_SUB, data, n);\n\n\t\t/* Sets up transmit frame control length based on data length */\n\t\t_txfctrl[0] = (byte)(n & 0xFF); // 1 byte (regular length + 1 bit)\n\t\t_txfctrl[1] &= 0xE0;\n\t\t_txfctrl[1] |= (byte)((n >> 8) & 0x03); // 2 added bits if extended length\n\t\t_writeTransmitFrameControlRegister();\n\t}\n\n\tvoid setTransmitData(const String &data)\n\t{\n\t\tuint16_t n = data.length() + 1;\n\t\tbyte *dataBytes = (byte *)malloc(n);\n\t\tdata.getBytes(dataBytes, n);\n\t\tsetTransmitData(dataBytes, n);\n\t\tfree(dataBytes);\n\t}\n\n\t// TODO reorder\n\tuint16_t getReceivedDataLength()\n\t{\n\t\tuint16_t len = 0;\n\n\t\t// 10 bits of RX frame control register\n\t\tbyte rxFrameInfo[LEN_RX_FINFO];\n\t\t_readBytes(RX_FINFO, NO_SUB, rxFrameInfo, LEN_RX_FINFO);\n\t\tlen = ((((uint16_t)rxFrameInfo[1] << 8) | (uint16_t)rxFrameInfo[0]) & 0x03FF);\n\n\t\tif (_frameCheck && len > 2)\n\t\t{\n\t\t\treturn len - 2;\n\t\t}\n\t\treturn len;\n\t}\n\n\tvoid getReceivedData(byte data[], uint16_t n)\n\t{\n\t\tif (n <= 0)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\t_readBytes(RX_BUFFER, NO_SUB, data, n);\n\t}\n\n\tvoid getReceivedData(String &data)\n\t{\n\t\tuint16_t i;\n\t\tuint16_t n = getReceivedDataLength(); // number of bytes w/o the two FCS ones\n\t\tif (n <= 0)\n\t\t{ // TODO\n\t\t\treturn;\n\t\t}\n\t\tbyte *dataBytes = (byte *)malloc(n);\n\t\tgetReceivedData(dataBytes, n);\n\t\t// clear string\n\t\tdata.remove(0);\n\t\tdata = \"\";\n\t\t// append to string\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tdata += (char)dataBytes[i];\n\t\t}\n\t\tfree(dataBytes);\n\t}\n\n\tuint64_t getTransmitTimestamp()\n\t{\n\t\tbyte data[LENGTH_TIMESTAMP];\n\t\tmemset(data, 0, LENGTH_TIMESTAMP);\n\t\t_readBytes(TX_TIME, TX_STAMP_SUB, data, LEN_TX_STAMP);\n\t\treturn DW1000NgUtils::bytesAsValue(data, LEN_TX_STAMP);\n\t}\n\n\tuint64_t getReceiveTimestamp()\n\t{\n\t\tbyte data[LEN_RX_STAMP];\n\t\tmemset(data, 0, LEN_RX_STAMP);\n\t\t_readBytes(RX_TIME, RX_STAMP_SUB, data, LEN_RX_STAMP);\n\t\treturn DW1000NgUtils::bytesAsValue(data, LEN_RX_STAMP);\n\t}\n\n\tuint64_t getSystemTimestamp()\n\t{\n\t\tbyte data[LEN_SYS_TIME];\n\t\tmemset(data, 0, LEN_SYS_TIME);\n\t\t_readBytes(SYS_TIME, NO_SUB, data, LEN_SYS_TIME);\n\t\treturn DW1000NgUtils::bytesAsValue(data, LEN_SYS_TIME);\n\t}\n\n\tfloat getReceiveQuality()\n\t{\n\t\tbyte noiseBytes[LEN_STD_NOISE];\n\t\tbyte fpAmpl2Bytes[LEN_FP_AMPL2];\n\t\tuint16_t noise, f2;\n\t\t_readBytes(RX_FQUAL, STD_NOISE_SUB, noiseBytes, LEN_STD_NOISE);\n\t\t_readBytes(RX_FQUAL, FP_AMPL2_SUB, fpAmpl2Bytes, LEN_FP_AMPL2);\n\t\tnoise = (uint16_t)noiseBytes[0] | ((uint16_t)noiseBytes[1] << 8);\n\t\tf2 = (uint16_t)fpAmpl2Bytes[0] | ((uint16_t)fpAmpl2Bytes[1] << 8);\n\t\treturn (float)f2 / noise;\n\t}\n\n\tfloat getFirstPathPower()\n\t{\n\t\tbyte fpAmpl1Bytes[LEN_FP_AMPL1];\n\t\tbyte fpAmpl2Bytes[LEN_FP_AMPL2];\n\t\tbyte fpAmpl3Bytes[LEN_FP_AMPL3];\n\t\tbyte rxFrameInfo[LEN_RX_FINFO];\n\t\tuint16_t f1, f2, f3, N;\n\t\tfloat A, corrFac;\n\t\t_readBytes(RX_TIME, FP_AMPL1_SUB, fpAmpl1Bytes, LEN_FP_AMPL1);\n\t\t_readBytes(RX_FQUAL, FP_AMPL2_SUB, fpAmpl2Bytes, LEN_FP_AMPL2);\n\t\t_readBytes(RX_FQUAL, FP_AMPL3_SUB, fpAmpl3Bytes, LEN_FP_AMPL3);\n\t\t_readBytes(RX_FINFO, NO_SUB, rxFrameInfo, LEN_RX_FINFO);\n\t\tf1 = (uint16_t)fpAmpl1Bytes[0] | ((uint16_t)fpAmpl1Bytes[1] << 8);\n\t\tf2 = (uint16_t)fpAmpl2Bytes[0] | ((uint16_t)fpAmpl2Bytes[1] << 8);\n\t\tf3 = (uint16_t)fpAmpl3Bytes[0] | ((uint16_t)fpAmpl3Bytes[1] << 8);\n\t\tN = (((uint16_t)rxFrameInfo[2] >> 4) & 0xFF) | ((uint16_t)rxFrameInfo[3] << 4);\n\n\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t{\n\t\t\tA = 113.77;\n\t\t\tcorrFac = 2.3334;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tA = 121.74;\n\t\t\tcorrFac = 1.1667;\n\t\t}\n\t\tfloat estFpPwr = 10.0 * log10(((float)f1 * (float)f1 + (float)f2 * (float)f2 + (float)f3 * (float)f3) / ((float)N * (float)N)) - A;\n\t\tif (estFpPwr <= -88)\n\t\t{\n\t\t\treturn estFpPwr;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// approximation of Fig. 22 in user manual for dbm correction\n\t\t\testFpPwr += (estFpPwr + 88) * corrFac;\n\t\t}\n\t\treturn estFpPwr;\n\t}\n\n\tfloat getReceivePower()\n\t{\n\t\tbyte cirPwrBytes[LEN_CIR_PWR];\n\t\tbyte rxFrameInfo[LEN_RX_FINFO];\n\t\tuint32_t twoPower17 = 131072;\n\t\tuint16_t C, N;\n\t\tfloat A, corrFac;\n\t\t_readBytes(RX_FQUAL, CIR_PWR_SUB, cirPwrBytes, LEN_CIR_PWR);\n\t\t_readBytes(RX_FINFO, NO_SUB, rxFrameInfo, LEN_RX_FINFO);\n\t\tC = (uint16_t)cirPwrBytes[0] | ((uint16_t)cirPwrBytes[1] << 8);\n\t\tN = (((uint16_t)rxFrameInfo[2] >> 4) & 0xFF) | ((uint16_t)rxFrameInfo[3] << 4);\n\n\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t{\n\t\t\tA = 113.77;\n\t\t\tcorrFac = 2.3334;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tA = 121.74;\n\t\t\tcorrFac = 1.1667;\n\t\t}\n\n\t\tfloat estRxPwr = 10.0 * log10(((float)C * (float)twoPower17) / ((float)N * (float)N)) - A;\n\t\tif (estRxPwr <= -88)\n\t\t{\n\t\t\treturn estRxPwr;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// approximation of Fig. 22 in user manual for dbm correction\n\t\t\testRxPwr += (estRxPwr + 88) * corrFac;\n\t\t}\n\t\treturn estRxPwr;\n\t}\n\n#if DW1000NG_DEBUG\n\tvoid getPrettyBytes(byte data[], char msgBuffer[], uint16_t n)\n\t{\n\t\tuint16_t i, j, b;\n\t\tb = sprintf(msgBuffer, \"Data, bytes: %d\\nB: 7 6 5 4 3 2 1 0\\n\", n); // TODO - type\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tbyte curByte = data[i];\n\t\t\tsnprintf(&msgBuffer[b++], 2, \"%d\", (i + 1));\n\t\t\tmsgBuffer[b++] = (char)((i + 1) & 0xFF);\n\t\t\tmsgBuffer[b++] = ':';\n\t\t\tmsgBuffer[b++] = ' ';\n\t\t\tfor (j = 0; j < 8; j++)\n\t\t\t{\n\t\t\t\tmsgBuffer[b++] = ((curByte >> (7 - j)) & 0x01) ? '1' : '0';\n\t\t\t\tif (j < 7)\n\t\t\t\t{\n\t\t\t\t\tmsgBuffer[b++] = ' ';\n\t\t\t\t}\n\t\t\t\telse if (i < n - 1)\n\t\t\t\t{\n\t\t\t\t\tmsgBuffer[b++] = '\\n';\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmsgBuffer[b++] = '\\0';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmsgBuffer[b++] = '\\0';\n\t}\n\n\tvoid getPrettyBytes(byte cmd, uint16_t offset, char msgBuffer[], uint16_t n)\n\t{\n\t\tuint16_t i, j, b;\n\t\tbyte *readBuf = (byte *)malloc(n);\n\t\t_readBytes(cmd, offset, readBuf, n);\n\t\tb = sprintf(msgBuffer, \"Reg: 0x%02x, bytes: %d\\nB: 7 6 5 4 3 2 1 0\\n\", cmd, n); // TODO - tpye\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tbyte curByte = readBuf[i];\n\t\t\tsnprintf(&msgBuffer[b++], 2, \"%d\", (i + 1));\n\t\t\tmsgBuffer[b++] = (char)((i + 1) & 0xFF);\n\t\t\tmsgBuffer[b++] = ':';\n\t\t\tmsgBuffer[b++] = ' ';\n\t\t\tfor (j = 0; j < 8; j++)\n\t\t\t{\n\t\t\t\tmsgBuffer[b++] = ((curByte >> (7 - j)) & 0x01) ? '1' : '0';\n\t\t\t\tif (j < 7)\n\t\t\t\t{\n\t\t\t\t\tmsgBuffer[b++] = ' ';\n\t\t\t\t}\n\t\t\t\telse if (i < n - 1)\n\t\t\t\t{\n\t\t\t\t\tmsgBuffer[b++] = '\\n';\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmsgBuffer[b++] = '\\0';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmsgBuffer[b++] = '\\0';\n\t\tfree(readBuf);\n\t}\n#endif\n}"}}}Content-Length: 175

{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"}}}
>>>
Content-Length: 183

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///c:/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","diagnostics":[]},"jsonrpc":"2.0"}
<<<
Content-Length: 228

{"jsonrpc":"2.0","id":116,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":53,"character":31}}}
>>>
Content-Length: 771

{"id":116,"result":{"contents":{"kind":"markdown","value":"### function `initializeNoInterrupt`  \n\n---\nâ†’ `void`  \nParameters:  \n- `uint8_t ss`\n- `uint8_t rst = 255`\n\nInitiates and starts a sessions with a DW1000 without interrupt. If rst is not set or value 0xff, a soft resets (i.e. command triggered) are used and it is assumed that no reset line is wired.  \n@param[in] ss The SPI Selection pin used to identify the specific connection  \n@param[in] rst The reset line/pin for hard resets of ICs that connect to the Arduino. Value 0xff means soft reset.  \n\n---\n```cpp\n// In namespace DW1000Ng\nvoid initializeNoInterrupt(uint8_t ss, uint8_t rst = 255)\n```"},"range":{"start":{"line":53,"character":12},"end":{"line":53,"character":33}}},"jsonrpc":"2.0"}
<<<
Content-Length: 228

{"jsonrpc":"2.0","id":117,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":53,"character":33}}}
>>>
Content-Length: 771

{"id":117,"result":{"contents":{"kind":"markdown","value":"### function `initializeNoInterrupt`  \n\n---\nâ†’ `void`  \nParameters:  \n- `uint8_t ss`\n- `uint8_t rst = 255`\n\nInitiates and starts a sessions with a DW1000 without interrupt. If rst is not set or value 0xff, a soft resets (i.e. command triggered) are used and it is assumed that no reset line is wired.  \n@param[in] ss The SPI Selection pin used to identify the specific connection  \n@param[in] rst The reset line/pin for hard resets of ICs that connect to the Arduino. Value 0xff means soft reset.  \n\n---\n```cpp\n// In namespace DW1000Ng\nvoid initializeNoInterrupt(uint8_t ss, uint8_t rst = 255)\n```"},"range":{"start":{"line":53,"character":12},"end":{"line":53,"character":33}}},"jsonrpc":"2.0"}
<<<
Content-Length: 233

{"jsonrpc":"2.0","id":118,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":53,"character":27}}}
>>>
Content-Length: 215

{"id":118,"result":[{"uri":"file:///C:/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","range":{"start":{"line":1643,"character":6},"end":{"line":1643,"character":27}}}],"jsonrpc":"2.0"}
<<<
Content-Length: 82613

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","languageId":"cpp","version":1,"text":"/*\n * MIT License\n *\n * Copyright (c) 2018 Michele Biondi, Andrea Salvatori\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n/*\n * Copyright (c) 2015 by Thomas Trojer <thomas@trojer.net>\n * Decawave DW1000Ng library for arduino.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @file DW1000Ng.cpp\n * Arduino driver library (source file) for the Decawave DW1000Ng UWB transceiver Module.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"DW1000Ng.hpp\"\n#include \"DW1000NgUtils.hpp\"\n#include \"DW1000NgConstants.hpp\"\n#include \"DW1000NgRegisters.hpp\"\n#include \"SPIporting.hpp\"\n\nnamespace DW1000Ng\n{\n\n\t/* anonymous namespace to host private-like variables and methods */\n\tnamespace\n\t{\n\n\t\t/* ########################### PRIVATE VARIABLES ################################# */\n\n\t\t/* SPI select pin and interrupt pin*/\n\t\tuint8_t _ss = 0xff;\n\t\tuint8_t _irq = 0xff;\n\t\tuint8_t _rst = 0xff;\n\n\t\t/* IRQ callbacks */\n\t\tvoid (*_handleSent)(void) = nullptr;\n\t\tvoid (*_handleError)(void) = nullptr;\n\t\tvoid (*_handleReceived)(void) = nullptr;\n\t\tvoid (*_handleReceiveFailed)(void) = nullptr;\n\t\tvoid (*_handleReceiveTimeout)(void) = nullptr;\n\t\tvoid (*_handleReceiveTimestampAvailable)(void) = nullptr;\n\n\t\t/* registers */\n\t\tbyte _syscfg[LEN_SYS_CFG];\n\t\tbyte _sysctrl[LEN_SYS_CTRL];\n\t\tbyte _sysstatus[LEN_SYS_STATUS];\n\t\tbyte _txfctrl[LEN_TX_FCTRL];\n\t\tbyte _sysmask[LEN_SYS_MASK];\n\t\tbyte _chanctrl[LEN_CHAN_CTRL];\n\t\tbyte _networkAndAddress[LEN_PANADR];\n\n\t\t/* Temperature and Voltage monitoring */\n\t\tbyte _vmeas3v3 = 0;\n\t\tbyte _tmeas23C = 0;\n\n\t\t/* Driver Internal State Trackers */\n\t\tbyte _extendedFrameLength;\n\t\tPacSize _pacSize;\n\t\tPulseFrequency _pulseFrequency;\n\t\tDataRate _dataRate;\n\t\tPreambleLength _preambleLength;\n\t\tPreambleCode _preambleCode;\n\t\tChannel _channel;\n\t\tboolean _smartPower;\n\t\tboolean _frameCheck;\n\t\tboolean _debounceClockEnabled = false;\n\t\tboolean _nlos = false;\n\t\tboolean _standardSFD = true;\n\t\tboolean _autoTXPower = true;\n\t\tboolean _autoTCPGDelay = true;\n\t\tboolean _wait4resp = false;\n\t\tuint16_t _antennaTxDelay = 0;\n\t\tuint16_t _antennaRxDelay = 0;\n\n\t\t/* ############################# PRIVATE METHODS ################################### */\n\t\t/*\n\t\t * Write bytes to the DW1000Ng. Single bytes can be written to registers via sub-addressing.\n\t\t * @param cmd\n\t\t * \t\tThe register address (see Chapter 7 in the DW1000Ng user manual).\n\t\t * @param offset\n\t\t *\t\tThe offset to select register sub-parts for writing, or 0x00 to disable\n\t\t * \t\tsub-adressing.\n\t\t * @param data\n\t\t *\t\tThe data array to be written.\n\t\t * @param data_size\n\t\t *\t\tThe number of bytes to be written (take care not to go out of bounds of\n\t\t * \t\tthe register).\n\t\t */\n\t\t// TODO offset really bigger than byte?\n\n\t\tvoid _writeBytesToRegister(byte cmd, uint16_t offset, byte data[], uint16_t data_size)\n\t\t{\n\t\t\tbyte header[3];\n\t\t\tuint8_t headerLen = 1;\n\n\t\t\t// TODO proper error handling: address out of bounds\n\t\t\t// build SPI header\n\t\t\tif (offset == NO_SUB)\n\t\t\t{\n\t\t\t\theader[0] = WRITE | cmd;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\theader[0] = WRITE_SUB | cmd;\n\t\t\t\tif (offset < 128)\n\t\t\t\t{\n\t\t\t\t\theader[1] = (byte)offset;\n\t\t\t\t\theaderLen++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\theader[1] = RW_SUB_EXT | (byte)offset;\n\t\t\t\t\theader[2] = (byte)(offset >> 7);\n\t\t\t\t\theaderLen += 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSPIporting::writeToSPI(_ss, headerLen, header, data_size, data);\n\t\t}\n\n\t\tvoid _writeToRegister(byte cmd, uint16_t offset, uint32_t data, uint16_t data_size)\n\t\t{\n\t\t\tbyte dataBytes[data_size];\n\t\t\tDW1000NgUtils::writeValueToBytes(dataBytes, data, data_size);\n\t\t\t_writeBytesToRegister(cmd, offset, dataBytes, data_size);\n\t\t}\n\n\t\t// Helper to set a single register\n\t\tvoid _writeByte(byte cmd, uint16_t offset, byte data)\n\t\t{\n\t\t\t_writeBytesToRegister(cmd, offset, &data, 1);\n\t\t}\n\n\t\t/*\n\t\t * Read bytes from the DW1000Ng. Number of bytes depend on register length.\n\t\t * @param cmd\n\t\t * \t\tThe register address (see Chapter 7 in the DW1000Ng user manual).\n\t\t * @param data\n\t\t *\t\tThe data array to be read into.\n\t\t * @param n\n\t\t *\t\tThe number of bytes expected to be received.\n\t\t */\n\t\t// TODO incomplete doc\n\t\tvoid _readBytes(byte cmd, uint16_t offset, byte data[], uint16_t data_size)\n\t\t{\n\t\t\tbyte header[3];\n\t\t\tuint8_t headerLen = 1;\n\n\t\t\t// build SPI header\n\t\t\tif (offset == NO_SUB)\n\t\t\t{\n\t\t\t\theader[0] = READ | cmd;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\theader[0] = READ_SUB | cmd;\n\t\t\t\tif (offset < 128)\n\t\t\t\t{\n\t\t\t\t\theader[1] = (byte)offset;\n\t\t\t\t\theaderLen++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\theader[1] = RW_SUB_EXT | (byte)offset;\n\t\t\t\t\theader[2] = (byte)(offset >> 7);\n\t\t\t\t\theaderLen += 2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSPIporting::readFromSPI(_ss, headerLen, header, data_size, data);\n\t\t}\n\n\t\t// always 4 bytes\n\t\t// TODO why always 4 bytes? can be different, see p. 58 table 10 otp memory map\n\t\tvoid _readBytesOTP(uint16_t address, byte data[])\n\t\t{\n\t\t\tbyte addressBytes[LEN_OTP_ADDR];\n\n\t\t\t// p60 - 6.3.3 Reading a value from OTP memory\n\t\t\t// bytes of address\n\t\t\taddressBytes[0] = (address & 0xFF);\n\t\t\taddressBytes[1] = ((address >> 8) & 0xFF);\n\t\t\t// set address\n\t\t\t_writeBytesToRegister(OTP_IF, OTP_ADDR_SUB, addressBytes, LEN_OTP_ADDR);\n\t\t\t// switch into read mode\n\t\t\t_writeByte(OTP_IF, OTP_CTRL_SUB, 0x03); // OTPRDEN | OTPREAD\n\t\t\t_writeByte(OTP_IF, OTP_CTRL_SUB, 0x01); // OTPRDEN\n\t\t\t// read value/block - 4 bytes\n\t\t\t_readBytes(OTP_IF, OTP_RDAT_SUB, data, LEN_OTP_RDAT);\n\t\t\t// end read mode\n\t\t\t_writeByte(OTP_IF, OTP_CTRL_SUB, 0x00);\n\t\t}\n\n\t\tvoid _writeBitToRegister(byte bitRegister, uint16_t RegisterOffset, uint16_t bitRegister_LEN, uint16_t selectedBit, boolean value)\n\t\t{\n\t\t\tuint16_t idx;\n\t\t\tuint8_t bitPosition;\n\n\t\t\tidx = selectedBit / 8;\n\t\t\tif (idx >= bitRegister_LEN)\n\t\t\t{\n\t\t\t\treturn; // TODO proper error handling: out of bounds\n\t\t\t}\n\t\t\tbyte targetByte;\n\t\t\tmemset(&targetByte, 0, 1);\n\t\t\tbitPosition = selectedBit % 8;\n\t\t\t_readBytes(bitRegister, RegisterOffset + idx, &targetByte, 1);\n\n\t\t\tvalue ? bitSet(targetByte, bitPosition) : bitClear(targetByte, bitPosition);\n\n\t\t\tif (RegisterOffset == NO_SUB)\n\t\t\t\tRegisterOffset = 0x00;\n\n\t\t\t_writeBytesToRegister(bitRegister, RegisterOffset + idx, &targetByte, 1);\n\t\t}\n\n\t\tvoid _enableClock(byte clock)\n\t\t{\n\t\t\tbyte pmscctrl0[LEN_PMSC_CTRL0];\n\t\t\tmemset(pmscctrl0, 0, LEN_PMSC_CTRL0);\n\t\t\t_readBytes(PMSC, PMSC_CTRL0_SUB, pmscctrl0, LEN_PMSC_CTRL0);\n\t\t\tif (clock == SYS_AUTO_CLOCK)\n\t\t\t{\n\t\t\t\tpmscctrl0[0] = SYS_AUTO_CLOCK;\n\t\t\t\tpmscctrl0[1] &= 0xFE;\n\t\t\t}\n\t\t\telse if (clock == SYS_XTI_CLOCK)\n\t\t\t{\n\t\t\t\tpmscctrl0[0] &= 0xFC;\n\t\t\t\tpmscctrl0[0] |= SYS_XTI_CLOCK;\n\t\t\t}\n\t\t\telse if (clock == SYS_PLL_CLOCK)\n\t\t\t{\n\t\t\t\tpmscctrl0[0] &= 0xFC;\n\t\t\t\tpmscctrl0[0] |= SYS_PLL_CLOCK;\n\t\t\t}\n\t\t\telse if (clock == TX_PLL_CLOCK)\n\t\t\t{\n\t\t\t\tpmscctrl0[0] &= 0xCF;\n\t\t\t\tpmscctrl0[0] |= TX_PLL_CLOCK;\n\t\t\t}\n\t\t\telse if (clock == LDE_CLOCK)\n\t\t\t{\n\t\t\t\tpmscctrl0[0] = SYS_XTI_CLOCK;\n\t\t\t\tpmscctrl0[1] = 0x03;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO deliver proper warning\n\t\t\t}\n\t\t\t_writeBytesToRegister(PMSC, PMSC_CTRL0_SUB, pmscctrl0, 2);\n\t\t}\n\n\t\t/* Steps used to get Temp and Voltage */\n\t\tvoid _vbatAndTempSteps()\n\t\t{\n\t\t\tbyte step1 = 0x80;\n\t\t\t_writeBytesToRegister(RF_CONF, 0x11, &step1, 1);\n\t\t\tbyte step2 = 0x0A;\n\t\t\t_writeBytesToRegister(RF_CONF, 0x12, &step2, 1);\n\t\t\tbyte step3 = 0x0F;\n\t\t\t_writeBytesToRegister(RF_CONF, 0x12, &step3, 1);\n\t\t\tbyte step4 = 0x01;\n\t\t\t_writeBytesToRegister(TX_CAL, NO_SUB, &step4, 1);\n\t\t\tbyte step5 = 0x00;\n\t\t\t_writeBytesToRegister(TX_CAL, NO_SUB, &step5, 1);\n\t\t}\n\n\t\t/* AGC_TUNE1 - reg:0x23, sub-reg:0x04, table 24 */\n\t\tvoid _agctune1()\n\t\t{\n\t\t\tbyte agctune1[LEN_AGC_TUNE1];\n\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(agctune1, 0x8870, LEN_AGC_TUNE1);\n\t\t\t}\n\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(agctune1, 0x889B, LEN_AGC_TUNE1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(AGC_TUNE, AGC_TUNE1_SUB, agctune1, LEN_AGC_TUNE1);\n\t\t}\n\n\t\t/* AGC_TUNE2 - reg:0x23, sub-reg:0x0C, table 25 */\n\t\tvoid _agctune2()\n\t\t{\n\t\t\tbyte agctune2[LEN_AGC_TUNE2];\n\t\t\tDW1000NgUtils::writeValueToBytes(agctune2, 0x2502A907L, LEN_AGC_TUNE2);\n\t\t\t_writeBytesToRegister(AGC_TUNE, AGC_TUNE2_SUB, agctune2, LEN_AGC_TUNE2);\n\t\t}\n\n\t\t/* AGC_TUNE3 - reg:0x23, sub-reg:0x12, table 26 */\n\t\tvoid _agctune3()\n\t\t{\n\t\t\tbyte agctune3[LEN_AGC_TUNE3];\n\t\t\tDW1000NgUtils::writeValueToBytes(agctune3, 0x0035, LEN_AGC_TUNE3);\n\t\t\t_writeBytesToRegister(AGC_TUNE, AGC_TUNE3_SUB, agctune3, LEN_AGC_TUNE3);\n\t\t}\n\n\t\t/* DRX_TUNE0b - reg:0x27, sub-reg:0x02, table 30 */\n\t\tvoid _drxtune0b()\n\t\t{\n\t\t\tbyte drxtune0b[LEN_DRX_TUNE0b];\n\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t{\n\t\t\t\tif (!_standardSFD)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune0b, 0x0016, LEN_DRX_TUNE0b);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune0b, 0x000A, LEN_DRX_TUNE0b);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_dataRate == DataRate::RATE_850KBPS)\n\t\t\t{\n\t\t\t\tif (!_standardSFD)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune0b, 0x0006, LEN_DRX_TUNE0b);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune0b, 0x0001, LEN_DRX_TUNE0b);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_dataRate == DataRate::RATE_6800KBPS)\n\t\t\t{\n\t\t\t\tif (!_standardSFD)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune0b, 0x0002, LEN_DRX_TUNE0b);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune0b, 0x0001, LEN_DRX_TUNE0b);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(DRX_TUNE, DRX_TUNE0b_SUB, drxtune0b, LEN_DRX_TUNE0b);\n\t\t}\n\n\t\t/* DRX_TUNE1a - reg:0x27, sub-reg:0x04, table 31 */\n\t\tvoid _drxtune1a()\n\t\t{\n\t\t\tbyte drxtune1a[LEN_DRX_TUNE1a];\n\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune1a, 0x0087, LEN_DRX_TUNE1a);\n\t\t\t}\n\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune1a, 0x008D, LEN_DRX_TUNE1a);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(DRX_TUNE, DRX_TUNE1a_SUB, drxtune1a, LEN_DRX_TUNE1a);\n\t\t}\n\n\t\t/* DRX_TUNE1b - reg:0x27, sub-reg:0x06, table 32 */\n\t\tvoid _drxtune1b()\n\t\t{\n\t\t\tbyte drxtune1b[LEN_DRX_TUNE1b];\n\t\t\tif (_preambleLength == PreambleLength::LEN_1536 || _preambleLength == PreambleLength::LEN_2048 ||\n\t\t\t\t_preambleLength == PreambleLength::LEN_4096)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune1b, 0x0064, LEN_DRX_TUNE1b);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleLength != PreambleLength::LEN_64)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_850KBPS || _dataRate == DataRate::RATE_6800KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune1b, 0x0020, LEN_DRX_TUNE1b);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_6800KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune1b, 0x0010, LEN_DRX_TUNE1b);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\t_writeBytesToRegister(DRX_TUNE, DRX_TUNE1b_SUB, drxtune1b, LEN_DRX_TUNE1b);\n\t\t}\n\n\t\t/* DRX_TUNE2 - reg:0x27, sub-reg:0x08, table 33 */\n\t\tvoid _drxtune2()\n\t\t{\n\t\t\tbyte drxtune2[LEN_DRX_TUNE2];\n\t\t\tif (_pacSize == PacSize::SIZE_8)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune2, 0x311A002DL, LEN_DRX_TUNE2);\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune2, 0x313B006BL, LEN_DRX_TUNE2);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_pacSize == PacSize::SIZE_16)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune2, 0x331A0052L, LEN_DRX_TUNE2);\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune2, 0x333B00BEL, LEN_DRX_TUNE2);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_pacSize == PacSize::SIZE_32)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune2, 0x351A009AL, LEN_DRX_TUNE2);\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune2, 0x353B015EL, LEN_DRX_TUNE2);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_pacSize == PacSize::SIZE_64)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune2, 0x371A011DL, LEN_DRX_TUNE2);\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune2, 0x373B0296L, LEN_DRX_TUNE2);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(DRX_TUNE, DRX_TUNE2_SUB, drxtune2, LEN_DRX_TUNE2);\n\t\t}\n\n\t\t/* DRX_TUNE4H - reg:0x27, sub-reg:0x26, table 34 */\n\t\tvoid _drxtune4H()\n\t\t{\n\t\t\tbyte drxtune4H[LEN_DRX_TUNE4H];\n\t\t\tif (_preambleLength == PreambleLength::LEN_64)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune4H, 0x0010, LEN_DRX_TUNE4H);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune4H, 0x0028, LEN_DRX_TUNE4H);\n\t\t\t}\n\t\t\t_writeBytesToRegister(DRX_TUNE, DRX_TUNE4H_SUB, drxtune4H, LEN_DRX_TUNE4H);\n\t\t}\n\n\t\t/* LDE_CFG1 - reg 0x2E, sub-reg:0x0806 */\n\t\tvoid _ldecfg1()\n\t\t{\n\t\t\tbyte ldecfg1[LEN_LDE_CFG1];\n\t\t\t_nlos == true ? DW1000NgUtils::writeValueToBytes(ldecfg1, 0x7, LEN_LDE_CFG1) : DW1000NgUtils::writeValueToBytes(ldecfg1, 0xD, LEN_LDE_CFG1);\n\t\t\t_writeBytesToRegister(LDE_IF, LDE_CFG1_SUB, ldecfg1, LEN_LDE_CFG1);\n\t\t}\n\n\t\t/* LDE_CFG2 - reg 0x2E, sub-reg:0x1806, table 50 */\n\t\tvoid _ldecfg2()\n\t\t{\n\t\t\tbyte ldecfg2[LEN_LDE_CFG2];\n\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t{\n\t\t\t\t_nlos == true ? DW1000NgUtils::writeValueToBytes(ldecfg2, 0x0003, LEN_LDE_CFG2) : DW1000NgUtils::writeValueToBytes(ldecfg2, 0x1607, LEN_LDE_CFG2);\n\t\t\t}\n\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(ldecfg2, 0x0607, LEN_LDE_CFG2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(LDE_IF, LDE_CFG2_SUB, ldecfg2, LEN_LDE_CFG2);\n\t\t}\n\n\t\t/* LDE_REPC - reg 0x2E, sub-reg:0x2804, table 51 */\n\t\tvoid _lderepc()\n\t\t{\n\t\t\tbyte lderepc[LEN_LDE_REPC];\n\t\t\tif (_preambleCode == PreambleCode::CODE_1 || _preambleCode == PreambleCode::CODE_2)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x5998 >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x5998, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_3 || _preambleCode == PreambleCode::CODE_8)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x51EA >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x51EA, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_4)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x428E >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x428E, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_5)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x451E >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x451E, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_6)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x2E14 >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x2E14, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_7)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x8000 >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x8000, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_9)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x28F4 >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x28F4, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_10 || _preambleCode == PreambleCode::CODE_17)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x3332 >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x3332, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_11)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x3AE0 >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x3AE0, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_12)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x3D70 >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x3D70, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_18 || _preambleCode == PreambleCode::CODE_19)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x35C2 >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x35C2, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_20)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x47AE >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x47AE, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\n\t\t\t_writeBytesToRegister(LDE_IF, LDE_REPC_SUB, lderepc, LEN_LDE_REPC);\n\t\t}\n\n\t\t/* TX_POWER (enabled smart transmit power control) - reg:0x1E, tables 19-20\n\t\t * These values are based on a typical IC and an assumed IC to antenna loss of 1.5 dB with a 0 dBi antenna */\n\t\tvoid _txpowertune()\n\t\t{\n\t\t\tbyte txpower[LEN_TX_POWER];\n\t\t\tif (_channel == Channel::CHANNEL_1 || _channel == Channel::CHANNEL_2)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x1B153555L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x15355575L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x55555555L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x75757575L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x0D072747L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x07274767L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x47474747L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x67676767L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_3)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x150F2F4FL, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x0F2F4F6FL, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x4F4F4F4FL, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x6F6F6F6FL, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x0B2B4B6BL, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x2B4B6B8BL, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x6B6B6B6BL, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x8B8B8B8BL, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_4)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x1F1F1F3FL, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x1F1F3F5FL, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x3F3F3F3FL, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x5F5F5F5FL, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x1A3A5A7AL, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x3A5A7A9AL, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x7A7A7A7AL, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x9A9A9A9AL, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_5)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x140E0828L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x0E082848L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x28282828L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x48484848L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x05254565L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x25456585L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x65656565L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x85858585L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_7)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x12325272L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x32527292L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x72727272L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x92929292L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x315191B1L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x5171B1D1L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0xB1B1B1B1L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0xD1D1D1D1L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(TX_POWER, NO_SUB, txpower, LEN_TX_POWER);\n\t\t}\n\n\t\t/* RF_RXCTRLH - reg:0x28, sub-reg:0x0B, table 37 */\n\t\tvoid _rfrxctrlh()\n\t\t{\n\t\t\tbyte rfrxctrlh[LEN_RF_RXCTRLH];\n\t\t\tif (_channel != Channel::CHANNEL_4 && _channel != Channel::CHANNEL_7)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(rfrxctrlh, 0xD8, LEN_RF_RXCTRLH);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(rfrxctrlh, 0xBC, LEN_RF_RXCTRLH);\n\t\t\t}\n\t\t\t_writeBytesToRegister(RF_CONF, RF_RXCTRLH_SUB, rfrxctrlh, LEN_RF_RXCTRLH);\n\t\t}\n\n\t\t/* RX_TXCTRL - reg:0x28, sub-reg:0x0C */\n\t\tvoid _rftxctrl()\n\t\t{\n\t\t\tbyte rftxctrl[LEN_RF_TXCTRL];\n\t\t\tif (_channel == Channel::CHANNEL_1)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(rftxctrl, 0x00005C40L, LEN_RF_TXCTRL);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_2)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(rftxctrl, 0x00045CA0L, LEN_RF_TXCTRL);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_3)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(rftxctrl, 0x00086CC0L, LEN_RF_TXCTRL);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_4)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(rftxctrl, 0x00045C80L, LEN_RF_TXCTRL);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_5)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(rftxctrl, 0x001E3FE0L, LEN_RF_TXCTRL);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_7)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(rftxctrl, 0x001E7DE0L, LEN_RF_TXCTRL);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(RF_CONF, RF_TXCTRL_SUB, rftxctrl, LEN_RF_TXCTRL);\n\t\t}\n\n\t\t/* TC_PGDELAY - reg:0x2A, sub-reg:0x0B, table 40 */\n\t\tvoid _tcpgdelaytune()\n\t\t{\n\t\t\tbyte tcpgdelay[LEN_TC_PGDELAY];\n\t\t\tif (_channel == Channel::CHANNEL_1)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(tcpgdelay, 0xC9, LEN_TC_PGDELAY);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_2)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(tcpgdelay, 0xC2, LEN_TC_PGDELAY);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_3)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(tcpgdelay, 0xC5, LEN_TC_PGDELAY);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_4)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(tcpgdelay, 0x95, LEN_TC_PGDELAY);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_5)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(tcpgdelay, 0xC0, LEN_TC_PGDELAY);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_7)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(tcpgdelay, 0x93, LEN_TC_PGDELAY);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(TX_CAL, TC_PGDELAY_SUB, tcpgdelay, LEN_TC_PGDELAY);\n\t\t}\n\n\t\t// FS_PLLCFG and FS_PLLTUNE - reg:0x2B, sub-reg:0x07-0x0B, tables 43-44\n\t\tvoid _fspll()\n\t\t{\n\t\t\tbyte fspllcfg[LEN_FS_PLLCFG];\n\t\t\tbyte fsplltune[LEN_FS_PLLTUNE];\n\t\t\tif (_channel == Channel::CHANNEL_1)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fspllcfg, 0x09000407L, LEN_FS_PLLCFG);\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fsplltune, 0x1E, LEN_FS_PLLTUNE);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_2 || _channel == Channel::CHANNEL_4)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fspllcfg, 0x08400508L, LEN_FS_PLLCFG);\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fsplltune, 0x26, LEN_FS_PLLTUNE);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_3)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fspllcfg, 0x08401009L, LEN_FS_PLLCFG);\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fsplltune, 0x56, LEN_FS_PLLTUNE);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_5 || _channel == Channel::CHANNEL_7)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fspllcfg, 0x0800041DL, LEN_FS_PLLCFG);\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fsplltune, 0xBE, LEN_FS_PLLTUNE);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(FS_CTRL, FS_PLLTUNE_SUB, fsplltune, LEN_FS_PLLTUNE);\n\t\t\t_writeBytesToRegister(FS_CTRL, FS_PLLCFG_SUB, fspllcfg, LEN_FS_PLLCFG);\n\t\t}\n\n\t\tvoid _tune()\n\t\t{\n\t\t\t// these registers are going to be tuned/configured\n\t\t\t_agctune1();\n\t\t\t_agctune2();\n\t\t\t_agctune3();\n\t\t\t_drxtune0b();\n\t\t\t_drxtune1a();\n\t\t\t_drxtune1b();\n\t\t\t_drxtune2();\n\t\t\t_drxtune4H();\n\t\t\t_ldecfg1();\n\t\t\t_ldecfg2();\n\t\t\t_lderepc();\n\t\t\tif (_autoTXPower)\n\t\t\t\t_txpowertune();\n\t\t\t_rfrxctrlh();\n\t\t\t_rftxctrl();\n\t\t\tif (_autoTCPGDelay)\n\t\t\t\t_tcpgdelaytune();\n\t\t\t_fspll();\n\t\t}\n\n\t\tvoid _writeNetworkIdAndDeviceAddress()\n\t\t{\n\t\t\t_writeBytesToRegister(PANADR, NO_SUB, _networkAndAddress, LEN_PANADR);\n\t\t}\n\n\t\tvoid _writeSystemConfigurationRegister()\n\t\t{\n\t\t\t_writeBytesToRegister(SYS_CFG, NO_SUB, _syscfg, LEN_SYS_CFG);\n\t\t}\n\n\t\tvoid _writeChannelControlRegister()\n\t\t{\n\t\t\t_writeBytesToRegister(CHAN_CTRL, NO_SUB, _chanctrl, LEN_CHAN_CTRL);\n\t\t}\n\n\t\tvoid _writeTransmitFrameControlRegister()\n\t\t{\n\t\t\t_writeBytesToRegister(TX_FCTRL, NO_SUB, _txfctrl, LEN_TX_FCTRL);\n\t\t}\n\n\t\tvoid _writeSystemEventMaskRegister()\n\t\t{\n\t\t\t_writeBytesToRegister(SYS_MASK, NO_SUB, _sysmask, LEN_SYS_MASK);\n\t\t}\n\n\t\tvoid _writeAntennaDelayRegisters()\n\t\t{\n\t\t\tbyte antennaTxDelayBytes[2];\n\t\t\tbyte antennaRxDelayBytes[2];\n\t\t\tDW1000NgUtils::writeValueToBytes(antennaTxDelayBytes, _antennaTxDelay, LEN_TX_ANTD);\n\t\t\tDW1000NgUtils::writeValueToBytes(antennaRxDelayBytes, _antennaRxDelay, LEN_LDE_RXANTD);\n\t\t\t_writeBytesToRegister(TX_ANTD, NO_SUB, antennaTxDelayBytes, LEN_TX_ANTD);\n\t\t\t_writeBytesToRegister(LDE_IF, LDE_RXANTD_SUB, antennaRxDelayBytes, LEN_LDE_RXANTD);\n\t\t}\n\n\t\tvoid _writeConfiguration()\n\t\t{\n\t\t\t// write all configurations back to device\n\t\t\t_writeSystemConfigurationRegister();\n\t\t\t_writeChannelControlRegister();\n\t\t\t_writeTransmitFrameControlRegister();\n\t\t}\n\n\t\tvoid _useExtendedFrameLength(boolean val)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, PHR_MODE_0_BIT, val);\n\t\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, PHR_MODE_1_BIT, val);\n\t\t}\n\n\t\tvoid _setReceiverAutoReenable(boolean val)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, RXAUTR_BIT, val);\n\t\t}\n\n\t\tvoid _useFrameCheck(boolean val)\n\t\t{\n\t\t\t_frameCheck = val;\n\t\t}\n\n\t\tvoid _setNlosOptimization(boolean val)\n\t\t{\n\t\t\t_nlos = val;\n\t\t\tif (_nlos)\n\t\t\t{\n\t\t\t\t_ldecfg1();\n\t\t\t\t_ldecfg2();\n\t\t\t}\n\t\t}\n\n\t\tvoid _useSmartPower(boolean smartPower)\n\t\t{\n\t\t\t_smartPower = smartPower;\n\t\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, DIS_STXP_BIT, !smartPower);\n\t\t\t_writeSystemConfigurationRegister();\n\t\t\tif (_autoTXPower)\n\t\t\t\t_txpowertune();\n\t\t}\n\n\t\tvoid _setSFDMode(SFDMode mode)\n\t\t{\n\t\t\tswitch (mode)\n\t\t\t{\n\t\t\tcase SFDMode::STANDARD_SFD:\n\t\t\t\tDW1000NgUtils::setBit(_chanctrl, LEN_CHAN_CTRL, DWSFD_BIT, false);\n\t\t\t\tDW1000NgUtils::setBit(_chanctrl, LEN_CHAN_CTRL, TNSSFD_BIT, false);\n\t\t\t\tDW1000NgUtils::setBit(_chanctrl, LEN_CHAN_CTRL, RNSSFD_BIT, false);\n\t\t\t\t_standardSFD = true;\n\t\t\t\tbreak;\n\t\t\tcase SFDMode::DECAWAVE_SFD:\n\t\t\t\tDW1000NgUtils::setBit(_chanctrl, LEN_CHAN_CTRL, DWSFD_BIT, true);\n\t\t\t\tDW1000NgUtils::setBit(_chanctrl, LEN_CHAN_CTRL, TNSSFD_BIT, true);\n\t\t\t\tDW1000NgUtils::setBit(_chanctrl, LEN_CHAN_CTRL, RNSSFD_BIT, true);\n\t\t\t\t_standardSFD = false;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn; // TODO Proper error handling\n\t\t\t}\n\t\t}\n\n\t\tvoid _setChannel(Channel channel)\n\t\t{\n\t\t\tbyte chan = static_cast<byte>(channel);\n\t\t\tchan &= 0xF;\n\t\t\t_chanctrl[0] = ((chan | (chan << 4)) & 0xFF);\n\n\t\t\t_channel = channel;\n\t\t}\n\n\t\tvoid _setDataRate(DataRate data_rate)\n\t\t{\n\t\t\tbyte rate = static_cast<byte>(data_rate);\n\t\t\trate &= 0x03;\n\t\t\t_txfctrl[1] &= 0x83;\n\t\t\t_txfctrl[1] |= (byte)((rate << 5) & 0xFF);\n\t\t\t// special 110kbps flag\n\t\t\tif (data_rate == DataRate::RATE_110KBPS)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, RXM110K_BIT, true);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, RXM110K_BIT, false);\n\t\t\t}\n\t\t\t_dataRate = data_rate;\n\t\t}\n\n\t\tvoid _setPulseFrequency(PulseFrequency frequency)\n\t\t{\n\t\t\tbyte freq = static_cast<byte>(frequency);\n\t\t\tfreq &= 0x03;\n\t\t\t_txfctrl[2] &= 0xFC;\n\t\t\t_txfctrl[2] |= (byte)(freq & 0xFF);\n\t\t\t_chanctrl[2] &= 0xF3;\n\t\t\t_chanctrl[2] |= (byte)((freq << 2) & 0xFF);\n\n\t\t\t_pulseFrequency = frequency;\n\t\t}\n\n\t\tvoid _setPreambleLength(PreambleLength preamble_length)\n\t\t{\n\t\t\tbyte prealen = static_cast<byte>(preamble_length);\n\t\t\tprealen &= 0x0F;\n\t\t\t_txfctrl[2] &= 0xC3;\n\t\t\t_txfctrl[2] |= (byte)((prealen << 2) & 0xFF);\n\n\t\t\tswitch (preamble_length)\n\t\t\t{\n\t\t\tcase PreambleLength::LEN_64:\n\t\t\t\t_pacSize = PacSize::SIZE_8;\n\t\t\t\tbreak;\n\t\t\tcase PreambleLength::LEN_128:\n\t\t\t\t_pacSize = PacSize::SIZE_8;\n\t\t\t\tbreak;\n\t\t\tcase PreambleLength::LEN_256:\n\t\t\t\t_pacSize = PacSize::SIZE_16;\n\t\t\t\tbreak;\n\t\t\tcase PreambleLength::LEN_512:\n\t\t\t\t_pacSize = PacSize::SIZE_16;\n\t\t\t\tbreak;\n\t\t\tcase PreambleLength::LEN_1024:\n\t\t\t\t_pacSize = PacSize::SIZE_32;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t_pacSize = PacSize::SIZE_64; // In case of 1536, 2048 or 4096 preamble length.\n\t\t\t}\n\n\t\t\t_preambleLength = preamble_length;\n\t\t}\n\n\t\tvoid _setPreambleCode(PreambleCode preamble_code)\n\t\t{\n\t\t\tbyte preacode = static_cast<byte>(preamble_code);\n\t\t\tpreacode &= 0x1F;\n\t\t\t_chanctrl[2] &= 0x3F;\n\t\t\t_chanctrl[2] |= ((preacode << 6) & 0xFF);\n\t\t\t_chanctrl[3] = 0x00;\n\t\t\t_chanctrl[3] = ((((preacode >> 2) & 0x07) | (preacode << 3)) & 0xFF);\n\n\t\t\t_preambleCode = preamble_code;\n\t\t}\n\n\t\tboolean _checkPreambleCodeValidity()\n\t\t{\n\t\t\tbyte preacode = static_cast<byte>(_preambleCode);\n\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t{\n\t\t\t\tfor (auto i = 0; i < 2; i++)\n\t\t\t\t{\n\t\t\t\t\tif (preacode == preamble_validity_matrix_PRF16[(int)_channel][i])\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t{\n\t\t\t\tfor (auto i = 0; i < 4; i++)\n\t\t\t\t{\n\t\t\t\t\tif (preacode == preamble_validity_matrix_PRF64[(int)_channel][i])\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn false; // TODO Proper error handling\n\t\t\t}\n\t\t}\n\n\t\tvoid _setValidPreambleCode()\n\t\t{\n\t\t\tPreambleCode preamble_code;\n\n\t\t\tswitch (_channel)\n\t\t\t{\n\t\t\tcase Channel::CHANNEL_1:\n\t\t\t\tpreamble_code = _pulseFrequency == PulseFrequency::FREQ_16MHZ ? PreambleCode::CODE_2 : PreambleCode::CODE_10;\n\t\t\t\tbreak;\n\t\t\tcase Channel::CHANNEL_3:\n\t\t\t\tpreamble_code = _pulseFrequency == PulseFrequency::FREQ_16MHZ ? PreambleCode::CODE_6 : PreambleCode::CODE_10;\n\t\t\t\tbreak;\n\t\t\tcase Channel::CHANNEL_4:\n\t\t\tcase Channel::CHANNEL_7:\n\t\t\t\tpreamble_code = _pulseFrequency == PulseFrequency::FREQ_16MHZ ? PreambleCode::CODE_8 : PreambleCode::CODE_18;\n\t\t\t\tbreak;\n\t\t\tcase Channel::CHANNEL_2:\n\t\t\tcase Channel::CHANNEL_5:\n\t\t\t\tpreamble_code = _pulseFrequency == PulseFrequency::FREQ_16MHZ ? PreambleCode::CODE_3 : PreambleCode::CODE_10;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn; // TODO Proper Error Handling\n\t\t\t}\n\t\t\tbyte preacode = static_cast<byte>(preamble_code);\n\t\t\tpreacode &= 0x1F;\n\t\t\t_chanctrl[2] &= 0x3F;\n\t\t\t_chanctrl[2] |= ((preacode << 6) & 0xFF);\n\t\t\t_chanctrl[3] = 0x00;\n\t\t\t_chanctrl[3] = ((((preacode >> 2) & 0x07) | (preacode << 3)) & 0xFF);\n\n\t\t\t_preambleCode = preamble_code;\n\t\t}\n\n\t\tvoid _setNonStandardSFDLength()\n\t\t{\n\t\t\tswitch (_dataRate)\n\t\t\t{\n\t\t\tcase DataRate::RATE_6800KBPS:\n\t\t\t\t_writeByte(USR_SFD, SFD_LENGTH_SUB, 0x08);\n\t\t\t\tbreak;\n\t\t\tcase DataRate::RATE_850KBPS:\n\t\t\t\t_writeByte(USR_SFD, SFD_LENGTH_SUB, 0x10);\n\t\t\t\tbreak;\n\t\t\tcase DataRate::RATE_110KBPS:\n\t\t\t\t_writeByte(USR_SFD, SFD_LENGTH_SUB, 0x40);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn; // TODO Proper error handling\n\t\t\t}\n\t\t}\n\n\t\tvoid _interruptOnSent(boolean val)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_MASK, TXFRS_BIT, val);\n\t\t}\n\n\t\tvoid _interruptOnReceived(boolean val)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_MASK, RXDFR_BIT, val);\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_MASK, RXFCG_BIT, val);\n\t\t}\n\n\t\tvoid _interruptOnReceiveFailed(boolean val)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_STATUS, RXPHE_BIT, val);\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_STATUS, RXFCE_BIT, val);\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_STATUS, RXRFSL_BIT, val);\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_STATUS, LDEERR_BIT, val);\n\t\t}\n\n\t\tvoid _interruptOnReceiveTimeout(boolean val)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_MASK, RXRFTO_BIT, val);\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_MASK, RXPTO_BIT, val);\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_MASK, RXSFDTO_BIT, val);\n\t\t}\n\n\t\tvoid _interruptOnReceiveTimestampAvailable(boolean val)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_MASK, LDEDONE_BIT, val);\n\t\t}\n\n\t\tvoid _interruptOnAutomaticAcknowledgeTrigger(boolean val)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_MASK, AAT_BIT, val);\n\t\t}\n\n\t\tvoid _manageLDE()\n\t\t{\n\t\t\t// transfer any ldo tune values\n\t\t\tbyte ldoTune[LEN_OTP_RDAT];\n\t\t\tuint16_t LDOTUNE_ADDRESS = 0x04;\n\t\t\t_readBytesOTP(LDOTUNE_ADDRESS, ldoTune); // TODO #define\n\t\t\tif (ldoTune[0] != 0)\n\t\t\t{\n\t\t\t\t// TODO tuning available, copy over to RAM: use OTP_LDO bit\n\t\t\t}\n\t\t\t// tell the chip to load the LDE microcode\n\t\t\t// TODO remove clock-related code (PMSC_CTRL) as handled separately\n\t\t\tbyte pmscctrl0[LEN_PMSC_CTRL0];\n\t\t\tbyte otpctrl[LEN_OTP_CTRL];\n\t\t\tmemset(pmscctrl0, 0, LEN_PMSC_CTRL0);\n\t\t\tmemset(otpctrl, 0, LEN_OTP_CTRL);\n\t\t\t_readBytes(PMSC, PMSC_CTRL0_SUB, pmscctrl0, LEN_PMSC_CTRL0);\n\t\t\t_readBytes(OTP_IF, OTP_CTRL_SUB, otpctrl, LEN_OTP_CTRL);\n\t\t\tpmscctrl0[0] = 0x01;\n\t\t\tpmscctrl0[1] = 0x03;\n\t\t\totpctrl[1] = 0x80;\n\t\t\t_writeBytesToRegister(PMSC, PMSC_CTRL0_SUB, pmscctrl0, 2);\n\t\t\t// uCode\n\t\t\t_enableClock(LDE_CLOCK);\n\t\t\tdelay(5);\n\t\t\t_writeBytesToRegister(OTP_IF, OTP_CTRL_SUB, otpctrl, 2);\n\t\t\tdelay(1);\n\t\t\t_enableClock(SYS_AUTO_CLOCK);\n\t\t\tdelay(5);\n\t\t\tpmscctrl0[0] = 0x00;\n\t\t\tpmscctrl0[1] &= 0x02;\n\t\t\t_writeBytesToRegister(PMSC, PMSC_CTRL0_SUB, pmscctrl0, 2);\n\t\t}\n\n\t\t/* Crystal calibration from OTP (if available)\n\t\t * FS_XTALT - reg:0x2B, sub-reg:0x0E\n\t\t * OTP(one-time-programmable) memory map - table 10 */\n\t\tvoid _fsxtalt()\n\t\t{\n\t\t\tbyte fsxtalt[LEN_FS_XTALT];\n\t\t\tbyte buf_otp[4];\n\t\t\t_readBytesOTP(0x01E, buf_otp); // 0x01E -> byte[0]=XTAL_Trim\n\t\t\tif (buf_otp[0] == 0)\n\t\t\t{\n\t\t\t\t// No trim value available from OTP, use midrange value of 0x10\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fsxtalt, ((0x10 & 0x1F) | 0x60), LEN_FS_XTALT);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fsxtalt, ((buf_otp[0] & 0x1F) | 0x60), LEN_FS_XTALT);\n\t\t\t}\n\t\t\t// write configuration back to chip\n\t\t\t_writeBytesToRegister(FS_CTRL, FS_XTALT_SUB, fsxtalt, LEN_FS_XTALT);\n\t\t}\n\n\t\tvoid _clearReceiveStatus()\n\t\t{\n\t\t\t// clear latched RX bits (i.e. write 1 to clear)\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXDFR_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXFCG_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXPRD_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXSFDD_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXPHD_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, LDEDONE_BIT, true);\n\t\t\t_writeBytesToRegister(SYS_STATUS, NO_SUB, _sysstatus, LEN_SYS_STATUS);\n\t\t}\n\n\t\tvoid _clearReceiveTimestampAvailableStatus()\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, LDEDONE_BIT, true);\n\t\t\t_writeBytesToRegister(SYS_STATUS, NO_SUB, _sysstatus, LEN_SYS_STATUS);\n\t\t}\n\n\t\tvoid _clearReceiveTimeoutStatus()\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXRFTO_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXPTO_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXSFDTO_BIT, true);\n\t\t\t_writeBytesToRegister(SYS_STATUS, NO_SUB, _sysstatus, LEN_SYS_STATUS);\n\t\t}\n\n\t\tvoid _clearReceiveFailedStatus()\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXPHE_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXFCE_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXRFSL_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, AFFREJ_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, LDEERR_BIT, true);\n\t\t\t_writeBytesToRegister(SYS_STATUS, NO_SUB, _sysstatus, LEN_SYS_STATUS);\n\t\t}\n\n\t\tvoid _clearTransmitStatus()\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, AAT_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, TXFRB_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, TXPRS_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, TXPHS_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, TXFRS_BIT, true);\n\t\t\t_writeBytesToRegister(SYS_STATUS, NO_SUB, _sysstatus, LEN_SYS_STATUS);\n\t\t}\n\n\t\tvoid _resetReceiver()\n\t\t{\n\t\t\t/* Set to 0 only bit 28 */\n\t\t\t_writeToRegister(PMSC, PMSC_SOFTRESET_SUB, 0xE0, LEN_PMSC_SOFTRESET);\n\t\t\t/* Set SOFTRESET to all ones */\n\t\t\t_writeToRegister(PMSC, PMSC_SOFTRESET_SUB, 0xF0, LEN_PMSC_SOFTRESET);\n\t\t}\n\n\t\t/* Internal helpers to read configuration */\n\n\t\tvoid _readSystemConfigurationRegister()\n\t\t{\n\t\t\t_readBytes(SYS_CFG, NO_SUB, _syscfg, LEN_SYS_CFG);\n\t\t}\n\n\t\tvoid _readSystemEventStatusRegister()\n\t\t{\n\t\t\t_readBytes(SYS_STATUS, NO_SUB, _sysstatus, LEN_SYS_STATUS);\n\t\t}\n\n\t\tvoid _readNetworkIdAndDeviceAddress()\n\t\t{\n\t\t\t_readBytes(PANADR, NO_SUB, _networkAndAddress, LEN_PANADR);\n\t\t}\n\n\t\tvoid _readSystemEventMaskRegister()\n\t\t{\n\t\t\t_readBytes(SYS_MASK, NO_SUB, _sysmask, LEN_SYS_MASK);\n\t\t}\n\n\t\tvoid _readChannelControlRegister()\n\t\t{\n\t\t\t_readBytes(CHAN_CTRL, NO_SUB, _chanctrl, LEN_CHAN_CTRL);\n\t\t}\n\n\t\tvoid _readTransmitFrameControlRegister()\n\t\t{\n\t\t\t_readBytes(TX_FCTRL, NO_SUB, _txfctrl, LEN_TX_FCTRL);\n\t\t}\n\n\t\tboolean _isTransmitDone()\n\t\t{\n\t\t\treturn DW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, TXFRS_BIT);\n\t\t}\n\n\t\tboolean _isReceiveTimestampAvailable()\n\t\t{\n\t\t\treturn DW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, LDEDONE_BIT);\n\t\t}\n\n\t\tboolean _isReceiveDone()\n\t\t{\n\t\t\tif (_frameCheck)\n\t\t\t{\n\t\t\t\treturn (DW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXFCG_BIT) &&\n\t\t\t\t\t\tDW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXDFR_BIT));\n\t\t\t}\n\t\t\treturn DW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXDFR_BIT);\n\t\t}\n\n\t\tboolean _isReceiveFailed()\n\t\t{\n\t\t\treturn (DW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXPHE_BIT) ||\n\t\t\t\t\tDW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXFCE_BIT) ||\n\t\t\t\t\tDW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXRFSL_BIT) ||\n\t\t\t\t\tDW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, LDEERR_BIT));\n\t\t}\n\n\t\tboolean _isReceiveTimeout()\n\t\t{\n\t\t\treturn (DW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXRFTO_BIT) ||\n\t\t\t\t\tDW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXPTO_BIT) ||\n\t\t\t\t\tDW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXSFDTO_BIT));\n\t\t}\n\n\t\tboolean _isClockProblem()\n\t\t{\n\t\t\treturn (DW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, CLKPLL_LL_BIT) ||\n\t\t\t\t\tDW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RFPLL_LL_BIT));\n\t\t}\n\n\t\tvoid _disableSequencing()\n\t\t{\n\t\t\t_enableClock(SYS_XTI_CLOCK);\n\t\t\tbyte zero[2];\n\t\t\tDW1000NgUtils::writeValueToBytes(zero, 0x0000, 2);\n\t\t\t_writeBytesToRegister(PMSC, PMSC_CTRL1_SUB, zero, 2); // To re-enable write 0xE7\n\t\t}\n\n\t\tvoid _configureRFTransmitPowerSpectrumTestMode()\n\t\t{\n\t\t\t/* Enabled TXFEN, PLLFEN, LDOFEN and set TXRXSW to TX */\n\t\t\tbyte enable_mask[4];\n\t\t\tDW1000NgUtils::writeValueToBytes(enable_mask, 0x005FFF00, LEN_RX_CONF_SUB);\n\t\t\t_writeBytesToRegister(RF_CONF, RF_CONF_SUB, enable_mask, LEN_RX_CONF_SUB);\n\t\t}\n\n\t\tvoid _uploadConfigToAON()\n\t\t{\n\t\t\t/* Write 1 in UPL_CFG_BIT */\n\t\t\t_writeToRegister(AON, AON_CTRL_SUB, 0x04, LEN_AON_CTRL);\n\t\t\t/* Clear the register */\n\t\t\t_writeToRegister(AON, AON_CTRL_SUB, 0x00, LEN_AON_CTRL);\n\t\t}\n\t}\n\n\t/* ####################### PUBLIC ###################### */\n\n\tvoid initialize(uint8_t ss, uint8_t irq, uint8_t rst)\n\t{\n\t\t// generous initial init/wake-up-idle delay\n\t\tdelay(5);\n\t\t_ss = ss;\n\t\t_irq = irq;\n\t\t_rst = rst;\n\n\t\tif (rst != 0xff)\n\t\t{\n\t\t\t// DW1000 data sheet v2.08 Â§5.6.1 page 20, the RSTn pin should not be driven high but left floating.\n\t\t\tpinMode(_rst, INPUT);\n\t\t}\n\n\t\tSPIporting::SPIinit();\n\t\t// pin and basic member setup\n\t\t// attach interrupt\n\t\t// TODO throw error if pin is not a interrupt pin\n\t\tif (_irq != 0xff)\n\t\t{\n\t\t\tattachInterrupt(digitalPinToInterrupt(_irq), interruptServiceRoutine, RISING);\n\t\t\t// attachInterrupt(digitalPinToInterrupt(_irq), interruptServiceRoutine, FALLING);\n\t\t}\n\n\t\tSPIporting::SPIselect(_ss, _irq);\n\t\t// reset chip (either soft or hard)\n\t\treset();\n\n\t\tSPIporting::setSPIspeed(SPIClock::SLOW);\n\t\t_enableClock(SYS_XTI_CLOCK);\n\t\tdelay(5);\n\n\t\t// Configure the CPLL lock detect\n\t\t_writeBitToRegister(EXT_SYNC, EC_CTRL_SUB, LEN_EC_CTRL, PLLLDT_BIT, true);\n\n\t\t// Configure XTAL trim\n\t\t_fsxtalt();\n\n\t\t// load LDE micro-code\n\t\t_manageLDE();\n\n\t\t// read the temp and vbat readings from OTP that were recorded during production test\n\t\t// see 6.3.1 OTP memory map\n\t\tbyte buf_otp[4];\n\t\t_readBytesOTP(0x008, buf_otp); // the stored 3.3 V reading\n\t\t_vmeas3v3 = buf_otp[0];\n\t\t// Serial.printf(\"_vmeas3v3=%d\\r\\n\", _vmeas3v3);\n\t\t_readBytesOTP(0x009, buf_otp); // the stored 23C reading\n\t\t_tmeas23C = buf_otp[0];\n\t\t// Serial.printf(\"_tmeas23C=%d\\r\\n\", _tmeas23C);\n\n\t\t_enableClock(SYS_AUTO_CLOCK);\n\t\tdelay(5);\n\t\tSPIporting::setSPIspeed(SPIClock::FAST);\n\n\t\t_readNetworkIdAndDeviceAddress();\n\t\t_readSystemConfigurationRegister();\n\t\t_readChannelControlRegister();\n\t\t_readTransmitFrameControlRegister();\n\t\t_readSystemEventMaskRegister();\n\n\t\t/* Cleared AON:CFG1(0x2C:0x0A) for proper operation of deepSleep */\n\t\t_writeToRegister(AON, AON_CFG1_SUB, 0x00, LEN_AON_CFG1);\n\t}\n\n\tvoid initializeNoInterrupt(uint8_t ss, uint8_t rst)\n\t{\n\t\tinitialize(ss, 0xff, rst);\n\t}\n\n\t/* callback handler management. */\n\tvoid attachErrorHandler(void (*handleError)(void))\n\t{\n\t\t_handleError = handleError;\n\t}\n\n\tvoid attachSentHandler(void (*handleSent)(void))\n\t{\n\t\t_handleSent = handleSent;\n\t}\n\n\tvoid attachReceivedHandler(void (*handleReceived)(void))\n\t{\n\t\t_handleReceived = handleReceived;\n\t}\n\n\tvoid attachReceiveFailedHandler(void (*handleReceiveFailed)(void))\n\t{\n\t\t_handleReceiveFailed = handleReceiveFailed;\n\t}\n\n\tvoid attachReceiveTimeoutHandler(void (*handleReceiveTimeout)(void))\n\t{\n\t\t_handleReceiveTimeout = handleReceiveTimeout;\n\t}\n\n\tvoid attachReceiveTimestampAvailableHandler(void (*handleReceiveTimestampAvailable)(void))\n\t{\n\t\t_handleReceiveTimestampAvailable = handleReceiveTimestampAvailable;\n\t}\n\n\tvoid interruptServiceRoutine()\n\t{\n\t\t// Serial.printf(\"test----------------------------0\\r\\n\");\n\t\t// read current status and handle via callbacks\n\t\t_readSystemEventStatusRegister();\n\t\tif (_isClockProblem() /* TODO and others */ && _handleError != 0)\n\t\t{\n\t\t\t(*_handleError)();\n\t\t\t// Serial.printf(\"interrupt----------------------------1\\r\\n\");\n\t\t}\n\t\tif (_isTransmitDone())\n\t\t{\n\t\t\t_clearTransmitStatus();\n\t\t\tif (_handleSent != nullptr)\n\t\t\t{\n\t\t\t\t(*_handleSent)();\n\t\t\t\t// Serial.printf(\"interrupt----------------------------2\\r\\n\");\n\t\t\t}\n\t\t}\n\t\tif (_isReceiveTimestampAvailable())\n\t\t{\n\t\t\t_clearReceiveTimestampAvailableStatus();\n\t\t\tif (_handleReceiveTimestampAvailable != nullptr)\n\t\t\t{\n\t\t\t\t(*_handleReceiveTimestampAvailable)();\n\t\t\t\t// Serial.printf(\"interrupt----------------------------3\\r\\n\");\n\t\t\t}\n\t\t}\n\t\tif (_isReceiveFailed())\n\t\t{\n\t\t\t_clearReceiveFailedStatus();\n\t\t\tforceTRxOff();\n\t\t\t_resetReceiver();\n\t\t\tif (_handleReceiveFailed != nullptr)\n\t\t\t{\n\t\t\t\t(*_handleReceiveFailed)();\n\t\t\t\t// Serial.printf(\"interrupt----------------------------4\\r\\n\");\n\t\t\t}\n\t\t}\n\t\telse if (_isReceiveTimeout())\n\t\t{\n\t\t\t_clearReceiveTimeoutStatus();\n\t\t\tforceTRxOff();\n\t\t\t_resetReceiver();\n\t\t\tif (_handleReceiveTimeout != nullptr)\n\t\t\t{\n\t\t\t\t(*_handleReceiveTimeout)();\n\t\t\t\t// Serial.printf(\"interrupt----------------------------5\\r\\n\");\n\t\t\t}\n\t\t}\n\t\telse if (_isReceiveDone())\n\t\t{\n\t\t\t_clearReceiveStatus();\n\t\t\tif (_handleReceived != nullptr)\n\t\t\t{\n\t\t\t\t(*_handleReceived)();\n\t\t\t\t// Serial.printf(\"interrupt----------------------------6\\r\\n\");\n\t\t\t}\n\t\t}\n\t\t// Latched bits in status register are reset by writing 1 to them\n\t\tmemset(_sysstatus, 0xff, LEN_SYS_STATUS);\n\t\t_writeBytesToRegister(SYS_STATUS, NO_SUB, _sysstatus, LEN_SYS_STATUS);\n\t}\n\n\tboolean isTransmitDone()\n\t{\n\t\t_readSystemEventStatusRegister();\n\t\treturn _isTransmitDone();\n\t}\n\n\tvoid clearTransmitStatus()\n\t{\n\t\t_clearTransmitStatus();\n\t}\n\n\tboolean isReceiveDone()\n\t{\n\t\t_readSystemEventStatusRegister();\n\t\treturn _isReceiveDone();\n\t}\n\n\tvoid clearReceiveStatus()\n\t{\n\t\t_clearReceiveStatus();\n\t}\n\n\tboolean isReceiveFailed()\n\t{\n\t\t_readSystemEventStatusRegister();\n\t\treturn _isReceiveFailed();\n\t}\n\n\tvoid clearReceiveFailedStatus()\n\t{\n\t\t_clearReceiveFailedStatus();\n\t\tforceTRxOff();\n\t\t_resetReceiver();\n\t}\n\n\tboolean isReceiveTimeout()\n\t{\n\t\t_readSystemEventMaskRegister();\n\t\treturn _isReceiveTimeout();\n\t}\n\n\tvoid clearReceiveTimeoutStatus()\n\t{\n\t\t_clearReceiveTimeoutStatus();\n\t\tforceTRxOff();\n\t\t_resetReceiver();\n\t}\n\n\tvoid enableDebounceClock()\n\t{\n\t\tbyte pmscctrl0[LEN_PMSC_CTRL0];\n\t\tmemset(pmscctrl0, 0, LEN_PMSC_CTRL0);\n\t\t_readBytes(PMSC, PMSC_CTRL0_SUB, pmscctrl0, LEN_PMSC_CTRL0);\n\t\tDW1000NgUtils::setBit(pmscctrl0, LEN_PMSC_CTRL0, GPDCE_BIT, 1);\n\t\tDW1000NgUtils::setBit(pmscctrl0, LEN_PMSC_CTRL0, KHZCLKEN_BIT, 1);\n\t\t_writeBytesToRegister(PMSC, PMSC_CTRL0_SUB, pmscctrl0, LEN_PMSC_CTRL0);\n\t\t_debounceClockEnabled = true;\n\t}\n\n\tvoid enableLedBlinking()\n\t{\n\t\tbyte pmscledc[LEN_PMSC_LEDC];\n\t\tmemset(pmscledc, 0, LEN_PMSC_LEDC);\n\t\t_readBytes(PMSC, PMSC_LEDC_SUB, pmscledc, LEN_PMSC_LEDC);\n\t\tDW1000NgUtils::setBit(pmscledc, LEN_PMSC_LEDC, BLNKEN, 1);\n\t\t_writeBytesToRegister(PMSC, PMSC_LEDC_SUB, pmscledc, LEN_PMSC_LEDC);\n\t}\n\n\tvoid setGPIOMode(uint8_t msgp, uint8_t mode)\n\t{\n\t\tbyte gpiomode[LEN_GPIO_MODE];\n\t\tmemset(gpiomode, 0, LEN_GPIO_MODE);\n\t\t_readBytes(GPIO_CTRL, GPIO_MODE_SUB, gpiomode, LEN_GPIO_MODE);\n\t\tfor (char i = 0; i < 2; i++)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(gpiomode, LEN_GPIO_MODE, msgp + i, (mode >> i) & 1);\n\t\t}\n\t\t_writeBytesToRegister(GPIO_CTRL, GPIO_MODE_SUB, gpiomode, LEN_GPIO_MODE);\n\t}\n\n\tvoid applySleepConfiguration(sleep_configuration_t sleep_config)\n\t{\n\t\tbyte aon_wcfg[LEN_AON_WCFG];\n\t\t_readBytes(AON, AON_WCFG_SUB, aon_wcfg, LEN_AON_WCFG);\n\t\tbyte aon_cfg0[1];\n\t\tmemset(aon_cfg0, 0, 1);\n\n\t\tDW1000NgUtils::setBit(aon_wcfg, LEN_AON_WCFG, ONW_RADC_BIT, sleep_config.onWakeUpRunADC);\n\t\tDW1000NgUtils::setBit(aon_wcfg, LEN_AON_WCFG, ONW_RX_BIT, sleep_config.onWakeUpReceive);\n\t\tDW1000NgUtils::setBit(aon_wcfg, LEN_AON_WCFG, ONW_LEUI_BIT, sleep_config.onWakeUpLoadEUI);\n\t\tDW1000NgUtils::setBit(aon_wcfg, LEN_AON_WCFG, ONW_LDC_BIT, true);\n\t\tDW1000NgUtils::setBit(aon_wcfg, LEN_AON_WCFG, ONW_L64P_BIT, sleep_config.onWakeUpLoadL64Param);\n\t\tDW1000NgUtils::setBit(aon_wcfg, LEN_AON_WCFG, ONW_PRES_SLEEP_BIT, sleep_config.preserveSleep);\n\t\tDW1000NgUtils::setBit(aon_wcfg, LEN_AON_WCFG, ONW_LLDE_BIT, true);\n\t\tDW1000NgUtils::setBit(aon_wcfg, LEN_AON_WCFG, ONW_LLDO_BIT, true);\n\t\t_writeBytesToRegister(AON, AON_WCFG_SUB, aon_wcfg, LEN_AON_WCFG);\n\n\t\tDW1000NgUtils::setBit(aon_cfg0, 1, WAKE_PIN_BIT, sleep_config.enableWakePIN);\n\t\tDW1000NgUtils::setBit(aon_cfg0, 1, WAKE_SPI_BIT, sleep_config.enableWakeSPI);\n\t\tDW1000NgUtils::setBit(aon_cfg0, 1, WAKE_CNT_BIT, false);\n\t\tDW1000NgUtils::setBit(aon_cfg0, 1, SLEEP_EN_BIT, sleep_config.enableSLP);\n\t\t_writeBytesToRegister(AON, AON_CFG0_SUB, aon_cfg0, 1); // Deletes 3 bits of the unused LPCLKDIVA\n\t}\n\n\t/*Puts the device into sleep/deepSleep mode. This function also upload sleep config to AON. */\n\tvoid deepSleep()\n\t{\n\t\t/* Clear the register */\n\t\t_writeToRegister(AON, AON_CTRL_SUB, 0x00, LEN_AON_CTRL);\n\t\t/* Write 1 in SAVE_BIT */\n\t\t_writeToRegister(AON, AON_CTRL_SUB, 0x02, LEN_AON_CTRL);\n\t}\n\n\tvoid spiWakeup()\n\t{\n\t\tbyte deviceId[LEN_DEV_ID];\n\t\tbyte expectedDeviceId[LEN_DEV_ID];\n\t\tDW1000NgUtils::writeValueToBytes(expectedDeviceId, 0xDECA0130, LEN_DEV_ID);\n\t\t_readBytes(DEV_ID, NO_SUB, deviceId, LEN_DEV_ID);\n\t\tif (memcmp(deviceId, expectedDeviceId, LEN_DEV_ID))\n\t\t{\n\t\t\tdigitalWrite(_ss, LOW);\n\t\t\tdelay(1);\n\t\t\tdigitalWrite(_ss, HIGH);\n\t\t\tdelay(5);\n\t\t\tsetTxAntennaDelay(_antennaTxDelay);\n\t\t\tif (_debounceClockEnabled)\n\t\t\t{\n\t\t\t\tenableDebounceClock();\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid reset()   \n\t{\n\t\tif (_rst == 0xff)\n\t\t{ /* Fallback to Software Reset */\n\t\t\tsoftwareReset();\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// DW1000Ng data sheet v2.08 Â§5.6.1 page 20, the RSTn pin should not be driven high but left floating.\n\t\t\tpinMode(_rst, OUTPUT);\n\t\t\tdigitalWrite(_rst, LOW);\n\t\t\tdelay(2); // DW1000Ng data sheet v2.08 Â§5.6.1 page 20: nominal 50ns, to be safe take more time\n\t\t\tpinMode(_rst, INPUT);\n\t\t\tdelay(5); // dw1000Ng data sheet v1.2 page 5: nominal 3 ms, to be safe take more time\n\t\t}\n\t}\n\n\tvoid softwareReset()\n\t{\n\t\tSPIporting::setSPIspeed(SPIClock::SLOW);\n\n\t\t/* Disable sequencing and go to state \"INIT\" - (a) Sets SYSCLKS to 01 */\n\t\t_disableSequencing();\n\t\t/* Clear AON and WakeUp configuration */\n\t\t_writeToRegister(AON, AON_WCFG_SUB, 0x00, LEN_AON_WCFG);\n\t\t_writeToRegister(AON, AON_CFG0_SUB, 0x00, LEN_AON_CFG0);\n\t\t// TODO change this with uploadToAON\n\t\t_writeToRegister(AON, AON_CTRL_SUB, 0x00, LEN_AON_CTRL);\n\t\t_writeToRegister(AON, AON_CTRL_SUB, 0x02, LEN_AON_CTRL);\n\t\t/* (b) Clear SOFTRESET to all zeroâ€™s */\n\t\t_writeToRegister(PMSC, PMSC_SOFTRESET_SUB, 0x00, LEN_PMSC_SOFTRESET);\n\t\tdelay(1);\n\t\t/* (c) Set SOFTRESET to all ones */\n\t\t_writeToRegister(PMSC, PMSC_SOFTRESET_SUB, 0xF0, LEN_PMSC_SOFTRESET);\n\t}\n\n\t/* ###########################################################################\n\t * #### Pretty printed device information ####################################\n\t * ######################################################################### */\n\n\tvoid getPrintableDeviceIdentifier(char msgBuffer[])\n\t{\n\t\tbyte data[LEN_DEV_ID];\n\t\t_readBytes(DEV_ID, NO_SUB, data, LEN_DEV_ID);\n\t\tsprintf(msgBuffer, \"%02X - model: %d, version: %d, revision: %d\",\n\t\t\t\t(uint16_t)((data[3] << 8) | data[2]), data[1], (data[0] >> 4) & 0x0F, data[0] & 0x0F);\n\t}\n\n\tvoid getPrintableExtendedUniqueIdentifier(char msgBuffer[])\n\t{\n\t\tbyte data[LEN_EUI];\n\t\t_readBytes(EUI, NO_SUB, data, LEN_EUI);\n\t\tsprintf(msgBuffer, \"%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X\",\n\t\t\t\tdata[7], data[6], data[5], data[4], data[3], data[2], data[1], data[0]);\n\t}\n\n\tvoid getPrintableNetworkIdAndShortAddress(char msgBuffer[])\n\t{\n\t\tbyte data[LEN_PANADR];\n\t\t_readBytes(PANADR, NO_SUB, data, LEN_PANADR);\n\t\tsprintf(msgBuffer, \"PAN: %02X, Short Address: %02X\",\n\t\t\t\t(uint16_t)((data[3] << 8) | data[2]), (uint16_t)((data[1] << 8) | data[0]));\n\t}\n\n\tvoid getPrintableDeviceMode(char msgBuffer[])\n\t{\n\t\tuint16_t dr;\n\t\tuint8_t prf;\n\t\tuint16_t plen;\n\t\tuint8_t pcode;\n\t\tuint8_t ch;\n\t\tbyte chan_ctrl[LEN_CHAN_CTRL];\n\t\tbyte tx_fctrl[LEN_TX_FCTRL];\n\t\t_readBytes(CHAN_CTRL, NO_SUB, chan_ctrl, LEN_CHAN_CTRL);\n\t\t_readBytes(TX_FCTRL, NO_SUB, tx_fctrl, LEN_TX_FCTRL);\n\t\t/* Data Rate from 0x08 bits:13-14(tx_fctrl) */\n\t\tdr = (uint16_t)(tx_fctrl[1] >> 5 & 0x3);\n\t\tswitch (dr)\n\t\t{\n\t\tcase 0x00:\n\t\t\tdr = 110;\n\t\t\tbreak;\n\t\tcase 0x01:\n\t\t\tdr = 850;\n\t\t\tbreak;\n\t\tcase 0x02:\n\t\t\tdr = 6800;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn; // TODO Error handling\n\t\t}\n\t\t/* PRF(16 or 64) from 0x1F bits:18-19(chan_ctrl) */\n\t\tprf = (uint8_t)(chan_ctrl[2] >> 2 & 0x03);\n\t\tif (prf == 0x01)\n\t\t{\n\t\t\tprf = 16;\n\t\t}\n\t\telse if (prf == 0x02)\n\t\t{\n\t\t\tprf = 64;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn; // TODO Error handling\n\t\t}\n\t\t/* PreambleLength from 0x08 bits:18-21(tx_fctrl) */\n\t\tplen = (uint16_t)(tx_fctrl[2] >> 2 & 0xF);\n\t\tswitch (plen)\n\t\t{\n\t\tcase 0x01:\n\t\t\tplen = 64;\n\t\t\tbreak;\n\t\tcase 0x05:\n\t\t\tplen = 128;\n\t\t\tbreak;\n\t\tcase 0x09:\n\t\t\tplen = 256;\n\t\t\tbreak;\n\t\tcase 0x0D:\n\t\t\tplen = 512;\n\t\t\tbreak;\n\t\tcase 0x02:\n\t\t\tplen = 1024;\n\t\t\tbreak;\n\t\tcase 0x06:\n\t\t\tplen = 1536;\n\t\t\tbreak;\n\t\tcase 0x0A:\n\t\t\tplen = 2048;\n\t\t\tbreak;\n\t\tcase 0x03:\n\t\t\tplen = 4096;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn; // TODO Error handling\n\t\t}\n\t\t/* Channel from 0x1F bits:0-4(tx_chan) */\n\t\tch = (uint8_t)(chan_ctrl[0] & 0xF);\n\t\t/* Preamble Code from 0x1F bits:24-31(chan_ctrl) */\n\t\tpcode = (uint8_t)(chan_ctrl[3] >> 3 & 0x1F);\n\t\tsprintf(msgBuffer, \"Data rate: %u kb/s, PRF: %u MHz, Preamble: %u symbols, Channel: #%u, Preamble code #%u\", dr, prf, plen, ch, pcode);\n\t}\n\n\t/* ###########################################################################\n\t * #### DW1000Ng operation functions ###########################################\n\t * ######################################################################### */\n\n\tvoid setNetworkId(uint16_t val)\n\t{\n\t\t_networkAndAddress[2] = (byte)(val & 0xFF);\n\t\t_networkAndAddress[3] = (byte)((val >> 8) & 0xFF);\n\t\t_writeNetworkIdAndDeviceAddress();\n\t}\n\n\tvoid getNetworkId(byte id[])\n\t{\n\t\t_readNetworkIdAndDeviceAddress();\n\t\tid[0] = _networkAndAddress[2];\n\t\tid[1] = _networkAndAddress[3];\n\t}\n\n\tvoid setDeviceAddress(uint16_t val)\n\t{\n\t\t_networkAndAddress[0] = (byte)(val & 0xFF);\n\t\t_networkAndAddress[1] = (byte)((val >> 8) & 0xFF);\n\t\t_writeNetworkIdAndDeviceAddress();\n\t}\n\n\tvoid getDeviceAddress(byte address[])\n\t{\n\t\t_readNetworkIdAndDeviceAddress();\n\t\taddress[0] = _networkAndAddress[0];\n\t\taddress[1] = _networkAndAddress[1];\n\t}\n\n\tvoid setEUI(char eui[])\n\t{\n\t\tbyte eui_byte[LEN_EUI];\n\t\tDW1000NgUtils::convertToByte(eui, eui_byte);\n\t\tsetEUI(eui_byte);\n\t}\n\n\tvoid setEUI(byte eui[])\n\t{\n\t\t// we reverse the address->\n\t\tbyte reverseEUI[8];\n\t\tuint8_t size = 8;\n\t\tfor (uint8_t i = 0; i < size; i++)\n\t\t{\n\t\t\t*(reverseEUI + i) = *(eui + size - i - 1);\n\t\t}\n\t\t_writeBytesToRegister(EUI, NO_SUB, reverseEUI, LEN_EUI);\n\t}\n\n\tvoid getEUI(byte eui[])\n\t{\n\t\t_readBytes(EUI, NO_SUB, eui, LEN_EUI);\n\t}\n\n\tfloat getTemperature()\n\t{\n\t\t_vbatAndTempSteps();\n\t\tbyte sar_ltemp = 0;\n\t\t_readBytes(TX_CAL, 0x04, &sar_ltemp, 1);\n\t\treturn (sar_ltemp - _tmeas23C) * 1.14f + 23.0f;\n\t}\n\n\tfloat getBatteryVoltage()\n\t{\n\t\t_vbatAndTempSteps();\n\t\tbyte sar_lvbat = 0;\n\t\t_readBytes(TX_CAL, 0x03, &sar_lvbat, 1);\n\t\treturn (sar_lvbat - _vmeas3v3) / 173.0f + 3.3f;\n\t}\n\n\tvoid getTemperatureAndBatteryVoltage(float &temp, float &vbat)\n\t{\n\t\t// follow the procedure from section 6.4 of the User Manual\n\t\t_vbatAndTempSteps();\n\t\tdelay(1);\n\t\tbyte sar_lvbat = 0;\n\t\t_readBytes(TX_CAL, 0x03, &sar_lvbat, 1);\n\t\tbyte sar_ltemp = 0;\n\t\t_readBytes(TX_CAL, 0x04, &sar_ltemp, 1);\n\n\t\t// calculate voltage and temperature\n\t\tvbat = (sar_lvbat - _vmeas3v3) / 173.0f + 3.3f;\n\t\ttemp = (sar_ltemp - _tmeas23C) * 1.14f + 23.0f;\n\t}\n\n\tvoid enableFrameFiltering(frame_filtering_configuration_t config)\n\t{\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFEN_BIT, true);\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFBC_BIT, config.behaveAsCoordinator);\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFAB_BIT, config.allowBeacon);\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFAD_BIT, config.allowData);\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFAA_BIT, config.allowAcknowledgement);\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFAM_BIT, config.allowMacCommand);\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFAR_BIT, config.allowAllReserved);\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFA4_BIT, config.allowReservedFour);\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFA5_BIT, config.allowReservedFive);\n\n\t\t_writeSystemConfigurationRegister();\n\t}\n\n\tvoid disableFrameFiltering()\n\t{\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFEN_BIT, false);\n\t\t_writeSystemConfigurationRegister();\n\t}\n\n\tvoid setDoubleBuffering(boolean val)\n\t{\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, DIS_DRXB_BIT, !val);\n\t}\n\n\tvoid setAntennaDelay(uint16_t value)\n\t{\n\t\t_antennaTxDelay = value;\n\t\t_antennaRxDelay = value;\n\t\t_writeAntennaDelayRegisters();\n\t}\n\n\tvoid setTxAntennaDelay(uint16_t value)\n\t{\n\t\t_antennaTxDelay = value;\n\t\t_writeAntennaDelayRegisters();\n\t}\n\tvoid setRxAntennaDelay(uint16_t value)\n\t{\n\t\t_antennaRxDelay = value;\n\t\t_writeAntennaDelayRegisters();\n\t}\n\n\tuint16_t getTxAntennaDelay()\n\t{\n\t\treturn _antennaTxDelay;\n\t}\n\tuint16_t getRxAntennaDelay()\n\t{\n\t\treturn _antennaRxDelay;\n\t}\n\n\tvoid forceTRxOff()\n\t{\n\t\tmemset(_sysctrl, 0, LEN_SYS_CTRL);\n\t\tDW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, TRXOFF_BIT, true);\n\t\t_writeBytesToRegister(SYS_CTRL, NO_SUB, _sysctrl, LEN_SYS_CTRL);\n\t}\n\n\tvoid startReceive(ReceiveMode mode)\n\t{\n\t\tmemset(_sysctrl, 0, LEN_SYS_CTRL);\n\t\tDW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, SFCST_BIT, !_frameCheck);\n\t\tif (mode == ReceiveMode::DELAYED)\n\t\t\tDW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, RXDLYS_BIT, true);\n\t\tDW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, RXENAB_BIT, true);\n\t\t_writeBytesToRegister(SYS_CTRL, NO_SUB, _sysctrl, LEN_SYS_CTRL);\n\t}\n\n\tvoid startTransmit(TransmitMode mode)\n\t{\n\t\tmemset(_sysctrl, 0, LEN_SYS_CTRL);\n\t\tDW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, SFCST_BIT, !_frameCheck);\n\t\tif (mode == TransmitMode::DELAYED)\n\t\t\tDW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, TXDLYS_BIT, true);\n\t\tif (_wait4resp)\n\t\t\tDW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, WAIT4RESP_BIT, true);\n\n\t\tDW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, TXSTRT_BIT, true);\n\t\t_writeBytesToRegister(SYS_CTRL, NO_SUB, _sysctrl, LEN_SYS_CTRL);\n\t}\n\n\tvoid setInterruptPolarity(boolean val)\n\t{\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, HIRQ_POL_BIT, val);\n\t\t_writeSystemConfigurationRegister();\n\t}\n\n\tvoid applyConfiguration(device_configuration_t config)\n\t{\n\t\tforceTRxOff();\n\n\t\t_useExtendedFrameLength(config.extendedFrameLength);\n\t\t_setReceiverAutoReenable(config.receiverAutoReenable);\n\t\t_useSmartPower(config.smartPower);\n\t\t_useFrameCheck(config.frameCheck);\n\t\t_setNlosOptimization(config.nlos);\n\t\t_setSFDMode(config.sfd);\n\t\t_setChannel(config.channel);\n\t\t_setDataRate(config.dataRate);\n\t\t_setPulseFrequency(config.pulseFreq);\n\t\t_setPreambleLength(config.preambleLen);\n\t\t_setPreambleCode(config.preaCode);\n\n\t\tif (!_checkPreambleCodeValidity())\n\t\t\t_setValidPreambleCode();\n\n\t\tif (!_standardSFD)\n\t\t\t_setNonStandardSFDLength();\n\n\t\t// writes configuration to registers\n\t\t_writeConfiguration();\n\t\t// tune according to configuration\n\t\t_tune();\n\t}\n\n\tChannel getChannel()\n\t{\n\t\treturn _channel;\n\t}\n\n\tPulseFrequency getPulseFrequency()\n\t{\n\t\treturn _pulseFrequency;\n\t}\n\n\tvoid setPreambleDetectionTimeout(uint16_t pacSize)\n\t{\n\t\tbyte drx_pretoc[LEN_DRX_PRETOC];\n\t\tDW1000NgUtils::writeValueToBytes(drx_pretoc, pacSize, LEN_DRX_PRETOC);\n\t\t_writeBytesToRegister(DRX_TUNE, DRX_PRETOC_SUB, drx_pretoc, LEN_DRX_PRETOC);\n\t}\n\n\tvoid setSfdDetectionTimeout(uint16_t preambleSymbols)\n\t{\n\t\tbyte drx_sfdtoc[LEN_DRX_SFDTOC];\n\t\tDW1000NgUtils::writeValueToBytes(drx_sfdtoc, preambleSymbols, LEN_DRX_SFDTOC);\n\t\t_writeBytesToRegister(DRX_TUNE, DRX_SFDTOC_SUB, drx_sfdtoc, LEN_DRX_SFDTOC);\n\t}\n\n\tvoid setReceiveFrameWaitTimeoutPeriod(uint16_t timeMicroSeconds)\n\t{\n\t\tif (timeMicroSeconds > 0)\n\t\t{\n\t\t\tbyte rx_wfto[LEN_RX_WFTO];\n\t\t\tDW1000NgUtils::writeValueToBytes(rx_wfto, timeMicroSeconds, LEN_RX_WFTO);\n\t\t\t_writeBytesToRegister(RX_WFTO, NO_SUB, rx_wfto, LEN_RX_WFTO);\n\t\t\t/* enable frame wait timeout bit */\n\t\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, RXWTOE_BIT, true);\n\t\t\t_writeSystemConfigurationRegister();\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* disable frame wait timeout bit */\n\t\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, RXWTOE_BIT, false);\n\t\t\t_writeSystemConfigurationRegister();\n\t\t}\n\t}\n\n\tvoid applyInterruptConfiguration(interrupt_configuration_t interrupt_config)\n\t{\n\t\tforceTRxOff();\n\n\t\t_interruptOnSent(interrupt_config.interruptOnSent);\n\t\t_interruptOnReceived(interrupt_config.interruptOnReceived);\n\t\t_interruptOnReceiveFailed(interrupt_config.interruptOnReceiveFailed);\n\t\t_interruptOnReceiveTimeout(interrupt_config.interruptOnReceiveTimeout);\n\t\t_interruptOnReceiveTimestampAvailable(interrupt_config.interruptOnReceiveTimestampAvailable);\n\t\t_interruptOnAutomaticAcknowledgeTrigger(interrupt_config.interruptOnAutomaticAcknowledgeTrigger);\n\n\t\t_writeSystemEventMaskRegister();\n\t}\n\n\tvoid setWait4Response(uint32_t timeMicroSeconds)\n\t{\n\t\t_wait4resp = timeMicroSeconds == 0 ? false : true;\n\n\t\t/* Check if it overflows 20 bits */\n\t\tif (timeMicroSeconds > 1048575)\n\t\t\ttimeMicroSeconds = 1048575;\n\n\t\tbyte W4R_TIME[LEN_ACK_RESP_T_W4R_TIME_SUB];\n\t\tDW1000NgUtils::writeValueToBytes(W4R_TIME, timeMicroSeconds, LEN_ACK_RESP_T_W4R_TIME_SUB);\n\t\tW4R_TIME[2] &= 0x0F;\n\t\t_writeBytesToRegister(ACK_RESP_T, ACK_RESP_T_W4R_TIME_SUB, W4R_TIME, LEN_ACK_RESP_T_W4R_TIME_SUB);\n\t}\n\n\tvoid setTXPower(byte power[])\n\t{\n\t\t// TODO Check byte length\n\t\t_writeBytesToRegister(TX_POWER, NO_SUB, power, LEN_TX_POWER);\n\t\t_autoTXPower = false;\n\t}\n\n\tvoid setTXPower(int32_t power)\n\t{\n\t\tbyte txpower[LEN_TX_POWER];\n\t\tDW1000NgUtils::writeValueToBytes(txpower, power, LEN_TX_POWER);\n\t\tsetTXPower(txpower);\n\t}\n\n\tvoid setTXPower(DriverAmplifierValue driver_amplifier, TransmitMixerValue mixer)\n\t{\n\t\tbyte txpower[LEN_TX_POWER];\n\t\tbyte pwr = 0x00;\n\n\t\tpwr |= ((byte)driver_amplifier << 5);\n\t\tpwr |= (byte)mixer;\n\n\t\tfor (auto i = 0; i < LEN_TX_POWER; i++)\n\t\t{\n\t\t\ttxpower[i] = pwr;\n\t\t}\n\n\t\tsetTXPower(txpower);\n\t}\n\n\tvoid setTXPowerAuto()\n\t{\n\t\t_autoTXPower = true;\n\t\t_txpowertune();\n\t}\n\n\tvoid setTCPGDelay(byte tcpgdelay)\n\t{\n\t\tbyte tcpgBytes[LEN_TC_PGDELAY];\n\t\tDW1000NgUtils::writeValueToBytes(tcpgBytes, tcpgdelay, LEN_TC_PGDELAY);\n\t\t_writeBytesToRegister(TX_CAL, TC_PGDELAY_SUB, tcpgBytes, LEN_TC_PGDELAY);\n\t\t_autoTCPGDelay = false;\n\t}\n\n\tvoid setTCPGDelayAuto()\n\t{\n\t\t_tcpgdelaytune();\n\t\t_autoTCPGDelay = true;\n\t}\n\n\tvoid enableTransmitPowerSpectrumTestMode(int32_t repeat_interval)\n\t{\n\t\t/* DW1000 clocks must be set to crystal speed so SPI rate have to be lowered and will\n\t\tnot be increased again */\n\t\tSPIporting::setSPIspeed(SPIClock::SLOW);\n\n\t\t_disableSequencing();\n\t\t_configureRFTransmitPowerSpectrumTestMode();\n\t\t_enableClock(SYS_PLL_CLOCK);\n\t\t_enableClock(TX_PLL_CLOCK);\n\n\t\tif (repeat_interval < 4)\n\t\t\trepeat_interval = 4;\n\n\t\t/* In diagnostic transmit power  mode (set next) the bytes 31:0 only are used for DX_TIME register */\n\t\tbyte delayBytes[4];\n\t\tDW1000NgUtils::writeValueToBytes(delayBytes, repeat_interval, 4);\n\t\t_writeBytesToRegister(DX_TIME, NO_SUB, delayBytes, 4);\n\n\t\t/* Enable Transmit Power Spectrum Test Mode */\n\t\tbyte diagnosticBytes[2];\n\t\tDW1000NgUtils::writeValueToBytes(diagnosticBytes, 0x0010, LEN_DIAG_TMC);\n\t\t_writeBytesToRegister(DIG_DIAG, DIAG_TMC_SUB, diagnosticBytes, LEN_DIAG_TMC);\n\t}\n\n\tvoid setDelayedTRX(byte futureTimeBytes[])\n\t{\n\t\t/* the least significant 9-bits are ignored in DX_TIME in functional modes */\n\t\t_writeBytesToRegister(DX_TIME, NO_SUB, futureTimeBytes, LEN_DX_TIME);\n\t}\n\n\tvoid setTransmitData(byte data[], uint16_t n)\n\t{\n\t\tif (_frameCheck)\n\t\t{\n\t\t\tn += 2; // two bytes CRC-16\n\t\t}\n\t\tif (n > LEN_EXT_UWB_FRAMES)\n\t\t{\n\t\t\treturn; // TODO proper error handling: frame/buffer size\n\t\t}\n\t\tif (n > LEN_UWB_FRAMES && !_extendedFrameLength)\n\t\t{\n\t\t\treturn; // TODO proper error handling: frame/buffer size\n\t\t}\n\t\t// transmit data and length\n\t\t_writeBytesToRegister(TX_BUFFER, NO_SUB, data, n);\n\n\t\t/* Sets up transmit frame control length based on data length */\n\t\t_txfctrl[0] = (byte)(n & 0xFF); // 1 byte (regular length + 1 bit)\n\t\t_txfctrl[1] &= 0xE0;\n\t\t_txfctrl[1] |= (byte)((n >> 8) & 0x03); // 2 added bits if extended length\n\t\t_writeTransmitFrameControlRegister();\n\t}\n\n\tvoid setTransmitData(const String &data)\n\t{\n\t\tuint16_t n = data.length() + 1;\n\t\tbyte *dataBytes = (byte *)malloc(n);\n\t\tdata.getBytes(dataBytes, n);\n\t\tsetTransmitData(dataBytes, n);\n\t\tfree(dataBytes);\n\t}\n\n\t// TODO reorder\n\tuint16_t getReceivedDataLength()\n\t{\n\t\tuint16_t len = 0;\n\n\t\t// 10 bits of RX frame control register\n\t\tbyte rxFrameInfo[LEN_RX_FINFO];\n\t\t_readBytes(RX_FINFO, NO_SUB, rxFrameInfo, LEN_RX_FINFO);\n\t\tlen = ((((uint16_t)rxFrameInfo[1] << 8) | (uint16_t)rxFrameInfo[0]) & 0x03FF);\n\n\t\tif (_frameCheck && len > 2)\n\t\t{\n\t\t\treturn len - 2;\n\t\t}\n\t\treturn len;\n\t}\n\n\tvoid getReceivedData(byte data[], uint16_t n)\n\t{\n\t\tif (n <= 0)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\t_readBytes(RX_BUFFER, NO_SUB, data, n);\n\t}\n\n\tvoid getReceivedData(String &data)\n\t{\n\t\tuint16_t i;\n\t\tuint16_t n = getReceivedDataLength(); // number of bytes w/o the two FCS ones\n\t\tif (n <= 0)\n\t\t{ // TODO\n\t\t\treturn;\n\t\t}\n\t\tbyte *dataBytes = (byte *)malloc(n);\n\t\tgetReceivedData(dataBytes, n);\n\t\t// clear string\n\t\tdata.remove(0);\n\t\tdata = \"\";\n\t\t// append to string\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tdata += (char)dataBytes[i];\n\t\t}\n\t\tfree(dataBytes);\n\t}\n\n\tuint64_t getTransmitTimestamp()\n\t{\n\t\tbyte data[LENGTH_TIMESTAMP];\n\t\tmemset(data, 0, LENGTH_TIMESTAMP);\n\t\t_readBytes(TX_TIME, TX_STAMP_SUB, data, LEN_TX_STAMP);\n\t\treturn DW1000NgUtils::bytesAsValue(data, LEN_TX_STAMP);\n\t}\n\n\tuint64_t getReceiveTimestamp()\n\t{\n\t\tbyte data[LEN_RX_STAMP];\n\t\tmemset(data, 0, LEN_RX_STAMP);\n\t\t_readBytes(RX_TIME, RX_STAMP_SUB, data, LEN_RX_STAMP);\n\t\treturn DW1000NgUtils::bytesAsValue(data, LEN_RX_STAMP);\n\t}\n\n\tuint64_t getSystemTimestamp()\n\t{\n\t\tbyte data[LEN_SYS_TIME];\n\t\tmemset(data, 0, LEN_SYS_TIME);\n\t\t_readBytes(SYS_TIME, NO_SUB, data, LEN_SYS_TIME);\n\t\treturn DW1000NgUtils::bytesAsValue(data, LEN_SYS_TIME);\n\t}\n\n\tfloat getReceiveQuality()\n\t{\n\t\tbyte noiseBytes[LEN_STD_NOISE];\n\t\tbyte fpAmpl2Bytes[LEN_FP_AMPL2];\n\t\tuint16_t noise, f2;\n\t\t_readBytes(RX_FQUAL, STD_NOISE_SUB, noiseBytes, LEN_STD_NOISE);\n\t\t_readBytes(RX_FQUAL, FP_AMPL2_SUB, fpAmpl2Bytes, LEN_FP_AMPL2);\n\t\tnoise = (uint16_t)noiseBytes[0] | ((uint16_t)noiseBytes[1] << 8);\n\t\tf2 = (uint16_t)fpAmpl2Bytes[0] | ((uint16_t)fpAmpl2Bytes[1] << 8);\n\t\treturn (float)f2 / noise;\n\t}\n\n\tfloat getFirstPathPower()\n\t{\n\t\tbyte fpAmpl1Bytes[LEN_FP_AMPL1];\n\t\tbyte fpAmpl2Bytes[LEN_FP_AMPL2];\n\t\tbyte fpAmpl3Bytes[LEN_FP_AMPL3];\n\t\tbyte rxFrameInfo[LEN_RX_FINFO];\n\t\tuint16_t f1, f2, f3, N;\n\t\tfloat A, corrFac;\n\t\t_readBytes(RX_TIME, FP_AMPL1_SUB, fpAmpl1Bytes, LEN_FP_AMPL1);\n\t\t_readBytes(RX_FQUAL, FP_AMPL2_SUB, fpAmpl2Bytes, LEN_FP_AMPL2);\n\t\t_readBytes(RX_FQUAL, FP_AMPL3_SUB, fpAmpl3Bytes, LEN_FP_AMPL3);\n\t\t_readBytes(RX_FINFO, NO_SUB, rxFrameInfo, LEN_RX_FINFO);\n\t\tf1 = (uint16_t)fpAmpl1Bytes[0] | ((uint16_t)fpAmpl1Bytes[1] << 8);\n\t\tf2 = (uint16_t)fpAmpl2Bytes[0] | ((uint16_t)fpAmpl2Bytes[1] << 8);\n\t\tf3 = (uint16_t)fpAmpl3Bytes[0] | ((uint16_t)fpAmpl3Bytes[1] << 8);\n\t\tN = (((uint16_t)rxFrameInfo[2] >> 4) & 0xFF) | ((uint16_t)rxFrameInfo[3] << 4);\n\n\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t{\n\t\t\tA = 113.77;\n\t\t\tcorrFac = 2.3334;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tA = 121.74;\n\t\t\tcorrFac = 1.1667;\n\t\t}\n\t\tfloat estFpPwr = 10.0 * log10(((float)f1 * (float)f1 + (float)f2 * (float)f2 + (float)f3 * (float)f3) / ((float)N * (float)N)) - A;\n\t\tif (estFpPwr <= -88)\n\t\t{\n\t\t\treturn estFpPwr;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// approximation of Fig. 22 in user manual for dbm correction\n\t\t\testFpPwr += (estFpPwr + 88) * corrFac;\n\t\t}\n\t\treturn estFpPwr;\n\t}\n\n\tfloat getReceivePower()\n\t{\n\t\tbyte cirPwrBytes[LEN_CIR_PWR];\n\t\tbyte rxFrameInfo[LEN_RX_FINFO];\n\t\tuint32_t twoPower17 = 131072;\n\t\tuint16_t C, N;\n\t\tfloat A, corrFac;\n\t\t_readBytes(RX_FQUAL, CIR_PWR_SUB, cirPwrBytes, LEN_CIR_PWR);\n\t\t_readBytes(RX_FINFO, NO_SUB, rxFrameInfo, LEN_RX_FINFO);\n\t\tC = (uint16_t)cirPwrBytes[0] | ((uint16_t)cirPwrBytes[1] << 8);\n\t\tN = (((uint16_t)rxFrameInfo[2] >> 4) & 0xFF) | ((uint16_t)rxFrameInfo[3] << 4);\n\n\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t{\n\t\t\tA = 113.77;\n\t\t\tcorrFac = 2.3334;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tA = 121.74;\n\t\t\tcorrFac = 1.1667;\n\t\t}\n\n\t\tfloat estRxPwr = 10.0 * log10(((float)C * (float)twoPower17) / ((float)N * (float)N)) - A;\n\t\tif (estRxPwr <= -88)\n\t\t{\n\t\t\treturn estRxPwr;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// approximation of Fig. 22 in user manual for dbm correction\n\t\t\testRxPwr += (estRxPwr + 88) * corrFac;\n\t\t}\n\t\treturn estRxPwr;\n\t}\n\n#if DW1000NG_DEBUG\n\tvoid getPrettyBytes(byte data[], char msgBuffer[], uint16_t n)\n\t{\n\t\tuint16_t i, j, b;\n\t\tb = sprintf(msgBuffer, \"Data, bytes: %d\\nB: 7 6 5 4 3 2 1 0\\n\", n); // TODO - type\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tbyte curByte = data[i];\n\t\t\tsnprintf(&msgBuffer[b++], 2, \"%d\", (i + 1));\n\t\t\tmsgBuffer[b++] = (char)((i + 1) & 0xFF);\n\t\t\tmsgBuffer[b++] = ':';\n\t\t\tmsgBuffer[b++] = ' ';\n\t\t\tfor (j = 0; j < 8; j++)\n\t\t\t{\n\t\t\t\tmsgBuffer[b++] = ((curByte >> (7 - j)) & 0x01) ? '1' : '0';\n\t\t\t\tif (j < 7)\n\t\t\t\t{\n\t\t\t\t\tmsgBuffer[b++] = ' ';\n\t\t\t\t}\n\t\t\t\telse if (i < n - 1)\n\t\t\t\t{\n\t\t\t\t\tmsgBuffer[b++] = '\\n';\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmsgBuffer[b++] = '\\0';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmsgBuffer[b++] = '\\0';\n\t}\n\n\tvoid getPrettyBytes(byte cmd, uint16_t offset, char msgBuffer[], uint16_t n)\n\t{\n\t\tuint16_t i, j, b;\n\t\tbyte *readBuf = (byte *)malloc(n);\n\t\t_readBytes(cmd, offset, readBuf, n);\n\t\tb = sprintf(msgBuffer, \"Reg: 0x%02x, bytes: %d\\nB: 7 6 5 4 3 2 1 0\\n\", cmd, n); // TODO - tpye\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tbyte curByte = readBuf[i];\n\t\t\tsnprintf(&msgBuffer[b++], 2, \"%d\", (i + 1));\n\t\t\tmsgBuffer[b++] = (char)((i + 1) & 0xFF);\n\t\t\tmsgBuffer[b++] = ':';\n\t\t\tmsgBuffer[b++] = ' ';\n\t\t\tfor (j = 0; j < 8; j++)\n\t\t\t{\n\t\t\t\tmsgBuffer[b++] = ((curByte >> (7 - j)) & 0x01) ? '1' : '0';\n\t\t\t\tif (j < 7)\n\t\t\t\t{\n\t\t\t\t\tmsgBuffer[b++] = ' ';\n\t\t\t\t}\n\t\t\t\telse if (i < n - 1)\n\t\t\t\t{\n\t\t\t\t\tmsgBuffer[b++] = '\\n';\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmsgBuffer[b++] = '\\0';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmsgBuffer[b++] = '\\0';\n\t\tfree(readBuf);\n\t}\n#endif\n}"}}}Content-Length: 175

{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"}}}
>>>
Content-Length: 183

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///c:/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","diagnostics":[]},"jsonrpc":"2.0"}
<<<
Content-Length: 233

{"jsonrpc":"2.0","id":119,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":53,"character":24}}}
>>>
Content-Length: 215

{"id":119,"result":[{"uri":"file:///C:/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","range":{"start":{"line":1643,"character":6},"end":{"line":1643,"character":27}}}],"jsonrpc":"2.0"}
<<<
Content-Length: 82613

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","languageId":"cpp","version":1,"text":"/*\n * MIT License\n *\n * Copyright (c) 2018 Michele Biondi, Andrea Salvatori\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n/*\n * Copyright (c) 2015 by Thomas Trojer <thomas@trojer.net>\n * Decawave DW1000Ng library for arduino.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @file DW1000Ng.cpp\n * Arduino driver library (source file) for the Decawave DW1000Ng UWB transceiver Module.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"DW1000Ng.hpp\"\n#include \"DW1000NgUtils.hpp\"\n#include \"DW1000NgConstants.hpp\"\n#include \"DW1000NgRegisters.hpp\"\n#include \"SPIporting.hpp\"\n\nnamespace DW1000Ng\n{\n\n\t/* anonymous namespace to host private-like variables and methods */\n\tnamespace\n\t{\n\n\t\t/* ########################### PRIVATE VARIABLES ################################# */\n\n\t\t/* SPI select pin and interrupt pin*/\n\t\tuint8_t _ss = 0xff;\n\t\tuint8_t _irq = 0xff;\n\t\tuint8_t _rst = 0xff;\n\n\t\t/* IRQ callbacks */\n\t\tvoid (*_handleSent)(void) = nullptr;\n\t\tvoid (*_handleError)(void) = nullptr;\n\t\tvoid (*_handleReceived)(void) = nullptr;\n\t\tvoid (*_handleReceiveFailed)(void) = nullptr;\n\t\tvoid (*_handleReceiveTimeout)(void) = nullptr;\n\t\tvoid (*_handleReceiveTimestampAvailable)(void) = nullptr;\n\n\t\t/* registers */\n\t\tbyte _syscfg[LEN_SYS_CFG];\n\t\tbyte _sysctrl[LEN_SYS_CTRL];\n\t\tbyte _sysstatus[LEN_SYS_STATUS];\n\t\tbyte _txfctrl[LEN_TX_FCTRL];\n\t\tbyte _sysmask[LEN_SYS_MASK];\n\t\tbyte _chanctrl[LEN_CHAN_CTRL];\n\t\tbyte _networkAndAddress[LEN_PANADR];\n\n\t\t/* Temperature and Voltage monitoring */\n\t\tbyte _vmeas3v3 = 0;\n\t\tbyte _tmeas23C = 0;\n\n\t\t/* Driver Internal State Trackers */\n\t\tbyte _extendedFrameLength;\n\t\tPacSize _pacSize;\n\t\tPulseFrequency _pulseFrequency;\n\t\tDataRate _dataRate;\n\t\tPreambleLength _preambleLength;\n\t\tPreambleCode _preambleCode;\n\t\tChannel _channel;\n\t\tboolean _smartPower;\n\t\tboolean _frameCheck;\n\t\tboolean _debounceClockEnabled = false;\n\t\tboolean _nlos = false;\n\t\tboolean _standardSFD = true;\n\t\tboolean _autoTXPower = true;\n\t\tboolean _autoTCPGDelay = true;\n\t\tboolean _wait4resp = false;\n\t\tuint16_t _antennaTxDelay = 0;\n\t\tuint16_t _antennaRxDelay = 0;\n\n\t\t/* ############################# PRIVATE METHODS ################################### */\n\t\t/*\n\t\t * Write bytes to the DW1000Ng. Single bytes can be written to registers via sub-addressing.\n\t\t * @param cmd\n\t\t * \t\tThe register address (see Chapter 7 in the DW1000Ng user manual).\n\t\t * @param offset\n\t\t *\t\tThe offset to select register sub-parts for writing, or 0x00 to disable\n\t\t * \t\tsub-adressing.\n\t\t * @param data\n\t\t *\t\tThe data array to be written.\n\t\t * @param data_size\n\t\t *\t\tThe number of bytes to be written (take care not to go out of bounds of\n\t\t * \t\tthe register).\n\t\t */\n\t\t// TODO offset really bigger than byte?\n\n\t\tvoid _writeBytesToRegister(byte cmd, uint16_t offset, byte data[], uint16_t data_size)\n\t\t{\n\t\t\tbyte header[3];\n\t\t\tuint8_t headerLen = 1;\n\n\t\t\t// TODO proper error handling: address out of bounds\n\t\t\t// build SPI header\n\t\t\tif (offset == NO_SUB)\n\t\t\t{\n\t\t\t\theader[0] = WRITE | cmd;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\theader[0] = WRITE_SUB | cmd;\n\t\t\t\tif (offset < 128)\n\t\t\t\t{\n\t\t\t\t\theader[1] = (byte)offset;\n\t\t\t\t\theaderLen++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\theader[1] = RW_SUB_EXT | (byte)offset;\n\t\t\t\t\theader[2] = (byte)(offset >> 7);\n\t\t\t\t\theaderLen += 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSPIporting::writeToSPI(_ss, headerLen, header, data_size, data);\n\t\t}\n\n\t\tvoid _writeToRegister(byte cmd, uint16_t offset, uint32_t data, uint16_t data_size)\n\t\t{\n\t\t\tbyte dataBytes[data_size];\n\t\t\tDW1000NgUtils::writeValueToBytes(dataBytes, data, data_size);\n\t\t\t_writeBytesToRegister(cmd, offset, dataBytes, data_size);\n\t\t}\n\n\t\t// Helper to set a single register\n\t\tvoid _writeByte(byte cmd, uint16_t offset, byte data)\n\t\t{\n\t\t\t_writeBytesToRegister(cmd, offset, &data, 1);\n\t\t}\n\n\t\t/*\n\t\t * Read bytes from the DW1000Ng. Number of bytes depend on register length.\n\t\t * @param cmd\n\t\t * \t\tThe register address (see Chapter 7 in the DW1000Ng user manual).\n\t\t * @param data\n\t\t *\t\tThe data array to be read into.\n\t\t * @param n\n\t\t *\t\tThe number of bytes expected to be received.\n\t\t */\n\t\t// TODO incomplete doc\n\t\tvoid _readBytes(byte cmd, uint16_t offset, byte data[], uint16_t data_size)\n\t\t{\n\t\t\tbyte header[3];\n\t\t\tuint8_t headerLen = 1;\n\n\t\t\t// build SPI header\n\t\t\tif (offset == NO_SUB)\n\t\t\t{\n\t\t\t\theader[0] = READ | cmd;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\theader[0] = READ_SUB | cmd;\n\t\t\t\tif (offset < 128)\n\t\t\t\t{\n\t\t\t\t\theader[1] = (byte)offset;\n\t\t\t\t\theaderLen++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\theader[1] = RW_SUB_EXT | (byte)offset;\n\t\t\t\t\theader[2] = (byte)(offset >> 7);\n\t\t\t\t\theaderLen += 2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSPIporting::readFromSPI(_ss, headerLen, header, data_size, data);\n\t\t}\n\n\t\t// always 4 bytes\n\t\t// TODO why always 4 bytes? can be different, see p. 58 table 10 otp memory map\n\t\tvoid _readBytesOTP(uint16_t address, byte data[])\n\t\t{\n\t\t\tbyte addressBytes[LEN_OTP_ADDR];\n\n\t\t\t// p60 - 6.3.3 Reading a value from OTP memory\n\t\t\t// bytes of address\n\t\t\taddressBytes[0] = (address & 0xFF);\n\t\t\taddressBytes[1] = ((address >> 8) & 0xFF);\n\t\t\t// set address\n\t\t\t_writeBytesToRegister(OTP_IF, OTP_ADDR_SUB, addressBytes, LEN_OTP_ADDR);\n\t\t\t// switch into read mode\n\t\t\t_writeByte(OTP_IF, OTP_CTRL_SUB, 0x03); // OTPRDEN | OTPREAD\n\t\t\t_writeByte(OTP_IF, OTP_CTRL_SUB, 0x01); // OTPRDEN\n\t\t\t// read value/block - 4 bytes\n\t\t\t_readBytes(OTP_IF, OTP_RDAT_SUB, data, LEN_OTP_RDAT);\n\t\t\t// end read mode\n\t\t\t_writeByte(OTP_IF, OTP_CTRL_SUB, 0x00);\n\t\t}\n\n\t\tvoid _writeBitToRegister(byte bitRegister, uint16_t RegisterOffset, uint16_t bitRegister_LEN, uint16_t selectedBit, boolean value)\n\t\t{\n\t\t\tuint16_t idx;\n\t\t\tuint8_t bitPosition;\n\n\t\t\tidx = selectedBit / 8;\n\t\t\tif (idx >= bitRegister_LEN)\n\t\t\t{\n\t\t\t\treturn; // TODO proper error handling: out of bounds\n\t\t\t}\n\t\t\tbyte targetByte;\n\t\t\tmemset(&targetByte, 0, 1);\n\t\t\tbitPosition = selectedBit % 8;\n\t\t\t_readBytes(bitRegister, RegisterOffset + idx, &targetByte, 1);\n\n\t\t\tvalue ? bitSet(targetByte, bitPosition) : bitClear(targetByte, bitPosition);\n\n\t\t\tif (RegisterOffset == NO_SUB)\n\t\t\t\tRegisterOffset = 0x00;\n\n\t\t\t_writeBytesToRegister(bitRegister, RegisterOffset + idx, &targetByte, 1);\n\t\t}\n\n\t\tvoid _enableClock(byte clock)\n\t\t{\n\t\t\tbyte pmscctrl0[LEN_PMSC_CTRL0];\n\t\t\tmemset(pmscctrl0, 0, LEN_PMSC_CTRL0);\n\t\t\t_readBytes(PMSC, PMSC_CTRL0_SUB, pmscctrl0, LEN_PMSC_CTRL0);\n\t\t\tif (clock == SYS_AUTO_CLOCK)\n\t\t\t{\n\t\t\t\tpmscctrl0[0] = SYS_AUTO_CLOCK;\n\t\t\t\tpmscctrl0[1] &= 0xFE;\n\t\t\t}\n\t\t\telse if (clock == SYS_XTI_CLOCK)\n\t\t\t{\n\t\t\t\tpmscctrl0[0] &= 0xFC;\n\t\t\t\tpmscctrl0[0] |= SYS_XTI_CLOCK;\n\t\t\t}\n\t\t\telse if (clock == SYS_PLL_CLOCK)\n\t\t\t{\n\t\t\t\tpmscctrl0[0] &= 0xFC;\n\t\t\t\tpmscctrl0[0] |= SYS_PLL_CLOCK;\n\t\t\t}\n\t\t\telse if (clock == TX_PLL_CLOCK)\n\t\t\t{\n\t\t\t\tpmscctrl0[0] &= 0xCF;\n\t\t\t\tpmscctrl0[0] |= TX_PLL_CLOCK;\n\t\t\t}\n\t\t\telse if (clock == LDE_CLOCK)\n\t\t\t{\n\t\t\t\tpmscctrl0[0] = SYS_XTI_CLOCK;\n\t\t\t\tpmscctrl0[1] = 0x03;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO deliver proper warning\n\t\t\t}\n\t\t\t_writeBytesToRegister(PMSC, PMSC_CTRL0_SUB, pmscctrl0, 2);\n\t\t}\n\n\t\t/* Steps used to get Temp and Voltage */\n\t\tvoid _vbatAndTempSteps()\n\t\t{\n\t\t\tbyte step1 = 0x80;\n\t\t\t_writeBytesToRegister(RF_CONF, 0x11, &step1, 1);\n\t\t\tbyte step2 = 0x0A;\n\t\t\t_writeBytesToRegister(RF_CONF, 0x12, &step2, 1);\n\t\t\tbyte step3 = 0x0F;\n\t\t\t_writeBytesToRegister(RF_CONF, 0x12, &step3, 1);\n\t\t\tbyte step4 = 0x01;\n\t\t\t_writeBytesToRegister(TX_CAL, NO_SUB, &step4, 1);\n\t\t\tbyte step5 = 0x00;\n\t\t\t_writeBytesToRegister(TX_CAL, NO_SUB, &step5, 1);\n\t\t}\n\n\t\t/* AGC_TUNE1 - reg:0x23, sub-reg:0x04, table 24 */\n\t\tvoid _agctune1()\n\t\t{\n\t\t\tbyte agctune1[LEN_AGC_TUNE1];\n\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(agctune1, 0x8870, LEN_AGC_TUNE1);\n\t\t\t}\n\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(agctune1, 0x889B, LEN_AGC_TUNE1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(AGC_TUNE, AGC_TUNE1_SUB, agctune1, LEN_AGC_TUNE1);\n\t\t}\n\n\t\t/* AGC_TUNE2 - reg:0x23, sub-reg:0x0C, table 25 */\n\t\tvoid _agctune2()\n\t\t{\n\t\t\tbyte agctune2[LEN_AGC_TUNE2];\n\t\t\tDW1000NgUtils::writeValueToBytes(agctune2, 0x2502A907L, LEN_AGC_TUNE2);\n\t\t\t_writeBytesToRegister(AGC_TUNE, AGC_TUNE2_SUB, agctune2, LEN_AGC_TUNE2);\n\t\t}\n\n\t\t/* AGC_TUNE3 - reg:0x23, sub-reg:0x12, table 26 */\n\t\tvoid _agctune3()\n\t\t{\n\t\t\tbyte agctune3[LEN_AGC_TUNE3];\n\t\t\tDW1000NgUtils::writeValueToBytes(agctune3, 0x0035, LEN_AGC_TUNE3);\n\t\t\t_writeBytesToRegister(AGC_TUNE, AGC_TUNE3_SUB, agctune3, LEN_AGC_TUNE3);\n\t\t}\n\n\t\t/* DRX_TUNE0b - reg:0x27, sub-reg:0x02, table 30 */\n\t\tvoid _drxtune0b()\n\t\t{\n\t\t\tbyte drxtune0b[LEN_DRX_TUNE0b];\n\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t{\n\t\t\t\tif (!_standardSFD)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune0b, 0x0016, LEN_DRX_TUNE0b);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune0b, 0x000A, LEN_DRX_TUNE0b);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_dataRate == DataRate::RATE_850KBPS)\n\t\t\t{\n\t\t\t\tif (!_standardSFD)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune0b, 0x0006, LEN_DRX_TUNE0b);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune0b, 0x0001, LEN_DRX_TUNE0b);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_dataRate == DataRate::RATE_6800KBPS)\n\t\t\t{\n\t\t\t\tif (!_standardSFD)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune0b, 0x0002, LEN_DRX_TUNE0b);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune0b, 0x0001, LEN_DRX_TUNE0b);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(DRX_TUNE, DRX_TUNE0b_SUB, drxtune0b, LEN_DRX_TUNE0b);\n\t\t}\n\n\t\t/* DRX_TUNE1a - reg:0x27, sub-reg:0x04, table 31 */\n\t\tvoid _drxtune1a()\n\t\t{\n\t\t\tbyte drxtune1a[LEN_DRX_TUNE1a];\n\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune1a, 0x0087, LEN_DRX_TUNE1a);\n\t\t\t}\n\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune1a, 0x008D, LEN_DRX_TUNE1a);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(DRX_TUNE, DRX_TUNE1a_SUB, drxtune1a, LEN_DRX_TUNE1a);\n\t\t}\n\n\t\t/* DRX_TUNE1b - reg:0x27, sub-reg:0x06, table 32 */\n\t\tvoid _drxtune1b()\n\t\t{\n\t\t\tbyte drxtune1b[LEN_DRX_TUNE1b];\n\t\t\tif (_preambleLength == PreambleLength::LEN_1536 || _preambleLength == PreambleLength::LEN_2048 ||\n\t\t\t\t_preambleLength == PreambleLength::LEN_4096)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune1b, 0x0064, LEN_DRX_TUNE1b);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleLength != PreambleLength::LEN_64)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_850KBPS || _dataRate == DataRate::RATE_6800KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune1b, 0x0020, LEN_DRX_TUNE1b);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_6800KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune1b, 0x0010, LEN_DRX_TUNE1b);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\t_writeBytesToRegister(DRX_TUNE, DRX_TUNE1b_SUB, drxtune1b, LEN_DRX_TUNE1b);\n\t\t}\n\n\t\t/* DRX_TUNE2 - reg:0x27, sub-reg:0x08, table 33 */\n\t\tvoid _drxtune2()\n\t\t{\n\t\t\tbyte drxtune2[LEN_DRX_TUNE2];\n\t\t\tif (_pacSize == PacSize::SIZE_8)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune2, 0x311A002DL, LEN_DRX_TUNE2);\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune2, 0x313B006BL, LEN_DRX_TUNE2);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_pacSize == PacSize::SIZE_16)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune2, 0x331A0052L, LEN_DRX_TUNE2);\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune2, 0x333B00BEL, LEN_DRX_TUNE2);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_pacSize == PacSize::SIZE_32)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune2, 0x351A009AL, LEN_DRX_TUNE2);\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune2, 0x353B015EL, LEN_DRX_TUNE2);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_pacSize == PacSize::SIZE_64)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune2, 0x371A011DL, LEN_DRX_TUNE2);\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune2, 0x373B0296L, LEN_DRX_TUNE2);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(DRX_TUNE, DRX_TUNE2_SUB, drxtune2, LEN_DRX_TUNE2);\n\t\t}\n\n\t\t/* DRX_TUNE4H - reg:0x27, sub-reg:0x26, table 34 */\n\t\tvoid _drxtune4H()\n\t\t{\n\t\t\tbyte drxtune4H[LEN_DRX_TUNE4H];\n\t\t\tif (_preambleLength == PreambleLength::LEN_64)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune4H, 0x0010, LEN_DRX_TUNE4H);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune4H, 0x0028, LEN_DRX_TUNE4H);\n\t\t\t}\n\t\t\t_writeBytesToRegister(DRX_TUNE, DRX_TUNE4H_SUB, drxtune4H, LEN_DRX_TUNE4H);\n\t\t}\n\n\t\t/* LDE_CFG1 - reg 0x2E, sub-reg:0x0806 */\n\t\tvoid _ldecfg1()\n\t\t{\n\t\t\tbyte ldecfg1[LEN_LDE_CFG1];\n\t\t\t_nlos == true ? DW1000NgUtils::writeValueToBytes(ldecfg1, 0x7, LEN_LDE_CFG1) : DW1000NgUtils::writeValueToBytes(ldecfg1, 0xD, LEN_LDE_CFG1);\n\t\t\t_writeBytesToRegister(LDE_IF, LDE_CFG1_SUB, ldecfg1, LEN_LDE_CFG1);\n\t\t}\n\n\t\t/* LDE_CFG2 - reg 0x2E, sub-reg:0x1806, table 50 */\n\t\tvoid _ldecfg2()\n\t\t{\n\t\t\tbyte ldecfg2[LEN_LDE_CFG2];\n\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t{\n\t\t\t\t_nlos == true ? DW1000NgUtils::writeValueToBytes(ldecfg2, 0x0003, LEN_LDE_CFG2) : DW1000NgUtils::writeValueToBytes(ldecfg2, 0x1607, LEN_LDE_CFG2);\n\t\t\t}\n\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(ldecfg2, 0x0607, LEN_LDE_CFG2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(LDE_IF, LDE_CFG2_SUB, ldecfg2, LEN_LDE_CFG2);\n\t\t}\n\n\t\t/* LDE_REPC - reg 0x2E, sub-reg:0x2804, table 51 */\n\t\tvoid _lderepc()\n\t\t{\n\t\t\tbyte lderepc[LEN_LDE_REPC];\n\t\t\tif (_preambleCode == PreambleCode::CODE_1 || _preambleCode == PreambleCode::CODE_2)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x5998 >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x5998, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_3 || _preambleCode == PreambleCode::CODE_8)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x51EA >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x51EA, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_4)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x428E >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x428E, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_5)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x451E >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x451E, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_6)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x2E14 >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x2E14, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_7)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x8000 >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x8000, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_9)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x28F4 >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x28F4, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_10 || _preambleCode == PreambleCode::CODE_17)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x3332 >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x3332, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_11)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x3AE0 >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x3AE0, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_12)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x3D70 >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x3D70, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_18 || _preambleCode == PreambleCode::CODE_19)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x35C2 >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x35C2, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_20)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x47AE >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x47AE, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\n\t\t\t_writeBytesToRegister(LDE_IF, LDE_REPC_SUB, lderepc, LEN_LDE_REPC);\n\t\t}\n\n\t\t/* TX_POWER (enabled smart transmit power control) - reg:0x1E, tables 19-20\n\t\t * These values are based on a typical IC and an assumed IC to antenna loss of 1.5 dB with a 0 dBi antenna */\n\t\tvoid _txpowertune()\n\t\t{\n\t\t\tbyte txpower[LEN_TX_POWER];\n\t\t\tif (_channel == Channel::CHANNEL_1 || _channel == Channel::CHANNEL_2)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x1B153555L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x15355575L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x55555555L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x75757575L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x0D072747L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x07274767L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x47474747L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x67676767L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_3)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x150F2F4FL, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x0F2F4F6FL, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x4F4F4F4FL, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x6F6F6F6FL, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x0B2B4B6BL, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x2B4B6B8BL, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x6B6B6B6BL, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x8B8B8B8BL, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_4)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x1F1F1F3FL, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x1F1F3F5FL, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x3F3F3F3FL, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x5F5F5F5FL, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x1A3A5A7AL, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x3A5A7A9AL, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x7A7A7A7AL, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x9A9A9A9AL, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_5)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x140E0828L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x0E082848L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x28282828L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x48484848L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x05254565L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x25456585L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x65656565L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x85858585L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_7)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x12325272L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x32527292L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x72727272L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x92929292L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x315191B1L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x5171B1D1L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0xB1B1B1B1L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0xD1D1D1D1L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(TX_POWER, NO_SUB, txpower, LEN_TX_POWER);\n\t\t}\n\n\t\t/* RF_RXCTRLH - reg:0x28, sub-reg:0x0B, table 37 */\n\t\tvoid _rfrxctrlh()\n\t\t{\n\t\t\tbyte rfrxctrlh[LEN_RF_RXCTRLH];\n\t\t\tif (_channel != Channel::CHANNEL_4 && _channel != Channel::CHANNEL_7)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(rfrxctrlh, 0xD8, LEN_RF_RXCTRLH);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(rfrxctrlh, 0xBC, LEN_RF_RXCTRLH);\n\t\t\t}\n\t\t\t_writeBytesToRegister(RF_CONF, RF_RXCTRLH_SUB, rfrxctrlh, LEN_RF_RXCTRLH);\n\t\t}\n\n\t\t/* RX_TXCTRL - reg:0x28, sub-reg:0x0C */\n\t\tvoid _rftxctrl()\n\t\t{\n\t\t\tbyte rftxctrl[LEN_RF_TXCTRL];\n\t\t\tif (_channel == Channel::CHANNEL_1)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(rftxctrl, 0x00005C40L, LEN_RF_TXCTRL);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_2)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(rftxctrl, 0x00045CA0L, LEN_RF_TXCTRL);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_3)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(rftxctrl, 0x00086CC0L, LEN_RF_TXCTRL);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_4)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(rftxctrl, 0x00045C80L, LEN_RF_TXCTRL);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_5)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(rftxctrl, 0x001E3FE0L, LEN_RF_TXCTRL);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_7)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(rftxctrl, 0x001E7DE0L, LEN_RF_TXCTRL);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(RF_CONF, RF_TXCTRL_SUB, rftxctrl, LEN_RF_TXCTRL);\n\t\t}\n\n\t\t/* TC_PGDELAY - reg:0x2A, sub-reg:0x0B, table 40 */\n\t\tvoid _tcpgdelaytune()\n\t\t{\n\t\t\tbyte tcpgdelay[LEN_TC_PGDELAY];\n\t\t\tif (_channel == Channel::CHANNEL_1)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(tcpgdelay, 0xC9, LEN_TC_PGDELAY);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_2)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(tcpgdelay, 0xC2, LEN_TC_PGDELAY);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_3)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(tcpgdelay, 0xC5, LEN_TC_PGDELAY);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_4)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(tcpgdelay, 0x95, LEN_TC_PGDELAY);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_5)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(tcpgdelay, 0xC0, LEN_TC_PGDELAY);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_7)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(tcpgdelay, 0x93, LEN_TC_PGDELAY);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(TX_CAL, TC_PGDELAY_SUB, tcpgdelay, LEN_TC_PGDELAY);\n\t\t}\n\n\t\t// FS_PLLCFG and FS_PLLTUNE - reg:0x2B, sub-reg:0x07-0x0B, tables 43-44\n\t\tvoid _fspll()\n\t\t{\n\t\t\tbyte fspllcfg[LEN_FS_PLLCFG];\n\t\t\tbyte fsplltune[LEN_FS_PLLTUNE];\n\t\t\tif (_channel == Channel::CHANNEL_1)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fspllcfg, 0x09000407L, LEN_FS_PLLCFG);\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fsplltune, 0x1E, LEN_FS_PLLTUNE);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_2 || _channel == Channel::CHANNEL_4)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fspllcfg, 0x08400508L, LEN_FS_PLLCFG);\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fsplltune, 0x26, LEN_FS_PLLTUNE);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_3)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fspllcfg, 0x08401009L, LEN_FS_PLLCFG);\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fsplltune, 0x56, LEN_FS_PLLTUNE);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_5 || _channel == Channel::CHANNEL_7)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fspllcfg, 0x0800041DL, LEN_FS_PLLCFG);\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fsplltune, 0xBE, LEN_FS_PLLTUNE);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(FS_CTRL, FS_PLLTUNE_SUB, fsplltune, LEN_FS_PLLTUNE);\n\t\t\t_writeBytesToRegister(FS_CTRL, FS_PLLCFG_SUB, fspllcfg, LEN_FS_PLLCFG);\n\t\t}\n\n\t\tvoid _tune()\n\t\t{\n\t\t\t// these registers are going to be tuned/configured\n\t\t\t_agctune1();\n\t\t\t_agctune2();\n\t\t\t_agctune3();\n\t\t\t_drxtune0b();\n\t\t\t_drxtune1a();\n\t\t\t_drxtune1b();\n\t\t\t_drxtune2();\n\t\t\t_drxtune4H();\n\t\t\t_ldecfg1();\n\t\t\t_ldecfg2();\n\t\t\t_lderepc();\n\t\t\tif (_autoTXPower)\n\t\t\t\t_txpowertune();\n\t\t\t_rfrxctrlh();\n\t\t\t_rftxctrl();\n\t\t\tif (_autoTCPGDelay)\n\t\t\t\t_tcpgdelaytune();\n\t\t\t_fspll();\n\t\t}\n\n\t\tvoid _writeNetworkIdAndDeviceAddress()\n\t\t{\n\t\t\t_writeBytesToRegister(PANADR, NO_SUB, _networkAndAddress, LEN_PANADR);\n\t\t}\n\n\t\tvoid _writeSystemConfigurationRegister()\n\t\t{\n\t\t\t_writeBytesToRegister(SYS_CFG, NO_SUB, _syscfg, LEN_SYS_CFG);\n\t\t}\n\n\t\tvoid _writeChannelControlRegister()\n\t\t{\n\t\t\t_writeBytesToRegister(CHAN_CTRL, NO_SUB, _chanctrl, LEN_CHAN_CTRL);\n\t\t}\n\n\t\tvoid _writeTransmitFrameControlRegister()\n\t\t{\n\t\t\t_writeBytesToRegister(TX_FCTRL, NO_SUB, _txfctrl, LEN_TX_FCTRL);\n\t\t}\n\n\t\tvoid _writeSystemEventMaskRegister()\n\t\t{\n\t\t\t_writeBytesToRegister(SYS_MASK, NO_SUB, _sysmask, LEN_SYS_MASK);\n\t\t}\n\n\t\tvoid _writeAntennaDelayRegisters()\n\t\t{\n\t\t\tbyte antennaTxDelayBytes[2];\n\t\t\tbyte antennaRxDelayBytes[2];\n\t\t\tDW1000NgUtils::writeValueToBytes(antennaTxDelayBytes, _antennaTxDelay, LEN_TX_ANTD);\n\t\t\tDW1000NgUtils::writeValueToBytes(antennaRxDelayBytes, _antennaRxDelay, LEN_LDE_RXANTD);\n\t\t\t_writeBytesToRegister(TX_ANTD, NO_SUB, antennaTxDelayBytes, LEN_TX_ANTD);\n\t\t\t_writeBytesToRegister(LDE_IF, LDE_RXANTD_SUB, antennaRxDelayBytes, LEN_LDE_RXANTD);\n\t\t}\n\n\t\tvoid _writeConfiguration()\n\t\t{\n\t\t\t// write all configurations back to device\n\t\t\t_writeSystemConfigurationRegister();\n\t\t\t_writeChannelControlRegister();\n\t\t\t_writeTransmitFrameControlRegister();\n\t\t}\n\n\t\tvoid _useExtendedFrameLength(boolean val)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, PHR_MODE_0_BIT, val);\n\t\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, PHR_MODE_1_BIT, val);\n\t\t}\n\n\t\tvoid _setReceiverAutoReenable(boolean val)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, RXAUTR_BIT, val);\n\t\t}\n\n\t\tvoid _useFrameCheck(boolean val)\n\t\t{\n\t\t\t_frameCheck = val;\n\t\t}\n\n\t\tvoid _setNlosOptimization(boolean val)\n\t\t{\n\t\t\t_nlos = val;\n\t\t\tif (_nlos)\n\t\t\t{\n\t\t\t\t_ldecfg1();\n\t\t\t\t_ldecfg2();\n\t\t\t}\n\t\t}\n\n\t\tvoid _useSmartPower(boolean smartPower)\n\t\t{\n\t\t\t_smartPower = smartPower;\n\t\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, DIS_STXP_BIT, !smartPower);\n\t\t\t_writeSystemConfigurationRegister();\n\t\t\tif (_autoTXPower)\n\t\t\t\t_txpowertune();\n\t\t}\n\n\t\tvoid _setSFDMode(SFDMode mode)\n\t\t{\n\t\t\tswitch (mode)\n\t\t\t{\n\t\t\tcase SFDMode::STANDARD_SFD:\n\t\t\t\tDW1000NgUtils::setBit(_chanctrl, LEN_CHAN_CTRL, DWSFD_BIT, false);\n\t\t\t\tDW1000NgUtils::setBit(_chanctrl, LEN_CHAN_CTRL, TNSSFD_BIT, false);\n\t\t\t\tDW1000NgUtils::setBit(_chanctrl, LEN_CHAN_CTRL, RNSSFD_BIT, false);\n\t\t\t\t_standardSFD = true;\n\t\t\t\tbreak;\n\t\t\tcase SFDMode::DECAWAVE_SFD:\n\t\t\t\tDW1000NgUtils::setBit(_chanctrl, LEN_CHAN_CTRL, DWSFD_BIT, true);\n\t\t\t\tDW1000NgUtils::setBit(_chanctrl, LEN_CHAN_CTRL, TNSSFD_BIT, true);\n\t\t\t\tDW1000NgUtils::setBit(_chanctrl, LEN_CHAN_CTRL, RNSSFD_BIT, true);\n\t\t\t\t_standardSFD = false;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn; // TODO Proper error handling\n\t\t\t}\n\t\t}\n\n\t\tvoid _setChannel(Channel channel)\n\t\t{\n\t\t\tbyte chan = static_cast<byte>(channel);\n\t\t\tchan &= 0xF;\n\t\t\t_chanctrl[0] = ((chan | (chan << 4)) & 0xFF);\n\n\t\t\t_channel = channel;\n\t\t}\n\n\t\tvoid _setDataRate(DataRate data_rate)\n\t\t{\n\t\t\tbyte rate = static_cast<byte>(data_rate);\n\t\t\trate &= 0x03;\n\t\t\t_txfctrl[1] &= 0x83;\n\t\t\t_txfctrl[1] |= (byte)((rate << 5) & 0xFF);\n\t\t\t// special 110kbps flag\n\t\t\tif (data_rate == DataRate::RATE_110KBPS)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, RXM110K_BIT, true);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, RXM110K_BIT, false);\n\t\t\t}\n\t\t\t_dataRate = data_rate;\n\t\t}\n\n\t\tvoid _setPulseFrequency(PulseFrequency frequency)\n\t\t{\n\t\t\tbyte freq = static_cast<byte>(frequency);\n\t\t\tfreq &= 0x03;\n\t\t\t_txfctrl[2] &= 0xFC;\n\t\t\t_txfctrl[2] |= (byte)(freq & 0xFF);\n\t\t\t_chanctrl[2] &= 0xF3;\n\t\t\t_chanctrl[2] |= (byte)((freq << 2) & 0xFF);\n\n\t\t\t_pulseFrequency = frequency;\n\t\t}\n\n\t\tvoid _setPreambleLength(PreambleLength preamble_length)\n\t\t{\n\t\t\tbyte prealen = static_cast<byte>(preamble_length);\n\t\t\tprealen &= 0x0F;\n\t\t\t_txfctrl[2] &= 0xC3;\n\t\t\t_txfctrl[2] |= (byte)((prealen << 2) & 0xFF);\n\n\t\t\tswitch (preamble_length)\n\t\t\t{\n\t\t\tcase PreambleLength::LEN_64:\n\t\t\t\t_pacSize = PacSize::SIZE_8;\n\t\t\t\tbreak;\n\t\t\tcase PreambleLength::LEN_128:\n\t\t\t\t_pacSize = PacSize::SIZE_8;\n\t\t\t\tbreak;\n\t\t\tcase PreambleLength::LEN_256:\n\t\t\t\t_pacSize = PacSize::SIZE_16;\n\t\t\t\tbreak;\n\t\t\tcase PreambleLength::LEN_512:\n\t\t\t\t_pacSize = PacSize::SIZE_16;\n\t\t\t\tbreak;\n\t\t\tcase PreambleLength::LEN_1024:\n\t\t\t\t_pacSize = PacSize::SIZE_32;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t_pacSize = PacSize::SIZE_64; // In case of 1536, 2048 or 4096 preamble length.\n\t\t\t}\n\n\t\t\t_preambleLength = preamble_length;\n\t\t}\n\n\t\tvoid _setPreambleCode(PreambleCode preamble_code)\n\t\t{\n\t\t\tbyte preacode = static_cast<byte>(preamble_code);\n\t\t\tpreacode &= 0x1F;\n\t\t\t_chanctrl[2] &= 0x3F;\n\t\t\t_chanctrl[2] |= ((preacode << 6) & 0xFF);\n\t\t\t_chanctrl[3] = 0x00;\n\t\t\t_chanctrl[3] = ((((preacode >> 2) & 0x07) | (preacode << 3)) & 0xFF);\n\n\t\t\t_preambleCode = preamble_code;\n\t\t}\n\n\t\tboolean _checkPreambleCodeValidity()\n\t\t{\n\t\t\tbyte preacode = static_cast<byte>(_preambleCode);\n\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t{\n\t\t\t\tfor (auto i = 0; i < 2; i++)\n\t\t\t\t{\n\t\t\t\t\tif (preacode == preamble_validity_matrix_PRF16[(int)_channel][i])\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t{\n\t\t\t\tfor (auto i = 0; i < 4; i++)\n\t\t\t\t{\n\t\t\t\t\tif (preacode == preamble_validity_matrix_PRF64[(int)_channel][i])\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn false; // TODO Proper error handling\n\t\t\t}\n\t\t}\n\n\t\tvoid _setValidPreambleCode()\n\t\t{\n\t\t\tPreambleCode preamble_code;\n\n\t\t\tswitch (_channel)\n\t\t\t{\n\t\t\tcase Channel::CHANNEL_1:\n\t\t\t\tpreamble_code = _pulseFrequency == PulseFrequency::FREQ_16MHZ ? PreambleCode::CODE_2 : PreambleCode::CODE_10;\n\t\t\t\tbreak;\n\t\t\tcase Channel::CHANNEL_3:\n\t\t\t\tpreamble_code = _pulseFrequency == PulseFrequency::FREQ_16MHZ ? PreambleCode::CODE_6 : PreambleCode::CODE_10;\n\t\t\t\tbreak;\n\t\t\tcase Channel::CHANNEL_4:\n\t\t\tcase Channel::CHANNEL_7:\n\t\t\t\tpreamble_code = _pulseFrequency == PulseFrequency::FREQ_16MHZ ? PreambleCode::CODE_8 : PreambleCode::CODE_18;\n\t\t\t\tbreak;\n\t\t\tcase Channel::CHANNEL_2:\n\t\t\tcase Channel::CHANNEL_5:\n\t\t\t\tpreamble_code = _pulseFrequency == PulseFrequency::FREQ_16MHZ ? PreambleCode::CODE_3 : PreambleCode::CODE_10;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn; // TODO Proper Error Handling\n\t\t\t}\n\t\t\tbyte preacode = static_cast<byte>(preamble_code);\n\t\t\tpreacode &= 0x1F;\n\t\t\t_chanctrl[2] &= 0x3F;\n\t\t\t_chanctrl[2] |= ((preacode << 6) & 0xFF);\n\t\t\t_chanctrl[3] = 0x00;\n\t\t\t_chanctrl[3] = ((((preacode >> 2) & 0x07) | (preacode << 3)) & 0xFF);\n\n\t\t\t_preambleCode = preamble_code;\n\t\t}\n\n\t\tvoid _setNonStandardSFDLength()\n\t\t{\n\t\t\tswitch (_dataRate)\n\t\t\t{\n\t\t\tcase DataRate::RATE_6800KBPS:\n\t\t\t\t_writeByte(USR_SFD, SFD_LENGTH_SUB, 0x08);\n\t\t\t\tbreak;\n\t\t\tcase DataRate::RATE_850KBPS:\n\t\t\t\t_writeByte(USR_SFD, SFD_LENGTH_SUB, 0x10);\n\t\t\t\tbreak;\n\t\t\tcase DataRate::RATE_110KBPS:\n\t\t\t\t_writeByte(USR_SFD, SFD_LENGTH_SUB, 0x40);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn; // TODO Proper error handling\n\t\t\t}\n\t\t}\n\n\t\tvoid _interruptOnSent(boolean val)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_MASK, TXFRS_BIT, val);\n\t\t}\n\n\t\tvoid _interruptOnReceived(boolean val)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_MASK, RXDFR_BIT, val);\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_MASK, RXFCG_BIT, val);\n\t\t}\n\n\t\tvoid _interruptOnReceiveFailed(boolean val)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_STATUS, RXPHE_BIT, val);\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_STATUS, RXFCE_BIT, val);\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_STATUS, RXRFSL_BIT, val);\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_STATUS, LDEERR_BIT, val);\n\t\t}\n\n\t\tvoid _interruptOnReceiveTimeout(boolean val)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_MASK, RXRFTO_BIT, val);\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_MASK, RXPTO_BIT, val);\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_MASK, RXSFDTO_BIT, val);\n\t\t}\n\n\t\tvoid _interruptOnReceiveTimestampAvailable(boolean val)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_MASK, LDEDONE_BIT, val);\n\t\t}\n\n\t\tvoid _interruptOnAutomaticAcknowledgeTrigger(boolean val)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_MASK, AAT_BIT, val);\n\t\t}\n\n\t\tvoid _manageLDE()\n\t\t{\n\t\t\t// transfer any ldo tune values\n\t\t\tbyte ldoTune[LEN_OTP_RDAT];\n\t\t\tuint16_t LDOTUNE_ADDRESS = 0x04;\n\t\t\t_readBytesOTP(LDOTUNE_ADDRESS, ldoTune); // TODO #define\n\t\t\tif (ldoTune[0] != 0)\n\t\t\t{\n\t\t\t\t// TODO tuning available, copy over to RAM: use OTP_LDO bit\n\t\t\t}\n\t\t\t// tell the chip to load the LDE microcode\n\t\t\t// TODO remove clock-related code (PMSC_CTRL) as handled separately\n\t\t\tbyte pmscctrl0[LEN_PMSC_CTRL0];\n\t\t\tbyte otpctrl[LEN_OTP_CTRL];\n\t\t\tmemset(pmscctrl0, 0, LEN_PMSC_CTRL0);\n\t\t\tmemset(otpctrl, 0, LEN_OTP_CTRL);\n\t\t\t_readBytes(PMSC, PMSC_CTRL0_SUB, pmscctrl0, LEN_PMSC_CTRL0);\n\t\t\t_readBytes(OTP_IF, OTP_CTRL_SUB, otpctrl, LEN_OTP_CTRL);\n\t\t\tpmscctrl0[0] = 0x01;\n\t\t\tpmscctrl0[1] = 0x03;\n\t\t\totpctrl[1] = 0x80;\n\t\t\t_writeBytesToRegister(PMSC, PMSC_CTRL0_SUB, pmscctrl0, 2);\n\t\t\t// uCode\n\t\t\t_enableClock(LDE_CLOCK);\n\t\t\tdelay(5);\n\t\t\t_writeBytesToRegister(OTP_IF, OTP_CTRL_SUB, otpctrl, 2);\n\t\t\tdelay(1);\n\t\t\t_enableClock(SYS_AUTO_CLOCK);\n\t\t\tdelay(5);\n\t\t\tpmscctrl0[0] = 0x00;\n\t\t\tpmscctrl0[1] &= 0x02;\n\t\t\t_writeBytesToRegister(PMSC, PMSC_CTRL0_SUB, pmscctrl0, 2);\n\t\t}\n\n\t\t/* Crystal calibration from OTP (if available)\n\t\t * FS_XTALT - reg:0x2B, sub-reg:0x0E\n\t\t * OTP(one-time-programmable) memory map - table 10 */\n\t\tvoid _fsxtalt()\n\t\t{\n\t\t\tbyte fsxtalt[LEN_FS_XTALT];\n\t\t\tbyte buf_otp[4];\n\t\t\t_readBytesOTP(0x01E, buf_otp); // 0x01E -> byte[0]=XTAL_Trim\n\t\t\tif (buf_otp[0] == 0)\n\t\t\t{\n\t\t\t\t// No trim value available from OTP, use midrange value of 0x10\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fsxtalt, ((0x10 & 0x1F) | 0x60), LEN_FS_XTALT);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fsxtalt, ((buf_otp[0] & 0x1F) | 0x60), LEN_FS_XTALT);\n\t\t\t}\n\t\t\t// write configuration back to chip\n\t\t\t_writeBytesToRegister(FS_CTRL, FS_XTALT_SUB, fsxtalt, LEN_FS_XTALT);\n\t\t}\n\n\t\tvoid _clearReceiveStatus()\n\t\t{\n\t\t\t// clear latched RX bits (i.e. write 1 to clear)\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXDFR_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXFCG_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXPRD_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXSFDD_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXPHD_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, LDEDONE_BIT, true);\n\t\t\t_writeBytesToRegister(SYS_STATUS, NO_SUB, _sysstatus, LEN_SYS_STATUS);\n\t\t}\n\n\t\tvoid _clearReceiveTimestampAvailableStatus()\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, LDEDONE_BIT, true);\n\t\t\t_writeBytesToRegister(SYS_STATUS, NO_SUB, _sysstatus, LEN_SYS_STATUS);\n\t\t}\n\n\t\tvoid _clearReceiveTimeoutStatus()\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXRFTO_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXPTO_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXSFDTO_BIT, true);\n\t\t\t_writeBytesToRegister(SYS_STATUS, NO_SUB, _sysstatus, LEN_SYS_STATUS);\n\t\t}\n\n\t\tvoid _clearReceiveFailedStatus()\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXPHE_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXFCE_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXRFSL_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, AFFREJ_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, LDEERR_BIT, true);\n\t\t\t_writeBytesToRegister(SYS_STATUS, NO_SUB, _sysstatus, LEN_SYS_STATUS);\n\t\t}\n\n\t\tvoid _clearTransmitStatus()\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, AAT_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, TXFRB_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, TXPRS_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, TXPHS_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, TXFRS_BIT, true);\n\t\t\t_writeBytesToRegister(SYS_STATUS, NO_SUB, _sysstatus, LEN_SYS_STATUS);\n\t\t}\n\n\t\tvoid _resetReceiver()\n\t\t{\n\t\t\t/* Set to 0 only bit 28 */\n\t\t\t_writeToRegister(PMSC, PMSC_SOFTRESET_SUB, 0xE0, LEN_PMSC_SOFTRESET);\n\t\t\t/* Set SOFTRESET to all ones */\n\t\t\t_writeToRegister(PMSC, PMSC_SOFTRESET_SUB, 0xF0, LEN_PMSC_SOFTRESET);\n\t\t}\n\n\t\t/* Internal helpers to read configuration */\n\n\t\tvoid _readSystemConfigurationRegister()\n\t\t{\n\t\t\t_readBytes(SYS_CFG, NO_SUB, _syscfg, LEN_SYS_CFG);\n\t\t}\n\n\t\tvoid _readSystemEventStatusRegister()\n\t\t{\n\t\t\t_readBytes(SYS_STATUS, NO_SUB, _sysstatus, LEN_SYS_STATUS);\n\t\t}\n\n\t\tvoid _readNetworkIdAndDeviceAddress()\n\t\t{\n\t\t\t_readBytes(PANADR, NO_SUB, _networkAndAddress, LEN_PANADR);\n\t\t}\n\n\t\tvoid _readSystemEventMaskRegister()\n\t\t{\n\t\t\t_readBytes(SYS_MASK, NO_SUB, _sysmask, LEN_SYS_MASK);\n\t\t}\n\n\t\tvoid _readChannelControlRegister()\n\t\t{\n\t\t\t_readBytes(CHAN_CTRL, NO_SUB, _chanctrl, LEN_CHAN_CTRL);\n\t\t}\n\n\t\tvoid _readTransmitFrameControlRegister()\n\t\t{\n\t\t\t_readBytes(TX_FCTRL, NO_SUB, _txfctrl, LEN_TX_FCTRL);\n\t\t}\n\n\t\tboolean _isTransmitDone()\n\t\t{\n\t\t\treturn DW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, TXFRS_BIT);\n\t\t}\n\n\t\tboolean _isReceiveTimestampAvailable()\n\t\t{\n\t\t\treturn DW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, LDEDONE_BIT);\n\t\t}\n\n\t\tboolean _isReceiveDone()\n\t\t{\n\t\t\tif (_frameCheck)\n\t\t\t{\n\t\t\t\treturn (DW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXFCG_BIT) &&\n\t\t\t\t\t\tDW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXDFR_BIT));\n\t\t\t}\n\t\t\treturn DW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXDFR_BIT);\n\t\t}\n\n\t\tboolean _isReceiveFailed()\n\t\t{\n\t\t\treturn (DW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXPHE_BIT) ||\n\t\t\t\t\tDW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXFCE_BIT) ||\n\t\t\t\t\tDW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXRFSL_BIT) ||\n\t\t\t\t\tDW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, LDEERR_BIT));\n\t\t}\n\n\t\tboolean _isReceiveTimeout()\n\t\t{\n\t\t\treturn (DW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXRFTO_BIT) ||\n\t\t\t\t\tDW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXPTO_BIT) ||\n\t\t\t\t\tDW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXSFDTO_BIT));\n\t\t}\n\n\t\tboolean _isClockProblem()\n\t\t{\n\t\t\treturn (DW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, CLKPLL_LL_BIT) ||\n\t\t\t\t\tDW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RFPLL_LL_BIT));\n\t\t}\n\n\t\tvoid _disableSequencing()\n\t\t{\n\t\t\t_enableClock(SYS_XTI_CLOCK);\n\t\t\tbyte zero[2];\n\t\t\tDW1000NgUtils::writeValueToBytes(zero, 0x0000, 2);\n\t\t\t_writeBytesToRegister(PMSC, PMSC_CTRL1_SUB, zero, 2); // To re-enable write 0xE7\n\t\t}\n\n\t\tvoid _configureRFTransmitPowerSpectrumTestMode()\n\t\t{\n\t\t\t/* Enabled TXFEN, PLLFEN, LDOFEN and set TXRXSW to TX */\n\t\t\tbyte enable_mask[4];\n\t\t\tDW1000NgUtils::writeValueToBytes(enable_mask, 0x005FFF00, LEN_RX_CONF_SUB);\n\t\t\t_writeBytesToRegister(RF_CONF, RF_CONF_SUB, enable_mask, LEN_RX_CONF_SUB);\n\t\t}\n\n\t\tvoid _uploadConfigToAON()\n\t\t{\n\t\t\t/* Write 1 in UPL_CFG_BIT */\n\t\t\t_writeToRegister(AON, AON_CTRL_SUB, 0x04, LEN_AON_CTRL);\n\t\t\t/* Clear the register */\n\t\t\t_writeToRegister(AON, AON_CTRL_SUB, 0x00, LEN_AON_CTRL);\n\t\t}\n\t}\n\n\t/* ####################### PUBLIC ###################### */\n\n\tvoid initialize(uint8_t ss, uint8_t irq, uint8_t rst)\n\t{\n\t\t// generous initial init/wake-up-idle delay\n\t\tdelay(5);\n\t\t_ss = ss;\n\t\t_irq = irq;\n\t\t_rst = rst;\n\n\t\tif (rst != 0xff)\n\t\t{\n\t\t\t// DW1000 data sheet v2.08 Â§5.6.1 page 20, the RSTn pin should not be driven high but left floating.\n\t\t\tpinMode(_rst, INPUT);\n\t\t}\n\n\t\tSPIporting::SPIinit();\n\t\t// pin and basic member setup\n\t\t// attach interrupt\n\t\t// TODO throw error if pin is not a interrupt pin\n\t\tif (_irq != 0xff)\n\t\t{\n\t\t\tattachInterrupt(digitalPinToInterrupt(_irq), interruptServiceRoutine, RISING);\n\t\t\t// attachInterrupt(digitalPinToInterrupt(_irq), interruptServiceRoutine, FALLING);\n\t\t}\n\n\t\tSPIporting::SPIselect(_ss, _irq);\n\t\t// reset chip (either soft or hard)\n\t\treset();\n\n\t\tSPIporting::setSPIspeed(SPIClock::SLOW);\n\t\t_enableClock(SYS_XTI_CLOCK);\n\t\tdelay(5);\n\n\t\t// Configure the CPLL lock detect\n\t\t_writeBitToRegister(EXT_SYNC, EC_CTRL_SUB, LEN_EC_CTRL, PLLLDT_BIT, true);\n\n\t\t// Configure XTAL trim\n\t\t_fsxtalt();\n\n\t\t// load LDE micro-code\n\t\t_manageLDE();\n\n\t\t// read the temp and vbat readings from OTP that were recorded during production test\n\t\t// see 6.3.1 OTP memory map\n\t\tbyte buf_otp[4];\n\t\t_readBytesOTP(0x008, buf_otp); // the stored 3.3 V reading\n\t\t_vmeas3v3 = buf_otp[0];\n\t\t// Serial.printf(\"_vmeas3v3=%d\\r\\n\", _vmeas3v3);\n\t\t_readBytesOTP(0x009, buf_otp); // the stored 23C reading\n\t\t_tmeas23C = buf_otp[0];\n\t\t// Serial.printf(\"_tmeas23C=%d\\r\\n\", _tmeas23C);\n\n\t\t_enableClock(SYS_AUTO_CLOCK);\n\t\tdelay(5);\n\t\tSPIporting::setSPIspeed(SPIClock::FAST);\n\n\t\t_readNetworkIdAndDeviceAddress();\n\t\t_readSystemConfigurationRegister();\n\t\t_readChannelControlRegister();\n\t\t_readTransmitFrameControlRegister();\n\t\t_readSystemEventMaskRegister();\n\n\t\t/* Cleared AON:CFG1(0x2C:0x0A) for proper operation of deepSleep */\n\t\t_writeToRegister(AON, AON_CFG1_SUB, 0x00, LEN_AON_CFG1);\n\t}\n\n\tvoid initializeNoInterrupt(uint8_t ss, uint8_t rst)\n\t{\n\t\tinitialize(ss, 0xff, rst);\n\t}\n\n\t/* callback handler management. */\n\tvoid attachErrorHandler(void (*handleError)(void))\n\t{\n\t\t_handleError = handleError;\n\t}\n\n\tvoid attachSentHandler(void (*handleSent)(void))\n\t{\n\t\t_handleSent = handleSent;\n\t}\n\n\tvoid attachReceivedHandler(void (*handleReceived)(void))\n\t{\n\t\t_handleReceived = handleReceived;\n\t}\n\n\tvoid attachReceiveFailedHandler(void (*handleReceiveFailed)(void))\n\t{\n\t\t_handleReceiveFailed = handleReceiveFailed;\n\t}\n\n\tvoid attachReceiveTimeoutHandler(void (*handleReceiveTimeout)(void))\n\t{\n\t\t_handleReceiveTimeout = handleReceiveTimeout;\n\t}\n\n\tvoid attachReceiveTimestampAvailableHandler(void (*handleReceiveTimestampAvailable)(void))\n\t{\n\t\t_handleReceiveTimestampAvailable = handleReceiveTimestampAvailable;\n\t}\n\n\tvoid interruptServiceRoutine()\n\t{\n\t\t// Serial.printf(\"test----------------------------0\\r\\n\");\n\t\t// read current status and handle via callbacks\n\t\t_readSystemEventStatusRegister();\n\t\tif (_isClockProblem() /* TODO and others */ && _handleError != 0)\n\t\t{\n\t\t\t(*_handleError)();\n\t\t\t// Serial.printf(\"interrupt----------------------------1\\r\\n\");\n\t\t}\n\t\tif (_isTransmitDone())\n\t\t{\n\t\t\t_clearTransmitStatus();\n\t\t\tif (_handleSent != nullptr)\n\t\t\t{\n\t\t\t\t(*_handleSent)();\n\t\t\t\t// Serial.printf(\"interrupt----------------------------2\\r\\n\");\n\t\t\t}\n\t\t}\n\t\tif (_isReceiveTimestampAvailable())\n\t\t{\n\t\t\t_clearReceiveTimestampAvailableStatus();\n\t\t\tif (_handleReceiveTimestampAvailable != nullptr)\n\t\t\t{\n\t\t\t\t(*_handleReceiveTimestampAvailable)();\n\t\t\t\t// Serial.printf(\"interrupt----------------------------3\\r\\n\");\n\t\t\t}\n\t\t}\n\t\tif (_isReceiveFailed())\n\t\t{\n\t\t\t_clearReceiveFailedStatus();\n\t\t\tforceTRxOff();\n\t\t\t_resetReceiver();\n\t\t\tif (_handleReceiveFailed != nullptr)\n\t\t\t{\n\t\t\t\t(*_handleReceiveFailed)();\n\t\t\t\t// Serial.printf(\"interrupt----------------------------4\\r\\n\");\n\t\t\t}\n\t\t}\n\t\telse if (_isReceiveTimeout())\n\t\t{\n\t\t\t_clearReceiveTimeoutStatus();\n\t\t\tforceTRxOff();\n\t\t\t_resetReceiver();\n\t\t\tif (_handleReceiveTimeout != nullptr)\n\t\t\t{\n\t\t\t\t(*_handleReceiveTimeout)();\n\t\t\t\t// Serial.printf(\"interrupt----------------------------5\\r\\n\");\n\t\t\t}\n\t\t}\n\t\telse if (_isReceiveDone())\n\t\t{\n\t\t\t_clearReceiveStatus();\n\t\t\tif (_handleReceived != nullptr)\n\t\t\t{\n\t\t\t\t(*_handleReceived)();\n\t\t\t\t// Serial.printf(\"interrupt----------------------------6\\r\\n\");\n\t\t\t}\n\t\t}\n\t\t// Latched bits in status register are reset by writing 1 to them\n\t\tmemset(_sysstatus, 0xff, LEN_SYS_STATUS);\n\t\t_writeBytesToRegister(SYS_STATUS, NO_SUB, _sysstatus, LEN_SYS_STATUS);\n\t}\n\n\tboolean isTransmitDone()\n\t{\n\t\t_readSystemEventStatusRegister();\n\t\treturn _isTransmitDone();\n\t}\n\n\tvoid clearTransmitStatus()\n\t{\n\t\t_clearTransmitStatus();\n\t}\n\n\tboolean isReceiveDone()\n\t{\n\t\t_readSystemEventStatusRegister();\n\t\treturn _isReceiveDone();\n\t}\n\n\tvoid clearReceiveStatus()\n\t{\n\t\t_clearReceiveStatus();\n\t}\n\n\tboolean isReceiveFailed()\n\t{\n\t\t_readSystemEventStatusRegister();\n\t\treturn _isReceiveFailed();\n\t}\n\n\tvoid clearReceiveFailedStatus()\n\t{\n\t\t_clearReceiveFailedStatus();\n\t\tforceTRxOff();\n\t\t_resetReceiver();\n\t}\n\n\tboolean isReceiveTimeout()\n\t{\n\t\t_readSystemEventMaskRegister();\n\t\treturn _isReceiveTimeout();\n\t}\n\n\tvoid clearReceiveTimeoutStatus()\n\t{\n\t\t_clearReceiveTimeoutStatus();\n\t\tforceTRxOff();\n\t\t_resetReceiver();\n\t}\n\n\tvoid enableDebounceClock()\n\t{\n\t\tbyte pmscctrl0[LEN_PMSC_CTRL0];\n\t\tmemset(pmscctrl0, 0, LEN_PMSC_CTRL0);\n\t\t_readBytes(PMSC, PMSC_CTRL0_SUB, pmscctrl0, LEN_PMSC_CTRL0);\n\t\tDW1000NgUtils::setBit(pmscctrl0, LEN_PMSC_CTRL0, GPDCE_BIT, 1);\n\t\tDW1000NgUtils::setBit(pmscctrl0, LEN_PMSC_CTRL0, KHZCLKEN_BIT, 1);\n\t\t_writeBytesToRegister(PMSC, PMSC_CTRL0_SUB, pmscctrl0, LEN_PMSC_CTRL0);\n\t\t_debounceClockEnabled = true;\n\t}\n\n\tvoid enableLedBlinking()\n\t{\n\t\tbyte pmscledc[LEN_PMSC_LEDC];\n\t\tmemset(pmscledc, 0, LEN_PMSC_LEDC);\n\t\t_readBytes(PMSC, PMSC_LEDC_SUB, pmscledc, LEN_PMSC_LEDC);\n\t\tDW1000NgUtils::setBit(pmscledc, LEN_PMSC_LEDC, BLNKEN, 1);\n\t\t_writeBytesToRegister(PMSC, PMSC_LEDC_SUB, pmscledc, LEN_PMSC_LEDC);\n\t}\n\n\tvoid setGPIOMode(uint8_t msgp, uint8_t mode)\n\t{\n\t\tbyte gpiomode[LEN_GPIO_MODE];\n\t\tmemset(gpiomode, 0, LEN_GPIO_MODE);\n\t\t_readBytes(GPIO_CTRL, GPIO_MODE_SUB, gpiomode, LEN_GPIO_MODE);\n\t\tfor (char i = 0; i < 2; i++)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(gpiomode, LEN_GPIO_MODE, msgp + i, (mode >> i) & 1);\n\t\t}\n\t\t_writeBytesToRegister(GPIO_CTRL, GPIO_MODE_SUB, gpiomode, LEN_GPIO_MODE);\n\t}\n\n\tvoid applySleepConfiguration(sleep_configuration_t sleep_config)\n\t{\n\t\tbyte aon_wcfg[LEN_AON_WCFG];\n\t\t_readBytes(AON, AON_WCFG_SUB, aon_wcfg, LEN_AON_WCFG);\n\t\tbyte aon_cfg0[1];\n\t\tmemset(aon_cfg0, 0, 1);\n\n\t\tDW1000NgUtils::setBit(aon_wcfg, LEN_AON_WCFG, ONW_RADC_BIT, sleep_config.onWakeUpRunADC);\n\t\tDW1000NgUtils::setBit(aon_wcfg, LEN_AON_WCFG, ONW_RX_BIT, sleep_config.onWakeUpReceive);\n\t\tDW1000NgUtils::setBit(aon_wcfg, LEN_AON_WCFG, ONW_LEUI_BIT, sleep_config.onWakeUpLoadEUI);\n\t\tDW1000NgUtils::setBit(aon_wcfg, LEN_AON_WCFG, ONW_LDC_BIT, true);\n\t\tDW1000NgUtils::setBit(aon_wcfg, LEN_AON_WCFG, ONW_L64P_BIT, sleep_config.onWakeUpLoadL64Param);\n\t\tDW1000NgUtils::setBit(aon_wcfg, LEN_AON_WCFG, ONW_PRES_SLEEP_BIT, sleep_config.preserveSleep);\n\t\tDW1000NgUtils::setBit(aon_wcfg, LEN_AON_WCFG, ONW_LLDE_BIT, true);\n\t\tDW1000NgUtils::setBit(aon_wcfg, LEN_AON_WCFG, ONW_LLDO_BIT, true);\n\t\t_writeBytesToRegister(AON, AON_WCFG_SUB, aon_wcfg, LEN_AON_WCFG);\n\n\t\tDW1000NgUtils::setBit(aon_cfg0, 1, WAKE_PIN_BIT, sleep_config.enableWakePIN);\n\t\tDW1000NgUtils::setBit(aon_cfg0, 1, WAKE_SPI_BIT, sleep_config.enableWakeSPI);\n\t\tDW1000NgUtils::setBit(aon_cfg0, 1, WAKE_CNT_BIT, false);\n\t\tDW1000NgUtils::setBit(aon_cfg0, 1, SLEEP_EN_BIT, sleep_config.enableSLP);\n\t\t_writeBytesToRegister(AON, AON_CFG0_SUB, aon_cfg0, 1); // Deletes 3 bits of the unused LPCLKDIVA\n\t}\n\n\t/*Puts the device into sleep/deepSleep mode. This function also upload sleep config to AON. */\n\tvoid deepSleep()\n\t{\n\t\t/* Clear the register */\n\t\t_writeToRegister(AON, AON_CTRL_SUB, 0x00, LEN_AON_CTRL);\n\t\t/* Write 1 in SAVE_BIT */\n\t\t_writeToRegister(AON, AON_CTRL_SUB, 0x02, LEN_AON_CTRL);\n\t}\n\n\tvoid spiWakeup()\n\t{\n\t\tbyte deviceId[LEN_DEV_ID];\n\t\tbyte expectedDeviceId[LEN_DEV_ID];\n\t\tDW1000NgUtils::writeValueToBytes(expectedDeviceId, 0xDECA0130, LEN_DEV_ID);\n\t\t_readBytes(DEV_ID, NO_SUB, deviceId, LEN_DEV_ID);\n\t\tif (memcmp(deviceId, expectedDeviceId, LEN_DEV_ID))\n\t\t{\n\t\t\tdigitalWrite(_ss, LOW);\n\t\t\tdelay(1);\n\t\t\tdigitalWrite(_ss, HIGH);\n\t\t\tdelay(5);\n\t\t\tsetTxAntennaDelay(_antennaTxDelay);\n\t\t\tif (_debounceClockEnabled)\n\t\t\t{\n\t\t\t\tenableDebounceClock();\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid reset()   \n\t{\n\t\tif (_rst == 0xff)\n\t\t{ /* Fallback to Software Reset */\n\t\t\tsoftwareReset();\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// DW1000Ng data sheet v2.08 Â§5.6.1 page 20, the RSTn pin should not be driven high but left floating.\n\t\t\tpinMode(_rst, OUTPUT);\n\t\t\tdigitalWrite(_rst, LOW);\n\t\t\tdelay(2); // DW1000Ng data sheet v2.08 Â§5.6.1 page 20: nominal 50ns, to be safe take more time\n\t\t\tpinMode(_rst, INPUT);\n\t\t\tdelay(5); // dw1000Ng data sheet v1.2 page 5: nominal 3 ms, to be safe take more time\n\t\t}\n\t}\n\n\tvoid softwareReset()\n\t{\n\t\tSPIporting::setSPIspeed(SPIClock::SLOW);\n\n\t\t/* Disable sequencing and go to state \"INIT\" - (a) Sets SYSCLKS to 01 */\n\t\t_disableSequencing();\n\t\t/* Clear AON and WakeUp configuration */\n\t\t_writeToRegister(AON, AON_WCFG_SUB, 0x00, LEN_AON_WCFG);\n\t\t_writeToRegister(AON, AON_CFG0_SUB, 0x00, LEN_AON_CFG0);\n\t\t// TODO change this with uploadToAON\n\t\t_writeToRegister(AON, AON_CTRL_SUB, 0x00, LEN_AON_CTRL);\n\t\t_writeToRegister(AON, AON_CTRL_SUB, 0x02, LEN_AON_CTRL);\n\t\t/* (b) Clear SOFTRESET to all zeroâ€™s */\n\t\t_writeToRegister(PMSC, PMSC_SOFTRESET_SUB, 0x00, LEN_PMSC_SOFTRESET);\n\t\tdelay(1);\n\t\t/* (c) Set SOFTRESET to all ones */\n\t\t_writeToRegister(PMSC, PMSC_SOFTRESET_SUB, 0xF0, LEN_PMSC_SOFTRESET);\n\t}\n\n\t/* ###########################################################################\n\t * #### Pretty printed device information ####################################\n\t * ######################################################################### */\n\n\tvoid getPrintableDeviceIdentifier(char msgBuffer[])\n\t{\n\t\tbyte data[LEN_DEV_ID];\n\t\t_readBytes(DEV_ID, NO_SUB, data, LEN_DEV_ID);\n\t\tsprintf(msgBuffer, \"%02X - model: %d, version: %d, revision: %d\",\n\t\t\t\t(uint16_t)((data[3] << 8) | data[2]), data[1], (data[0] >> 4) & 0x0F, data[0] & 0x0F);\n\t}\n\n\tvoid getPrintableExtendedUniqueIdentifier(char msgBuffer[])\n\t{\n\t\tbyte data[LEN_EUI];\n\t\t_readBytes(EUI, NO_SUB, data, LEN_EUI);\n\t\tsprintf(msgBuffer, \"%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X\",\n\t\t\t\tdata[7], data[6], data[5], data[4], data[3], data[2], data[1], data[0]);\n\t}\n\n\tvoid getPrintableNetworkIdAndShortAddress(char msgBuffer[])\n\t{\n\t\tbyte data[LEN_PANADR];\n\t\t_readBytes(PANADR, NO_SUB, data, LEN_PANADR);\n\t\tsprintf(msgBuffer, \"PAN: %02X, Short Address: %02X\",\n\t\t\t\t(uint16_t)((data[3] << 8) | data[2]), (uint16_t)((data[1] << 8) | data[0]));\n\t}\n\n\tvoid getPrintableDeviceMode(char msgBuffer[])\n\t{\n\t\tuint16_t dr;\n\t\tuint8_t prf;\n\t\tuint16_t plen;\n\t\tuint8_t pcode;\n\t\tuint8_t ch;\n\t\tbyte chan_ctrl[LEN_CHAN_CTRL];\n\t\tbyte tx_fctrl[LEN_TX_FCTRL];\n\t\t_readBytes(CHAN_CTRL, NO_SUB, chan_ctrl, LEN_CHAN_CTRL);\n\t\t_readBytes(TX_FCTRL, NO_SUB, tx_fctrl, LEN_TX_FCTRL);\n\t\t/* Data Rate from 0x08 bits:13-14(tx_fctrl) */\n\t\tdr = (uint16_t)(tx_fctrl[1] >> 5 & 0x3);\n\t\tswitch (dr)\n\t\t{\n\t\tcase 0x00:\n\t\t\tdr = 110;\n\t\t\tbreak;\n\t\tcase 0x01:\n\t\t\tdr = 850;\n\t\t\tbreak;\n\t\tcase 0x02:\n\t\t\tdr = 6800;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn; // TODO Error handling\n\t\t}\n\t\t/* PRF(16 or 64) from 0x1F bits:18-19(chan_ctrl) */\n\t\tprf = (uint8_t)(chan_ctrl[2] >> 2 & 0x03);\n\t\tif (prf == 0x01)\n\t\t{\n\t\t\tprf = 16;\n\t\t}\n\t\telse if (prf == 0x02)\n\t\t{\n\t\t\tprf = 64;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn; // TODO Error handling\n\t\t}\n\t\t/* PreambleLength from 0x08 bits:18-21(tx_fctrl) */\n\t\tplen = (uint16_t)(tx_fctrl[2] >> 2 & 0xF);\n\t\tswitch (plen)\n\t\t{\n\t\tcase 0x01:\n\t\t\tplen = 64;\n\t\t\tbreak;\n\t\tcase 0x05:\n\t\t\tplen = 128;\n\t\t\tbreak;\n\t\tcase 0x09:\n\t\t\tplen = 256;\n\t\t\tbreak;\n\t\tcase 0x0D:\n\t\t\tplen = 512;\n\t\t\tbreak;\n\t\tcase 0x02:\n\t\t\tplen = 1024;\n\t\t\tbreak;\n\t\tcase 0x06:\n\t\t\tplen = 1536;\n\t\t\tbreak;\n\t\tcase 0x0A:\n\t\t\tplen = 2048;\n\t\t\tbreak;\n\t\tcase 0x03:\n\t\t\tplen = 4096;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn; // TODO Error handling\n\t\t}\n\t\t/* Channel from 0x1F bits:0-4(tx_chan) */\n\t\tch = (uint8_t)(chan_ctrl[0] & 0xF);\n\t\t/* Preamble Code from 0x1F bits:24-31(chan_ctrl) */\n\t\tpcode = (uint8_t)(chan_ctrl[3] >> 3 & 0x1F);\n\t\tsprintf(msgBuffer, \"Data rate: %u kb/s, PRF: %u MHz, Preamble: %u symbols, Channel: #%u, Preamble code #%u\", dr, prf, plen, ch, pcode);\n\t}\n\n\t/* ###########################################################################\n\t * #### DW1000Ng operation functions ###########################################\n\t * ######################################################################### */\n\n\tvoid setNetworkId(uint16_t val)\n\t{\n\t\t_networkAndAddress[2] = (byte)(val & 0xFF);\n\t\t_networkAndAddress[3] = (byte)((val >> 8) & 0xFF);\n\t\t_writeNetworkIdAndDeviceAddress();\n\t}\n\n\tvoid getNetworkId(byte id[])\n\t{\n\t\t_readNetworkIdAndDeviceAddress();\n\t\tid[0] = _networkAndAddress[2];\n\t\tid[1] = _networkAndAddress[3];\n\t}\n\n\tvoid setDeviceAddress(uint16_t val)\n\t{\n\t\t_networkAndAddress[0] = (byte)(val & 0xFF);\n\t\t_networkAndAddress[1] = (byte)((val >> 8) & 0xFF);\n\t\t_writeNetworkIdAndDeviceAddress();\n\t}\n\n\tvoid getDeviceAddress(byte address[])\n\t{\n\t\t_readNetworkIdAndDeviceAddress();\n\t\taddress[0] = _networkAndAddress[0];\n\t\taddress[1] = _networkAndAddress[1];\n\t}\n\n\tvoid setEUI(char eui[])\n\t{\n\t\tbyte eui_byte[LEN_EUI];\n\t\tDW1000NgUtils::convertToByte(eui, eui_byte);\n\t\tsetEUI(eui_byte);\n\t}\n\n\tvoid setEUI(byte eui[])\n\t{\n\t\t// we reverse the address->\n\t\tbyte reverseEUI[8];\n\t\tuint8_t size = 8;\n\t\tfor (uint8_t i = 0; i < size; i++)\n\t\t{\n\t\t\t*(reverseEUI + i) = *(eui + size - i - 1);\n\t\t}\n\t\t_writeBytesToRegister(EUI, NO_SUB, reverseEUI, LEN_EUI);\n\t}\n\n\tvoid getEUI(byte eui[])\n\t{\n\t\t_readBytes(EUI, NO_SUB, eui, LEN_EUI);\n\t}\n\n\tfloat getTemperature()\n\t{\n\t\t_vbatAndTempSteps();\n\t\tbyte sar_ltemp = 0;\n\t\t_readBytes(TX_CAL, 0x04, &sar_ltemp, 1);\n\t\treturn (sar_ltemp - _tmeas23C) * 1.14f + 23.0f;\n\t}\n\n\tfloat getBatteryVoltage()\n\t{\n\t\t_vbatAndTempSteps();\n\t\tbyte sar_lvbat = 0;\n\t\t_readBytes(TX_CAL, 0x03, &sar_lvbat, 1);\n\t\treturn (sar_lvbat - _vmeas3v3) / 173.0f + 3.3f;\n\t}\n\n\tvoid getTemperatureAndBatteryVoltage(float &temp, float &vbat)\n\t{\n\t\t// follow the procedure from section 6.4 of the User Manual\n\t\t_vbatAndTempSteps();\n\t\tdelay(1);\n\t\tbyte sar_lvbat = 0;\n\t\t_readBytes(TX_CAL, 0x03, &sar_lvbat, 1);\n\t\tbyte sar_ltemp = 0;\n\t\t_readBytes(TX_CAL, 0x04, &sar_ltemp, 1);\n\n\t\t// calculate voltage and temperature\n\t\tvbat = (sar_lvbat - _vmeas3v3) / 173.0f + 3.3f;\n\t\ttemp = (sar_ltemp - _tmeas23C) * 1.14f + 23.0f;\n\t}\n\n\tvoid enableFrameFiltering(frame_filtering_configuration_t config)\n\t{\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFEN_BIT, true);\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFBC_BIT, config.behaveAsCoordinator);\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFAB_BIT, config.allowBeacon);\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFAD_BIT, config.allowData);\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFAA_BIT, config.allowAcknowledgement);\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFAM_BIT, config.allowMacCommand);\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFAR_BIT, config.allowAllReserved);\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFA4_BIT, config.allowReservedFour);\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFA5_BIT, config.allowReservedFive);\n\n\t\t_writeSystemConfigurationRegister();\n\t}\n\n\tvoid disableFrameFiltering()\n\t{\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFEN_BIT, false);\n\t\t_writeSystemConfigurationRegister();\n\t}\n\n\tvoid setDoubleBuffering(boolean val)\n\t{\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, DIS_DRXB_BIT, !val);\n\t}\n\n\tvoid setAntennaDelay(uint16_t value)\n\t{\n\t\t_antennaTxDelay = value;\n\t\t_antennaRxDelay = value;\n\t\t_writeAntennaDelayRegisters();\n\t}\n\n\tvoid setTxAntennaDelay(uint16_t value)\n\t{\n\t\t_antennaTxDelay = value;\n\t\t_writeAntennaDelayRegisters();\n\t}\n\tvoid setRxAntennaDelay(uint16_t value)\n\t{\n\t\t_antennaRxDelay = value;\n\t\t_writeAntennaDelayRegisters();\n\t}\n\n\tuint16_t getTxAntennaDelay()\n\t{\n\t\treturn _antennaTxDelay;\n\t}\n\tuint16_t getRxAntennaDelay()\n\t{\n\t\treturn _antennaRxDelay;\n\t}\n\n\tvoid forceTRxOff()\n\t{\n\t\tmemset(_sysctrl, 0, LEN_SYS_CTRL);\n\t\tDW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, TRXOFF_BIT, true);\n\t\t_writeBytesToRegister(SYS_CTRL, NO_SUB, _sysctrl, LEN_SYS_CTRL);\n\t}\n\n\tvoid startReceive(ReceiveMode mode)\n\t{\n\t\tmemset(_sysctrl, 0, LEN_SYS_CTRL);\n\t\tDW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, SFCST_BIT, !_frameCheck);\n\t\tif (mode == ReceiveMode::DELAYED)\n\t\t\tDW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, RXDLYS_BIT, true);\n\t\tDW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, RXENAB_BIT, true);\n\t\t_writeBytesToRegister(SYS_CTRL, NO_SUB, _sysctrl, LEN_SYS_CTRL);\n\t}\n\n\tvoid startTransmit(TransmitMode mode)\n\t{\n\t\tmemset(_sysctrl, 0, LEN_SYS_CTRL);\n\t\tDW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, SFCST_BIT, !_frameCheck);\n\t\tif (mode == TransmitMode::DELAYED)\n\t\t\tDW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, TXDLYS_BIT, true);\n\t\tif (_wait4resp)\n\t\t\tDW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, WAIT4RESP_BIT, true);\n\n\t\tDW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, TXSTRT_BIT, true);\n\t\t_writeBytesToRegister(SYS_CTRL, NO_SUB, _sysctrl, LEN_SYS_CTRL);\n\t}\n\n\tvoid setInterruptPolarity(boolean val)\n\t{\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, HIRQ_POL_BIT, val);\n\t\t_writeSystemConfigurationRegister();\n\t}\n\n\tvoid applyConfiguration(device_configuration_t config)\n\t{\n\t\tforceTRxOff();\n\n\t\t_useExtendedFrameLength(config.extendedFrameLength);\n\t\t_setReceiverAutoReenable(config.receiverAutoReenable);\n\t\t_useSmartPower(config.smartPower);\n\t\t_useFrameCheck(config.frameCheck);\n\t\t_setNlosOptimization(config.nlos);\n\t\t_setSFDMode(config.sfd);\n\t\t_setChannel(config.channel);\n\t\t_setDataRate(config.dataRate);\n\t\t_setPulseFrequency(config.pulseFreq);\n\t\t_setPreambleLength(config.preambleLen);\n\t\t_setPreambleCode(config.preaCode);\n\n\t\tif (!_checkPreambleCodeValidity())\n\t\t\t_setValidPreambleCode();\n\n\t\tif (!_standardSFD)\n\t\t\t_setNonStandardSFDLength();\n\n\t\t// writes configuration to registers\n\t\t_writeConfiguration();\n\t\t// tune according to configuration\n\t\t_tune();\n\t}\n\n\tChannel getChannel()\n\t{\n\t\treturn _channel;\n\t}\n\n\tPulseFrequency getPulseFrequency()\n\t{\n\t\treturn _pulseFrequency;\n\t}\n\n\tvoid setPreambleDetectionTimeout(uint16_t pacSize)\n\t{\n\t\tbyte drx_pretoc[LEN_DRX_PRETOC];\n\t\tDW1000NgUtils::writeValueToBytes(drx_pretoc, pacSize, LEN_DRX_PRETOC);\n\t\t_writeBytesToRegister(DRX_TUNE, DRX_PRETOC_SUB, drx_pretoc, LEN_DRX_PRETOC);\n\t}\n\n\tvoid setSfdDetectionTimeout(uint16_t preambleSymbols)\n\t{\n\t\tbyte drx_sfdtoc[LEN_DRX_SFDTOC];\n\t\tDW1000NgUtils::writeValueToBytes(drx_sfdtoc, preambleSymbols, LEN_DRX_SFDTOC);\n\t\t_writeBytesToRegister(DRX_TUNE, DRX_SFDTOC_SUB, drx_sfdtoc, LEN_DRX_SFDTOC);\n\t}\n\n\tvoid setReceiveFrameWaitTimeoutPeriod(uint16_t timeMicroSeconds)\n\t{\n\t\tif (timeMicroSeconds > 0)\n\t\t{\n\t\t\tbyte rx_wfto[LEN_RX_WFTO];\n\t\t\tDW1000NgUtils::writeValueToBytes(rx_wfto, timeMicroSeconds, LEN_RX_WFTO);\n\t\t\t_writeBytesToRegister(RX_WFTO, NO_SUB, rx_wfto, LEN_RX_WFTO);\n\t\t\t/* enable frame wait timeout bit */\n\t\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, RXWTOE_BIT, true);\n\t\t\t_writeSystemConfigurationRegister();\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* disable frame wait timeout bit */\n\t\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, RXWTOE_BIT, false);\n\t\t\t_writeSystemConfigurationRegister();\n\t\t}\n\t}\n\n\tvoid applyInterruptConfiguration(interrupt_configuration_t interrupt_config)\n\t{\n\t\tforceTRxOff();\n\n\t\t_interruptOnSent(interrupt_config.interruptOnSent);\n\t\t_interruptOnReceived(interrupt_config.interruptOnReceived);\n\t\t_interruptOnReceiveFailed(interrupt_config.interruptOnReceiveFailed);\n\t\t_interruptOnReceiveTimeout(interrupt_config.interruptOnReceiveTimeout);\n\t\t_interruptOnReceiveTimestampAvailable(interrupt_config.interruptOnReceiveTimestampAvailable);\n\t\t_interruptOnAutomaticAcknowledgeTrigger(interrupt_config.interruptOnAutomaticAcknowledgeTrigger);\n\n\t\t_writeSystemEventMaskRegister();\n\t}\n\n\tvoid setWait4Response(uint32_t timeMicroSeconds)\n\t{\n\t\t_wait4resp = timeMicroSeconds == 0 ? false : true;\n\n\t\t/* Check if it overflows 20 bits */\n\t\tif (timeMicroSeconds > 1048575)\n\t\t\ttimeMicroSeconds = 1048575;\n\n\t\tbyte W4R_TIME[LEN_ACK_RESP_T_W4R_TIME_SUB];\n\t\tDW1000NgUtils::writeValueToBytes(W4R_TIME, timeMicroSeconds, LEN_ACK_RESP_T_W4R_TIME_SUB);\n\t\tW4R_TIME[2] &= 0x0F;\n\t\t_writeBytesToRegister(ACK_RESP_T, ACK_RESP_T_W4R_TIME_SUB, W4R_TIME, LEN_ACK_RESP_T_W4R_TIME_SUB);\n\t}\n\n\tvoid setTXPower(byte power[])\n\t{\n\t\t// TODO Check byte length\n\t\t_writeBytesToRegister(TX_POWER, NO_SUB, power, LEN_TX_POWER);\n\t\t_autoTXPower = false;\n\t}\n\n\tvoid setTXPower(int32_t power)\n\t{\n\t\tbyte txpower[LEN_TX_POWER];\n\t\tDW1000NgUtils::writeValueToBytes(txpower, power, LEN_TX_POWER);\n\t\tsetTXPower(txpower);\n\t}\n\n\tvoid setTXPower(DriverAmplifierValue driver_amplifier, TransmitMixerValue mixer)\n\t{\n\t\tbyte txpower[LEN_TX_POWER];\n\t\tbyte pwr = 0x00;\n\n\t\tpwr |= ((byte)driver_amplifier << 5);\n\t\tpwr |= (byte)mixer;\n\n\t\tfor (auto i = 0; i < LEN_TX_POWER; i++)\n\t\t{\n\t\t\ttxpower[i] = pwr;\n\t\t}\n\n\t\tsetTXPower(txpower);\n\t}\n\n\tvoid setTXPowerAuto()\n\t{\n\t\t_autoTXPower = true;\n\t\t_txpowertune();\n\t}\n\n\tvoid setTCPGDelay(byte tcpgdelay)\n\t{\n\t\tbyte tcpgBytes[LEN_TC_PGDELAY];\n\t\tDW1000NgUtils::writeValueToBytes(tcpgBytes, tcpgdelay, LEN_TC_PGDELAY);\n\t\t_writeBytesToRegister(TX_CAL, TC_PGDELAY_SUB, tcpgBytes, LEN_TC_PGDELAY);\n\t\t_autoTCPGDelay = false;\n\t}\n\n\tvoid setTCPGDelayAuto()\n\t{\n\t\t_tcpgdelaytune();\n\t\t_autoTCPGDelay = true;\n\t}\n\n\tvoid enableTransmitPowerSpectrumTestMode(int32_t repeat_interval)\n\t{\n\t\t/* DW1000 clocks must be set to crystal speed so SPI rate have to be lowered and will\n\t\tnot be increased again */\n\t\tSPIporting::setSPIspeed(SPIClock::SLOW);\n\n\t\t_disableSequencing();\n\t\t_configureRFTransmitPowerSpectrumTestMode();\n\t\t_enableClock(SYS_PLL_CLOCK);\n\t\t_enableClock(TX_PLL_CLOCK);\n\n\t\tif (repeat_interval < 4)\n\t\t\trepeat_interval = 4;\n\n\t\t/* In diagnostic transmit power  mode (set next) the bytes 31:0 only are used for DX_TIME register */\n\t\tbyte delayBytes[4];\n\t\tDW1000NgUtils::writeValueToBytes(delayBytes, repeat_interval, 4);\n\t\t_writeBytesToRegister(DX_TIME, NO_SUB, delayBytes, 4);\n\n\t\t/* Enable Transmit Power Spectrum Test Mode */\n\t\tbyte diagnosticBytes[2];\n\t\tDW1000NgUtils::writeValueToBytes(diagnosticBytes, 0x0010, LEN_DIAG_TMC);\n\t\t_writeBytesToRegister(DIG_DIAG, DIAG_TMC_SUB, diagnosticBytes, LEN_DIAG_TMC);\n\t}\n\n\tvoid setDelayedTRX(byte futureTimeBytes[])\n\t{\n\t\t/* the least significant 9-bits are ignored in DX_TIME in functional modes */\n\t\t_writeBytesToRegister(DX_TIME, NO_SUB, futureTimeBytes, LEN_DX_TIME);\n\t}\n\n\tvoid setTransmitData(byte data[], uint16_t n)\n\t{\n\t\tif (_frameCheck)\n\t\t{\n\t\t\tn += 2; // two bytes CRC-16\n\t\t}\n\t\tif (n > LEN_EXT_UWB_FRAMES)\n\t\t{\n\t\t\treturn; // TODO proper error handling: frame/buffer size\n\t\t}\n\t\tif (n > LEN_UWB_FRAMES && !_extendedFrameLength)\n\t\t{\n\t\t\treturn; // TODO proper error handling: frame/buffer size\n\t\t}\n\t\t// transmit data and length\n\t\t_writeBytesToRegister(TX_BUFFER, NO_SUB, data, n);\n\n\t\t/* Sets up transmit frame control length based on data length */\n\t\t_txfctrl[0] = (byte)(n & 0xFF); // 1 byte (regular length + 1 bit)\n\t\t_txfctrl[1] &= 0xE0;\n\t\t_txfctrl[1] |= (byte)((n >> 8) & 0x03); // 2 added bits if extended length\n\t\t_writeTransmitFrameControlRegister();\n\t}\n\n\tvoid setTransmitData(const String &data)\n\t{\n\t\tuint16_t n = data.length() + 1;\n\t\tbyte *dataBytes = (byte *)malloc(n);\n\t\tdata.getBytes(dataBytes, n);\n\t\tsetTransmitData(dataBytes, n);\n\t\tfree(dataBytes);\n\t}\n\n\t// TODO reorder\n\tuint16_t getReceivedDataLength()\n\t{\n\t\tuint16_t len = 0;\n\n\t\t// 10 bits of RX frame control register\n\t\tbyte rxFrameInfo[LEN_RX_FINFO];\n\t\t_readBytes(RX_FINFO, NO_SUB, rxFrameInfo, LEN_RX_FINFO);\n\t\tlen = ((((uint16_t)rxFrameInfo[1] << 8) | (uint16_t)rxFrameInfo[0]) & 0x03FF);\n\n\t\tif (_frameCheck && len > 2)\n\t\t{\n\t\t\treturn len - 2;\n\t\t}\n\t\treturn len;\n\t}\n\n\tvoid getReceivedData(byte data[], uint16_t n)\n\t{\n\t\tif (n <= 0)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\t_readBytes(RX_BUFFER, NO_SUB, data, n);\n\t}\n\n\tvoid getReceivedData(String &data)\n\t{\n\t\tuint16_t i;\n\t\tuint16_t n = getReceivedDataLength(); // number of bytes w/o the two FCS ones\n\t\tif (n <= 0)\n\t\t{ // TODO\n\t\t\treturn;\n\t\t}\n\t\tbyte *dataBytes = (byte *)malloc(n);\n\t\tgetReceivedData(dataBytes, n);\n\t\t// clear string\n\t\tdata.remove(0);\n\t\tdata = \"\";\n\t\t// append to string\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tdata += (char)dataBytes[i];\n\t\t}\n\t\tfree(dataBytes);\n\t}\n\n\tuint64_t getTransmitTimestamp()\n\t{\n\t\tbyte data[LENGTH_TIMESTAMP];\n\t\tmemset(data, 0, LENGTH_TIMESTAMP);\n\t\t_readBytes(TX_TIME, TX_STAMP_SUB, data, LEN_TX_STAMP);\n\t\treturn DW1000NgUtils::bytesAsValue(data, LEN_TX_STAMP);\n\t}\n\n\tuint64_t getReceiveTimestamp()\n\t{\n\t\tbyte data[LEN_RX_STAMP];\n\t\tmemset(data, 0, LEN_RX_STAMP);\n\t\t_readBytes(RX_TIME, RX_STAMP_SUB, data, LEN_RX_STAMP);\n\t\treturn DW1000NgUtils::bytesAsValue(data, LEN_RX_STAMP);\n\t}\n\n\tuint64_t getSystemTimestamp()\n\t{\n\t\tbyte data[LEN_SYS_TIME];\n\t\tmemset(data, 0, LEN_SYS_TIME);\n\t\t_readBytes(SYS_TIME, NO_SUB, data, LEN_SYS_TIME);\n\t\treturn DW1000NgUtils::bytesAsValue(data, LEN_SYS_TIME);\n\t}\n\n\tfloat getReceiveQuality()\n\t{\n\t\tbyte noiseBytes[LEN_STD_NOISE];\n\t\tbyte fpAmpl2Bytes[LEN_FP_AMPL2];\n\t\tuint16_t noise, f2;\n\t\t_readBytes(RX_FQUAL, STD_NOISE_SUB, noiseBytes, LEN_STD_NOISE);\n\t\t_readBytes(RX_FQUAL, FP_AMPL2_SUB, fpAmpl2Bytes, LEN_FP_AMPL2);\n\t\tnoise = (uint16_t)noiseBytes[0] | ((uint16_t)noiseBytes[1] << 8);\n\t\tf2 = (uint16_t)fpAmpl2Bytes[0] | ((uint16_t)fpAmpl2Bytes[1] << 8);\n\t\treturn (float)f2 / noise;\n\t}\n\n\tfloat getFirstPathPower()\n\t{\n\t\tbyte fpAmpl1Bytes[LEN_FP_AMPL1];\n\t\tbyte fpAmpl2Bytes[LEN_FP_AMPL2];\n\t\tbyte fpAmpl3Bytes[LEN_FP_AMPL3];\n\t\tbyte rxFrameInfo[LEN_RX_FINFO];\n\t\tuint16_t f1, f2, f3, N;\n\t\tfloat A, corrFac;\n\t\t_readBytes(RX_TIME, FP_AMPL1_SUB, fpAmpl1Bytes, LEN_FP_AMPL1);\n\t\t_readBytes(RX_FQUAL, FP_AMPL2_SUB, fpAmpl2Bytes, LEN_FP_AMPL2);\n\t\t_readBytes(RX_FQUAL, FP_AMPL3_SUB, fpAmpl3Bytes, LEN_FP_AMPL3);\n\t\t_readBytes(RX_FINFO, NO_SUB, rxFrameInfo, LEN_RX_FINFO);\n\t\tf1 = (uint16_t)fpAmpl1Bytes[0] | ((uint16_t)fpAmpl1Bytes[1] << 8);\n\t\tf2 = (uint16_t)fpAmpl2Bytes[0] | ((uint16_t)fpAmpl2Bytes[1] << 8);\n\t\tf3 = (uint16_t)fpAmpl3Bytes[0] | ((uint16_t)fpAmpl3Bytes[1] << 8);\n\t\tN = (((uint16_t)rxFrameInfo[2] >> 4) & 0xFF) | ((uint16_t)rxFrameInfo[3] << 4);\n\n\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t{\n\t\t\tA = 113.77;\n\t\t\tcorrFac = 2.3334;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tA = 121.74;\n\t\t\tcorrFac = 1.1667;\n\t\t}\n\t\tfloat estFpPwr = 10.0 * log10(((float)f1 * (float)f1 + (float)f2 * (float)f2 + (float)f3 * (float)f3) / ((float)N * (float)N)) - A;\n\t\tif (estFpPwr <= -88)\n\t\t{\n\t\t\treturn estFpPwr;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// approximation of Fig. 22 in user manual for dbm correction\n\t\t\testFpPwr += (estFpPwr + 88) * corrFac;\n\t\t}\n\t\treturn estFpPwr;\n\t}\n\n\tfloat getReceivePower()\n\t{\n\t\tbyte cirPwrBytes[LEN_CIR_PWR];\n\t\tbyte rxFrameInfo[LEN_RX_FINFO];\n\t\tuint32_t twoPower17 = 131072;\n\t\tuint16_t C, N;\n\t\tfloat A, corrFac;\n\t\t_readBytes(RX_FQUAL, CIR_PWR_SUB, cirPwrBytes, LEN_CIR_PWR);\n\t\t_readBytes(RX_FINFO, NO_SUB, rxFrameInfo, LEN_RX_FINFO);\n\t\tC = (uint16_t)cirPwrBytes[0] | ((uint16_t)cirPwrBytes[1] << 8);\n\t\tN = (((uint16_t)rxFrameInfo[2] >> 4) & 0xFF) | ((uint16_t)rxFrameInfo[3] << 4);\n\n\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t{\n\t\t\tA = 113.77;\n\t\t\tcorrFac = 2.3334;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tA = 121.74;\n\t\t\tcorrFac = 1.1667;\n\t\t}\n\n\t\tfloat estRxPwr = 10.0 * log10(((float)C * (float)twoPower17) / ((float)N * (float)N)) - A;\n\t\tif (estRxPwr <= -88)\n\t\t{\n\t\t\treturn estRxPwr;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// approximation of Fig. 22 in user manual for dbm correction\n\t\t\testRxPwr += (estRxPwr + 88) * corrFac;\n\t\t}\n\t\treturn estRxPwr;\n\t}\n\n#if DW1000NG_DEBUG\n\tvoid getPrettyBytes(byte data[], char msgBuffer[], uint16_t n)\n\t{\n\t\tuint16_t i, j, b;\n\t\tb = sprintf(msgBuffer, \"Data, bytes: %d\\nB: 7 6 5 4 3 2 1 0\\n\", n); // TODO - type\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tbyte curByte = data[i];\n\t\t\tsnprintf(&msgBuffer[b++], 2, \"%d\", (i + 1));\n\t\t\tmsgBuffer[b++] = (char)((i + 1) & 0xFF);\n\t\t\tmsgBuffer[b++] = ':';\n\t\t\tmsgBuffer[b++] = ' ';\n\t\t\tfor (j = 0; j < 8; j++)\n\t\t\t{\n\t\t\t\tmsgBuffer[b++] = ((curByte >> (7 - j)) & 0x01) ? '1' : '0';\n\t\t\t\tif (j < 7)\n\t\t\t\t{\n\t\t\t\t\tmsgBuffer[b++] = ' ';\n\t\t\t\t}\n\t\t\t\telse if (i < n - 1)\n\t\t\t\t{\n\t\t\t\t\tmsgBuffer[b++] = '\\n';\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmsgBuffer[b++] = '\\0';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmsgBuffer[b++] = '\\0';\n\t}\n\n\tvoid getPrettyBytes(byte cmd, uint16_t offset, char msgBuffer[], uint16_t n)\n\t{\n\t\tuint16_t i, j, b;\n\t\tbyte *readBuf = (byte *)malloc(n);\n\t\t_readBytes(cmd, offset, readBuf, n);\n\t\tb = sprintf(msgBuffer, \"Reg: 0x%02x, bytes: %d\\nB: 7 6 5 4 3 2 1 0\\n\", cmd, n); // TODO - tpye\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tbyte curByte = readBuf[i];\n\t\t\tsnprintf(&msgBuffer[b++], 2, \"%d\", (i + 1));\n\t\t\tmsgBuffer[b++] = (char)((i + 1) & 0xFF);\n\t\t\tmsgBuffer[b++] = ':';\n\t\t\tmsgBuffer[b++] = ' ';\n\t\t\tfor (j = 0; j < 8; j++)\n\t\t\t{\n\t\t\t\tmsgBuffer[b++] = ((curByte >> (7 - j)) & 0x01) ? '1' : '0';\n\t\t\t\tif (j < 7)\n\t\t\t\t{\n\t\t\t\t\tmsgBuffer[b++] = ' ';\n\t\t\t\t}\n\t\t\t\telse if (i < n - 1)\n\t\t\t\t{\n\t\t\t\t\tmsgBuffer[b++] = '\\n';\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmsgBuffer[b++] = '\\0';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmsgBuffer[b++] = '\\0';\n\t\tfree(readBuf);\n\t}\n#endif\n}"}}}Content-Length: 175

{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"}}}
>>>
Content-Length: 183

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///c:/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","diagnostics":[]},"jsonrpc":"2.0"}
<<<
Content-Length: 228

{"jsonrpc":"2.0","id":120,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":53,"character":23}}}
>>>
Content-Length: 771

{"id":120,"result":{"contents":{"kind":"markdown","value":"### function `initializeNoInterrupt`  \n\n---\nâ†’ `void`  \nParameters:  \n- `uint8_t ss`\n- `uint8_t rst = 255`\n\nInitiates and starts a sessions with a DW1000 without interrupt. If rst is not set or value 0xff, a soft resets (i.e. command triggered) are used and it is assumed that no reset line is wired.  \n@param[in] ss The SPI Selection pin used to identify the specific connection  \n@param[in] rst The reset line/pin for hard resets of ICs that connect to the Arduino. Value 0xff means soft reset.  \n\n---\n```cpp\n// In namespace DW1000Ng\nvoid initializeNoInterrupt(uint8_t ss, uint8_t rst = 255)\n```"},"range":{"start":{"line":53,"character":12},"end":{"line":53,"character":33}}},"jsonrpc":"2.0"}
<<<
Content-Length: 233

{"jsonrpc":"2.0","id":121,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":54,"character":25}}}
>>>
Content-Length: 38

{"id":121,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 228

{"jsonrpc":"2.0","id":122,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":54,"character":24}}}
>>>
Content-Length: 40

{"id":122,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 233

{"jsonrpc":"2.0","id":123,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":53,"character":24}}}
>>>
Content-Length: 215

{"id":123,"result":[{"uri":"file:///C:/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","range":{"start":{"line":1643,"character":6},"end":{"line":1643,"character":27}}}],"jsonrpc":"2.0"}
<<<
Content-Length: 82613

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","languageId":"cpp","version":1,"text":"/*\n * MIT License\n *\n * Copyright (c) 2018 Michele Biondi, Andrea Salvatori\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n/*\n * Copyright (c) 2015 by Thomas Trojer <thomas@trojer.net>\n * Decawave DW1000Ng library for arduino.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @file DW1000Ng.cpp\n * Arduino driver library (source file) for the Decawave DW1000Ng UWB transceiver Module.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"DW1000Ng.hpp\"\n#include \"DW1000NgUtils.hpp\"\n#include \"DW1000NgConstants.hpp\"\n#include \"DW1000NgRegisters.hpp\"\n#include \"SPIporting.hpp\"\n\nnamespace DW1000Ng\n{\n\n\t/* anonymous namespace to host private-like variables and methods */\n\tnamespace\n\t{\n\n\t\t/* ########################### PRIVATE VARIABLES ################################# */\n\n\t\t/* SPI select pin and interrupt pin*/\n\t\tuint8_t _ss = 0xff;\n\t\tuint8_t _irq = 0xff;\n\t\tuint8_t _rst = 0xff;\n\n\t\t/* IRQ callbacks */\n\t\tvoid (*_handleSent)(void) = nullptr;\n\t\tvoid (*_handleError)(void) = nullptr;\n\t\tvoid (*_handleReceived)(void) = nullptr;\n\t\tvoid (*_handleReceiveFailed)(void) = nullptr;\n\t\tvoid (*_handleReceiveTimeout)(void) = nullptr;\n\t\tvoid (*_handleReceiveTimestampAvailable)(void) = nullptr;\n\n\t\t/* registers */\n\t\tbyte _syscfg[LEN_SYS_CFG];\n\t\tbyte _sysctrl[LEN_SYS_CTRL];\n\t\tbyte _sysstatus[LEN_SYS_STATUS];\n\t\tbyte _txfctrl[LEN_TX_FCTRL];\n\t\tbyte _sysmask[LEN_SYS_MASK];\n\t\tbyte _chanctrl[LEN_CHAN_CTRL];\n\t\tbyte _networkAndAddress[LEN_PANADR];\n\n\t\t/* Temperature and Voltage monitoring */\n\t\tbyte _vmeas3v3 = 0;\n\t\tbyte _tmeas23C = 0;\n\n\t\t/* Driver Internal State Trackers */\n\t\tbyte _extendedFrameLength;\n\t\tPacSize _pacSize;\n\t\tPulseFrequency _pulseFrequency;\n\t\tDataRate _dataRate;\n\t\tPreambleLength _preambleLength;\n\t\tPreambleCode _preambleCode;\n\t\tChannel _channel;\n\t\tboolean _smartPower;\n\t\tboolean _frameCheck;\n\t\tboolean _debounceClockEnabled = false;\n\t\tboolean _nlos = false;\n\t\tboolean _standardSFD = true;\n\t\tboolean _autoTXPower = true;\n\t\tboolean _autoTCPGDelay = true;\n\t\tboolean _wait4resp = false;\n\t\tuint16_t _antennaTxDelay = 0;\n\t\tuint16_t _antennaRxDelay = 0;\n\n\t\t/* ############################# PRIVATE METHODS ################################### */\n\t\t/*\n\t\t * Write bytes to the DW1000Ng. Single bytes can be written to registers via sub-addressing.\n\t\t * @param cmd\n\t\t * \t\tThe register address (see Chapter 7 in the DW1000Ng user manual).\n\t\t * @param offset\n\t\t *\t\tThe offset to select register sub-parts for writing, or 0x00 to disable\n\t\t * \t\tsub-adressing.\n\t\t * @param data\n\t\t *\t\tThe data array to be written.\n\t\t * @param data_size\n\t\t *\t\tThe number of bytes to be written (take care not to go out of bounds of\n\t\t * \t\tthe register).\n\t\t */\n\t\t// TODO offset really bigger than byte?\n\n\t\tvoid _writeBytesToRegister(byte cmd, uint16_t offset, byte data[], uint16_t data_size)\n\t\t{\n\t\t\tbyte header[3];\n\t\t\tuint8_t headerLen = 1;\n\n\t\t\t// TODO proper error handling: address out of bounds\n\t\t\t// build SPI header\n\t\t\tif (offset == NO_SUB)\n\t\t\t{\n\t\t\t\theader[0] = WRITE | cmd;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\theader[0] = WRITE_SUB | cmd;\n\t\t\t\tif (offset < 128)\n\t\t\t\t{\n\t\t\t\t\theader[1] = (byte)offset;\n\t\t\t\t\theaderLen++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\theader[1] = RW_SUB_EXT | (byte)offset;\n\t\t\t\t\theader[2] = (byte)(offset >> 7);\n\t\t\t\t\theaderLen += 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSPIporting::writeToSPI(_ss, headerLen, header, data_size, data);\n\t\t}\n\n\t\tvoid _writeToRegister(byte cmd, uint16_t offset, uint32_t data, uint16_t data_size)\n\t\t{\n\t\t\tbyte dataBytes[data_size];\n\t\t\tDW1000NgUtils::writeValueToBytes(dataBytes, data, data_size);\n\t\t\t_writeBytesToRegister(cmd, offset, dataBytes, data_size);\n\t\t}\n\n\t\t// Helper to set a single register\n\t\tvoid _writeByte(byte cmd, uint16_t offset, byte data)\n\t\t{\n\t\t\t_writeBytesToRegister(cmd, offset, &data, 1);\n\t\t}\n\n\t\t/*\n\t\t * Read bytes from the DW1000Ng. Number of bytes depend on register length.\n\t\t * @param cmd\n\t\t * \t\tThe register address (see Chapter 7 in the DW1000Ng user manual).\n\t\t * @param data\n\t\t *\t\tThe data array to be read into.\n\t\t * @param n\n\t\t *\t\tThe number of bytes expected to be received.\n\t\t */\n\t\t// TODO incomplete doc\n\t\tvoid _readBytes(byte cmd, uint16_t offset, byte data[], uint16_t data_size)\n\t\t{\n\t\t\tbyte header[3];\n\t\t\tuint8_t headerLen = 1;\n\n\t\t\t// build SPI header\n\t\t\tif (offset == NO_SUB)\n\t\t\t{\n\t\t\t\theader[0] = READ | cmd;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\theader[0] = READ_SUB | cmd;\n\t\t\t\tif (offset < 128)\n\t\t\t\t{\n\t\t\t\t\theader[1] = (byte)offset;\n\t\t\t\t\theaderLen++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\theader[1] = RW_SUB_EXT | (byte)offset;\n\t\t\t\t\theader[2] = (byte)(offset >> 7);\n\t\t\t\t\theaderLen += 2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSPIporting::readFromSPI(_ss, headerLen, header, data_size, data);\n\t\t}\n\n\t\t// always 4 bytes\n\t\t// TODO why always 4 bytes? can be different, see p. 58 table 10 otp memory map\n\t\tvoid _readBytesOTP(uint16_t address, byte data[])\n\t\t{\n\t\t\tbyte addressBytes[LEN_OTP_ADDR];\n\n\t\t\t// p60 - 6.3.3 Reading a value from OTP memory\n\t\t\t// bytes of address\n\t\t\taddressBytes[0] = (address & 0xFF);\n\t\t\taddressBytes[1] = ((address >> 8) & 0xFF);\n\t\t\t// set address\n\t\t\t_writeBytesToRegister(OTP_IF, OTP_ADDR_SUB, addressBytes, LEN_OTP_ADDR);\n\t\t\t// switch into read mode\n\t\t\t_writeByte(OTP_IF, OTP_CTRL_SUB, 0x03); // OTPRDEN | OTPREAD\n\t\t\t_writeByte(OTP_IF, OTP_CTRL_SUB, 0x01); // OTPRDEN\n\t\t\t// read value/block - 4 bytes\n\t\t\t_readBytes(OTP_IF, OTP_RDAT_SUB, data, LEN_OTP_RDAT);\n\t\t\t// end read mode\n\t\t\t_writeByte(OTP_IF, OTP_CTRL_SUB, 0x00);\n\t\t}\n\n\t\tvoid _writeBitToRegister(byte bitRegister, uint16_t RegisterOffset, uint16_t bitRegister_LEN, uint16_t selectedBit, boolean value)\n\t\t{\n\t\t\tuint16_t idx;\n\t\t\tuint8_t bitPosition;\n\n\t\t\tidx = selectedBit / 8;\n\t\t\tif (idx >= bitRegister_LEN)\n\t\t\t{\n\t\t\t\treturn; // TODO proper error handling: out of bounds\n\t\t\t}\n\t\t\tbyte targetByte;\n\t\t\tmemset(&targetByte, 0, 1);\n\t\t\tbitPosition = selectedBit % 8;\n\t\t\t_readBytes(bitRegister, RegisterOffset + idx, &targetByte, 1);\n\n\t\t\tvalue ? bitSet(targetByte, bitPosition) : bitClear(targetByte, bitPosition);\n\n\t\t\tif (RegisterOffset == NO_SUB)\n\t\t\t\tRegisterOffset = 0x00;\n\n\t\t\t_writeBytesToRegister(bitRegister, RegisterOffset + idx, &targetByte, 1);\n\t\t}\n\n\t\tvoid _enableClock(byte clock)\n\t\t{\n\t\t\tbyte pmscctrl0[LEN_PMSC_CTRL0];\n\t\t\tmemset(pmscctrl0, 0, LEN_PMSC_CTRL0);\n\t\t\t_readBytes(PMSC, PMSC_CTRL0_SUB, pmscctrl0, LEN_PMSC_CTRL0);\n\t\t\tif (clock == SYS_AUTO_CLOCK)\n\t\t\t{\n\t\t\t\tpmscctrl0[0] = SYS_AUTO_CLOCK;\n\t\t\t\tpmscctrl0[1] &= 0xFE;\n\t\t\t}\n\t\t\telse if (clock == SYS_XTI_CLOCK)\n\t\t\t{\n\t\t\t\tpmscctrl0[0] &= 0xFC;\n\t\t\t\tpmscctrl0[0] |= SYS_XTI_CLOCK;\n\t\t\t}\n\t\t\telse if (clock == SYS_PLL_CLOCK)\n\t\t\t{\n\t\t\t\tpmscctrl0[0] &= 0xFC;\n\t\t\t\tpmscctrl0[0] |= SYS_PLL_CLOCK;\n\t\t\t}\n\t\t\telse if (clock == TX_PLL_CLOCK)\n\t\t\t{\n\t\t\t\tpmscctrl0[0] &= 0xCF;\n\t\t\t\tpmscctrl0[0] |= TX_PLL_CLOCK;\n\t\t\t}\n\t\t\telse if (clock == LDE_CLOCK)\n\t\t\t{\n\t\t\t\tpmscctrl0[0] = SYS_XTI_CLOCK;\n\t\t\t\tpmscctrl0[1] = 0x03;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO deliver proper warning\n\t\t\t}\n\t\t\t_writeBytesToRegister(PMSC, PMSC_CTRL0_SUB, pmscctrl0, 2);\n\t\t}\n\n\t\t/* Steps used to get Temp and Voltage */\n\t\tvoid _vbatAndTempSteps()\n\t\t{\n\t\t\tbyte step1 = 0x80;\n\t\t\t_writeBytesToRegister(RF_CONF, 0x11, &step1, 1);\n\t\t\tbyte step2 = 0x0A;\n\t\t\t_writeBytesToRegister(RF_CONF, 0x12, &step2, 1);\n\t\t\tbyte step3 = 0x0F;\n\t\t\t_writeBytesToRegister(RF_CONF, 0x12, &step3, 1);\n\t\t\tbyte step4 = 0x01;\n\t\t\t_writeBytesToRegister(TX_CAL, NO_SUB, &step4, 1);\n\t\t\tbyte step5 = 0x00;\n\t\t\t_writeBytesToRegister(TX_CAL, NO_SUB, &step5, 1);\n\t\t}\n\n\t\t/* AGC_TUNE1 - reg:0x23, sub-reg:0x04, table 24 */\n\t\tvoid _agctune1()\n\t\t{\n\t\t\tbyte agctune1[LEN_AGC_TUNE1];\n\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(agctune1, 0x8870, LEN_AGC_TUNE1);\n\t\t\t}\n\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(agctune1, 0x889B, LEN_AGC_TUNE1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(AGC_TUNE, AGC_TUNE1_SUB, agctune1, LEN_AGC_TUNE1);\n\t\t}\n\n\t\t/* AGC_TUNE2 - reg:0x23, sub-reg:0x0C, table 25 */\n\t\tvoid _agctune2()\n\t\t{\n\t\t\tbyte agctune2[LEN_AGC_TUNE2];\n\t\t\tDW1000NgUtils::writeValueToBytes(agctune2, 0x2502A907L, LEN_AGC_TUNE2);\n\t\t\t_writeBytesToRegister(AGC_TUNE, AGC_TUNE2_SUB, agctune2, LEN_AGC_TUNE2);\n\t\t}\n\n\t\t/* AGC_TUNE3 - reg:0x23, sub-reg:0x12, table 26 */\n\t\tvoid _agctune3()\n\t\t{\n\t\t\tbyte agctune3[LEN_AGC_TUNE3];\n\t\t\tDW1000NgUtils::writeValueToBytes(agctune3, 0x0035, LEN_AGC_TUNE3);\n\t\t\t_writeBytesToRegister(AGC_TUNE, AGC_TUNE3_SUB, agctune3, LEN_AGC_TUNE3);\n\t\t}\n\n\t\t/* DRX_TUNE0b - reg:0x27, sub-reg:0x02, table 30 */\n\t\tvoid _drxtune0b()\n\t\t{\n\t\t\tbyte drxtune0b[LEN_DRX_TUNE0b];\n\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t{\n\t\t\t\tif (!_standardSFD)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune0b, 0x0016, LEN_DRX_TUNE0b);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune0b, 0x000A, LEN_DRX_TUNE0b);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_dataRate == DataRate::RATE_850KBPS)\n\t\t\t{\n\t\t\t\tif (!_standardSFD)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune0b, 0x0006, LEN_DRX_TUNE0b);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune0b, 0x0001, LEN_DRX_TUNE0b);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_dataRate == DataRate::RATE_6800KBPS)\n\t\t\t{\n\t\t\t\tif (!_standardSFD)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune0b, 0x0002, LEN_DRX_TUNE0b);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune0b, 0x0001, LEN_DRX_TUNE0b);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(DRX_TUNE, DRX_TUNE0b_SUB, drxtune0b, LEN_DRX_TUNE0b);\n\t\t}\n\n\t\t/* DRX_TUNE1a - reg:0x27, sub-reg:0x04, table 31 */\n\t\tvoid _drxtune1a()\n\t\t{\n\t\t\tbyte drxtune1a[LEN_DRX_TUNE1a];\n\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune1a, 0x0087, LEN_DRX_TUNE1a);\n\t\t\t}\n\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune1a, 0x008D, LEN_DRX_TUNE1a);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(DRX_TUNE, DRX_TUNE1a_SUB, drxtune1a, LEN_DRX_TUNE1a);\n\t\t}\n\n\t\t/* DRX_TUNE1b - reg:0x27, sub-reg:0x06, table 32 */\n\t\tvoid _drxtune1b()\n\t\t{\n\t\t\tbyte drxtune1b[LEN_DRX_TUNE1b];\n\t\t\tif (_preambleLength == PreambleLength::LEN_1536 || _preambleLength == PreambleLength::LEN_2048 ||\n\t\t\t\t_preambleLength == PreambleLength::LEN_4096)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune1b, 0x0064, LEN_DRX_TUNE1b);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleLength != PreambleLength::LEN_64)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_850KBPS || _dataRate == DataRate::RATE_6800KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune1b, 0x0020, LEN_DRX_TUNE1b);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_6800KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune1b, 0x0010, LEN_DRX_TUNE1b);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\t_writeBytesToRegister(DRX_TUNE, DRX_TUNE1b_SUB, drxtune1b, LEN_DRX_TUNE1b);\n\t\t}\n\n\t\t/* DRX_TUNE2 - reg:0x27, sub-reg:0x08, table 33 */\n\t\tvoid _drxtune2()\n\t\t{\n\t\t\tbyte drxtune2[LEN_DRX_TUNE2];\n\t\t\tif (_pacSize == PacSize::SIZE_8)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune2, 0x311A002DL, LEN_DRX_TUNE2);\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune2, 0x313B006BL, LEN_DRX_TUNE2);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_pacSize == PacSize::SIZE_16)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune2, 0x331A0052L, LEN_DRX_TUNE2);\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune2, 0x333B00BEL, LEN_DRX_TUNE2);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_pacSize == PacSize::SIZE_32)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune2, 0x351A009AL, LEN_DRX_TUNE2);\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune2, 0x353B015EL, LEN_DRX_TUNE2);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_pacSize == PacSize::SIZE_64)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune2, 0x371A011DL, LEN_DRX_TUNE2);\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune2, 0x373B0296L, LEN_DRX_TUNE2);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(DRX_TUNE, DRX_TUNE2_SUB, drxtune2, LEN_DRX_TUNE2);\n\t\t}\n\n\t\t/* DRX_TUNE4H - reg:0x27, sub-reg:0x26, table 34 */\n\t\tvoid _drxtune4H()\n\t\t{\n\t\t\tbyte drxtune4H[LEN_DRX_TUNE4H];\n\t\t\tif (_preambleLength == PreambleLength::LEN_64)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune4H, 0x0010, LEN_DRX_TUNE4H);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune4H, 0x0028, LEN_DRX_TUNE4H);\n\t\t\t}\n\t\t\t_writeBytesToRegister(DRX_TUNE, DRX_TUNE4H_SUB, drxtune4H, LEN_DRX_TUNE4H);\n\t\t}\n\n\t\t/* LDE_CFG1 - reg 0x2E, sub-reg:0x0806 */\n\t\tvoid _ldecfg1()\n\t\t{\n\t\t\tbyte ldecfg1[LEN_LDE_CFG1];\n\t\t\t_nlos == true ? DW1000NgUtils::writeValueToBytes(ldecfg1, 0x7, LEN_LDE_CFG1) : DW1000NgUtils::writeValueToBytes(ldecfg1, 0xD, LEN_LDE_CFG1);\n\t\t\t_writeBytesToRegister(LDE_IF, LDE_CFG1_SUB, ldecfg1, LEN_LDE_CFG1);\n\t\t}\n\n\t\t/* LDE_CFG2 - reg 0x2E, sub-reg:0x1806, table 50 */\n\t\tvoid _ldecfg2()\n\t\t{\n\t\t\tbyte ldecfg2[LEN_LDE_CFG2];\n\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t{\n\t\t\t\t_nlos == true ? DW1000NgUtils::writeValueToBytes(ldecfg2, 0x0003, LEN_LDE_CFG2) : DW1000NgUtils::writeValueToBytes(ldecfg2, 0x1607, LEN_LDE_CFG2);\n\t\t\t}\n\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(ldecfg2, 0x0607, LEN_LDE_CFG2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(LDE_IF, LDE_CFG2_SUB, ldecfg2, LEN_LDE_CFG2);\n\t\t}\n\n\t\t/* LDE_REPC - reg 0x2E, sub-reg:0x2804, table 51 */\n\t\tvoid _lderepc()\n\t\t{\n\t\t\tbyte lderepc[LEN_LDE_REPC];\n\t\t\tif (_preambleCode == PreambleCode::CODE_1 || _preambleCode == PreambleCode::CODE_2)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x5998 >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x5998, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_3 || _preambleCode == PreambleCode::CODE_8)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x51EA >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x51EA, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_4)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x428E >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x428E, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_5)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x451E >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x451E, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_6)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x2E14 >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x2E14, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_7)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x8000 >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x8000, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_9)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x28F4 >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x28F4, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_10 || _preambleCode == PreambleCode::CODE_17)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x3332 >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x3332, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_11)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x3AE0 >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x3AE0, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_12)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x3D70 >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x3D70, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_18 || _preambleCode == PreambleCode::CODE_19)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x35C2 >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x35C2, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_20)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x47AE >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x47AE, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\n\t\t\t_writeBytesToRegister(LDE_IF, LDE_REPC_SUB, lderepc, LEN_LDE_REPC);\n\t\t}\n\n\t\t/* TX_POWER (enabled smart transmit power control) - reg:0x1E, tables 19-20\n\t\t * These values are based on a typical IC and an assumed IC to antenna loss of 1.5 dB with a 0 dBi antenna */\n\t\tvoid _txpowertune()\n\t\t{\n\t\t\tbyte txpower[LEN_TX_POWER];\n\t\t\tif (_channel == Channel::CHANNEL_1 || _channel == Channel::CHANNEL_2)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x1B153555L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x15355575L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x55555555L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x75757575L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x0D072747L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x07274767L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x47474747L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x67676767L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_3)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x150F2F4FL, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x0F2F4F6FL, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x4F4F4F4FL, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x6F6F6F6FL, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x0B2B4B6BL, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x2B4B6B8BL, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x6B6B6B6BL, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x8B8B8B8BL, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_4)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x1F1F1F3FL, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x1F1F3F5FL, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x3F3F3F3FL, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x5F5F5F5FL, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x1A3A5A7AL, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x3A5A7A9AL, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x7A7A7A7AL, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x9A9A9A9AL, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_5)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x140E0828L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x0E082848L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x28282828L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x48484848L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x05254565L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x25456585L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x65656565L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x85858585L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_7)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x12325272L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x32527292L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x72727272L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x92929292L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x315191B1L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x5171B1D1L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0xB1B1B1B1L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0xD1D1D1D1L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(TX_POWER, NO_SUB, txpower, LEN_TX_POWER);\n\t\t}\n\n\t\t/* RF_RXCTRLH - reg:0x28, sub-reg:0x0B, table 37 */\n\t\tvoid _rfrxctrlh()\n\t\t{\n\t\t\tbyte rfrxctrlh[LEN_RF_RXCTRLH];\n\t\t\tif (_channel != Channel::CHANNEL_4 && _channel != Channel::CHANNEL_7)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(rfrxctrlh, 0xD8, LEN_RF_RXCTRLH);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(rfrxctrlh, 0xBC, LEN_RF_RXCTRLH);\n\t\t\t}\n\t\t\t_writeBytesToRegister(RF_CONF, RF_RXCTRLH_SUB, rfrxctrlh, LEN_RF_RXCTRLH);\n\t\t}\n\n\t\t/* RX_TXCTRL - reg:0x28, sub-reg:0x0C */\n\t\tvoid _rftxctrl()\n\t\t{\n\t\t\tbyte rftxctrl[LEN_RF_TXCTRL];\n\t\t\tif (_channel == Channel::CHANNEL_1)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(rftxctrl, 0x00005C40L, LEN_RF_TXCTRL);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_2)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(rftxctrl, 0x00045CA0L, LEN_RF_TXCTRL);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_3)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(rftxctrl, 0x00086CC0L, LEN_RF_TXCTRL);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_4)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(rftxctrl, 0x00045C80L, LEN_RF_TXCTRL);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_5)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(rftxctrl, 0x001E3FE0L, LEN_RF_TXCTRL);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_7)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(rftxctrl, 0x001E7DE0L, LEN_RF_TXCTRL);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(RF_CONF, RF_TXCTRL_SUB, rftxctrl, LEN_RF_TXCTRL);\n\t\t}\n\n\t\t/* TC_PGDELAY - reg:0x2A, sub-reg:0x0B, table 40 */\n\t\tvoid _tcpgdelaytune()\n\t\t{\n\t\t\tbyte tcpgdelay[LEN_TC_PGDELAY];\n\t\t\tif (_channel == Channel::CHANNEL_1)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(tcpgdelay, 0xC9, LEN_TC_PGDELAY);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_2)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(tcpgdelay, 0xC2, LEN_TC_PGDELAY);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_3)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(tcpgdelay, 0xC5, LEN_TC_PGDELAY);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_4)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(tcpgdelay, 0x95, LEN_TC_PGDELAY);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_5)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(tcpgdelay, 0xC0, LEN_TC_PGDELAY);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_7)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(tcpgdelay, 0x93, LEN_TC_PGDELAY);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(TX_CAL, TC_PGDELAY_SUB, tcpgdelay, LEN_TC_PGDELAY);\n\t\t}\n\n\t\t// FS_PLLCFG and FS_PLLTUNE - reg:0x2B, sub-reg:0x07-0x0B, tables 43-44\n\t\tvoid _fspll()\n\t\t{\n\t\t\tbyte fspllcfg[LEN_FS_PLLCFG];\n\t\t\tbyte fsplltune[LEN_FS_PLLTUNE];\n\t\t\tif (_channel == Channel::CHANNEL_1)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fspllcfg, 0x09000407L, LEN_FS_PLLCFG);\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fsplltune, 0x1E, LEN_FS_PLLTUNE);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_2 || _channel == Channel::CHANNEL_4)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fspllcfg, 0x08400508L, LEN_FS_PLLCFG);\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fsplltune, 0x26, LEN_FS_PLLTUNE);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_3)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fspllcfg, 0x08401009L, LEN_FS_PLLCFG);\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fsplltune, 0x56, LEN_FS_PLLTUNE);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_5 || _channel == Channel::CHANNEL_7)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fspllcfg, 0x0800041DL, LEN_FS_PLLCFG);\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fsplltune, 0xBE, LEN_FS_PLLTUNE);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(FS_CTRL, FS_PLLTUNE_SUB, fsplltune, LEN_FS_PLLTUNE);\n\t\t\t_writeBytesToRegister(FS_CTRL, FS_PLLCFG_SUB, fspllcfg, LEN_FS_PLLCFG);\n\t\t}\n\n\t\tvoid _tune()\n\t\t{\n\t\t\t// these registers are going to be tuned/configured\n\t\t\t_agctune1();\n\t\t\t_agctune2();\n\t\t\t_agctune3();\n\t\t\t_drxtune0b();\n\t\t\t_drxtune1a();\n\t\t\t_drxtune1b();\n\t\t\t_drxtune2();\n\t\t\t_drxtune4H();\n\t\t\t_ldecfg1();\n\t\t\t_ldecfg2();\n\t\t\t_lderepc();\n\t\t\tif (_autoTXPower)\n\t\t\t\t_txpowertune();\n\t\t\t_rfrxctrlh();\n\t\t\t_rftxctrl();\n\t\t\tif (_autoTCPGDelay)\n\t\t\t\t_tcpgdelaytune();\n\t\t\t_fspll();\n\t\t}\n\n\t\tvoid _writeNetworkIdAndDeviceAddress()\n\t\t{\n\t\t\t_writeBytesToRegister(PANADR, NO_SUB, _networkAndAddress, LEN_PANADR);\n\t\t}\n\n\t\tvoid _writeSystemConfigurationRegister()\n\t\t{\n\t\t\t_writeBytesToRegister(SYS_CFG, NO_SUB, _syscfg, LEN_SYS_CFG);\n\t\t}\n\n\t\tvoid _writeChannelControlRegister()\n\t\t{\n\t\t\t_writeBytesToRegister(CHAN_CTRL, NO_SUB, _chanctrl, LEN_CHAN_CTRL);\n\t\t}\n\n\t\tvoid _writeTransmitFrameControlRegister()\n\t\t{\n\t\t\t_writeBytesToRegister(TX_FCTRL, NO_SUB, _txfctrl, LEN_TX_FCTRL);\n\t\t}\n\n\t\tvoid _writeSystemEventMaskRegister()\n\t\t{\n\t\t\t_writeBytesToRegister(SYS_MASK, NO_SUB, _sysmask, LEN_SYS_MASK);\n\t\t}\n\n\t\tvoid _writeAntennaDelayRegisters()\n\t\t{\n\t\t\tbyte antennaTxDelayBytes[2];\n\t\t\tbyte antennaRxDelayBytes[2];\n\t\t\tDW1000NgUtils::writeValueToBytes(antennaTxDelayBytes, _antennaTxDelay, LEN_TX_ANTD);\n\t\t\tDW1000NgUtils::writeValueToBytes(antennaRxDelayBytes, _antennaRxDelay, LEN_LDE_RXANTD);\n\t\t\t_writeBytesToRegister(TX_ANTD, NO_SUB, antennaTxDelayBytes, LEN_TX_ANTD);\n\t\t\t_writeBytesToRegister(LDE_IF, LDE_RXANTD_SUB, antennaRxDelayBytes, LEN_LDE_RXANTD);\n\t\t}\n\n\t\tvoid _writeConfiguration()\n\t\t{\n\t\t\t// write all configurations back to device\n\t\t\t_writeSystemConfigurationRegister();\n\t\t\t_writeChannelControlRegister();\n\t\t\t_writeTransmitFrameControlRegister();\n\t\t}\n\n\t\tvoid _useExtendedFrameLength(boolean val)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, PHR_MODE_0_BIT, val);\n\t\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, PHR_MODE_1_BIT, val);\n\t\t}\n\n\t\tvoid _setReceiverAutoReenable(boolean val)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, RXAUTR_BIT, val);\n\t\t}\n\n\t\tvoid _useFrameCheck(boolean val)\n\t\t{\n\t\t\t_frameCheck = val;\n\t\t}\n\n\t\tvoid _setNlosOptimization(boolean val)\n\t\t{\n\t\t\t_nlos = val;\n\t\t\tif (_nlos)\n\t\t\t{\n\t\t\t\t_ldecfg1();\n\t\t\t\t_ldecfg2();\n\t\t\t}\n\t\t}\n\n\t\tvoid _useSmartPower(boolean smartPower)\n\t\t{\n\t\t\t_smartPower = smartPower;\n\t\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, DIS_STXP_BIT, !smartPower);\n\t\t\t_writeSystemConfigurationRegister();\n\t\t\tif (_autoTXPower)\n\t\t\t\t_txpowertune();\n\t\t}\n\n\t\tvoid _setSFDMode(SFDMode mode)\n\t\t{\n\t\t\tswitch (mode)\n\t\t\t{\n\t\t\tcase SFDMode::STANDARD_SFD:\n\t\t\t\tDW1000NgUtils::setBit(_chanctrl, LEN_CHAN_CTRL, DWSFD_BIT, false);\n\t\t\t\tDW1000NgUtils::setBit(_chanctrl, LEN_CHAN_CTRL, TNSSFD_BIT, false);\n\t\t\t\tDW1000NgUtils::setBit(_chanctrl, LEN_CHAN_CTRL, RNSSFD_BIT, false);\n\t\t\t\t_standardSFD = true;\n\t\t\t\tbreak;\n\t\t\tcase SFDMode::DECAWAVE_SFD:\n\t\t\t\tDW1000NgUtils::setBit(_chanctrl, LEN_CHAN_CTRL, DWSFD_BIT, true);\n\t\t\t\tDW1000NgUtils::setBit(_chanctrl, LEN_CHAN_CTRL, TNSSFD_BIT, true);\n\t\t\t\tDW1000NgUtils::setBit(_chanctrl, LEN_CHAN_CTRL, RNSSFD_BIT, true);\n\t\t\t\t_standardSFD = false;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn; // TODO Proper error handling\n\t\t\t}\n\t\t}\n\n\t\tvoid _setChannel(Channel channel)\n\t\t{\n\t\t\tbyte chan = static_cast<byte>(channel);\n\t\t\tchan &= 0xF;\n\t\t\t_chanctrl[0] = ((chan | (chan << 4)) & 0xFF);\n\n\t\t\t_channel = channel;\n\t\t}\n\n\t\tvoid _setDataRate(DataRate data_rate)\n\t\t{\n\t\t\tbyte rate = static_cast<byte>(data_rate);\n\t\t\trate &= 0x03;\n\t\t\t_txfctrl[1] &= 0x83;\n\t\t\t_txfctrl[1] |= (byte)((rate << 5) & 0xFF);\n\t\t\t// special 110kbps flag\n\t\t\tif (data_rate == DataRate::RATE_110KBPS)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, RXM110K_BIT, true);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, RXM110K_BIT, false);\n\t\t\t}\n\t\t\t_dataRate = data_rate;\n\t\t}\n\n\t\tvoid _setPulseFrequency(PulseFrequency frequency)\n\t\t{\n\t\t\tbyte freq = static_cast<byte>(frequency);\n\t\t\tfreq &= 0x03;\n\t\t\t_txfctrl[2] &= 0xFC;\n\t\t\t_txfctrl[2] |= (byte)(freq & 0xFF);\n\t\t\t_chanctrl[2] &= 0xF3;\n\t\t\t_chanctrl[2] |= (byte)((freq << 2) & 0xFF);\n\n\t\t\t_pulseFrequency = frequency;\n\t\t}\n\n\t\tvoid _setPreambleLength(PreambleLength preamble_length)\n\t\t{\n\t\t\tbyte prealen = static_cast<byte>(preamble_length);\n\t\t\tprealen &= 0x0F;\n\t\t\t_txfctrl[2] &= 0xC3;\n\t\t\t_txfctrl[2] |= (byte)((prealen << 2) & 0xFF);\n\n\t\t\tswitch (preamble_length)\n\t\t\t{\n\t\t\tcase PreambleLength::LEN_64:\n\t\t\t\t_pacSize = PacSize::SIZE_8;\n\t\t\t\tbreak;\n\t\t\tcase PreambleLength::LEN_128:\n\t\t\t\t_pacSize = PacSize::SIZE_8;\n\t\t\t\tbreak;\n\t\t\tcase PreambleLength::LEN_256:\n\t\t\t\t_pacSize = PacSize::SIZE_16;\n\t\t\t\tbreak;\n\t\t\tcase PreambleLength::LEN_512:\n\t\t\t\t_pacSize = PacSize::SIZE_16;\n\t\t\t\tbreak;\n\t\t\tcase PreambleLength::LEN_1024:\n\t\t\t\t_pacSize = PacSize::SIZE_32;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t_pacSize = PacSize::SIZE_64; // In case of 1536, 2048 or 4096 preamble length.\n\t\t\t}\n\n\t\t\t_preambleLength = preamble_length;\n\t\t}\n\n\t\tvoid _setPreambleCode(PreambleCode preamble_code)\n\t\t{\n\t\t\tbyte preacode = static_cast<byte>(preamble_code);\n\t\t\tpreacode &= 0x1F;\n\t\t\t_chanctrl[2] &= 0x3F;\n\t\t\t_chanctrl[2] |= ((preacode << 6) & 0xFF);\n\t\t\t_chanctrl[3] = 0x00;\n\t\t\t_chanctrl[3] = ((((preacode >> 2) & 0x07) | (preacode << 3)) & 0xFF);\n\n\t\t\t_preambleCode = preamble_code;\n\t\t}\n\n\t\tboolean _checkPreambleCodeValidity()\n\t\t{\n\t\t\tbyte preacode = static_cast<byte>(_preambleCode);\n\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t{\n\t\t\t\tfor (auto i = 0; i < 2; i++)\n\t\t\t\t{\n\t\t\t\t\tif (preacode == preamble_validity_matrix_PRF16[(int)_channel][i])\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t{\n\t\t\t\tfor (auto i = 0; i < 4; i++)\n\t\t\t\t{\n\t\t\t\t\tif (preacode == preamble_validity_matrix_PRF64[(int)_channel][i])\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn false; // TODO Proper error handling\n\t\t\t}\n\t\t}\n\n\t\tvoid _setValidPreambleCode()\n\t\t{\n\t\t\tPreambleCode preamble_code;\n\n\t\t\tswitch (_channel)\n\t\t\t{\n\t\t\tcase Channel::CHANNEL_1:\n\t\t\t\tpreamble_code = _pulseFrequency == PulseFrequency::FREQ_16MHZ ? PreambleCode::CODE_2 : PreambleCode::CODE_10;\n\t\t\t\tbreak;\n\t\t\tcase Channel::CHANNEL_3:\n\t\t\t\tpreamble_code = _pulseFrequency == PulseFrequency::FREQ_16MHZ ? PreambleCode::CODE_6 : PreambleCode::CODE_10;\n\t\t\t\tbreak;\n\t\t\tcase Channel::CHANNEL_4:\n\t\t\tcase Channel::CHANNEL_7:\n\t\t\t\tpreamble_code = _pulseFrequency == PulseFrequency::FREQ_16MHZ ? PreambleCode::CODE_8 : PreambleCode::CODE_18;\n\t\t\t\tbreak;\n\t\t\tcase Channel::CHANNEL_2:\n\t\t\tcase Channel::CHANNEL_5:\n\t\t\t\tpreamble_code = _pulseFrequency == PulseFrequency::FREQ_16MHZ ? PreambleCode::CODE_3 : PreambleCode::CODE_10;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn; // TODO Proper Error Handling\n\t\t\t}\n\t\t\tbyte preacode = static_cast<byte>(preamble_code);\n\t\t\tpreacode &= 0x1F;\n\t\t\t_chanctrl[2] &= 0x3F;\n\t\t\t_chanctrl[2] |= ((preacode << 6) & 0xFF);\n\t\t\t_chanctrl[3] = 0x00;\n\t\t\t_chanctrl[3] = ((((preacode >> 2) & 0x07) | (preacode << 3)) & 0xFF);\n\n\t\t\t_preambleCode = preamble_code;\n\t\t}\n\n\t\tvoid _setNonStandardSFDLength()\n\t\t{\n\t\t\tswitch (_dataRate)\n\t\t\t{\n\t\t\tcase DataRate::RATE_6800KBPS:\n\t\t\t\t_writeByte(USR_SFD, SFD_LENGTH_SUB, 0x08);\n\t\t\t\tbreak;\n\t\t\tcase DataRate::RATE_850KBPS:\n\t\t\t\t_writeByte(USR_SFD, SFD_LENGTH_SUB, 0x10);\n\t\t\t\tbreak;\n\t\t\tcase DataRate::RATE_110KBPS:\n\t\t\t\t_writeByte(USR_SFD, SFD_LENGTH_SUB, 0x40);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn; // TODO Proper error handling\n\t\t\t}\n\t\t}\n\n\t\tvoid _interruptOnSent(boolean val)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_MASK, TXFRS_BIT, val);\n\t\t}\n\n\t\tvoid _interruptOnReceived(boolean val)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_MASK, RXDFR_BIT, val);\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_MASK, RXFCG_BIT, val);\n\t\t}\n\n\t\tvoid _interruptOnReceiveFailed(boolean val)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_STATUS, RXPHE_BIT, val);\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_STATUS, RXFCE_BIT, val);\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_STATUS, RXRFSL_BIT, val);\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_STATUS, LDEERR_BIT, val);\n\t\t}\n\n\t\tvoid _interruptOnReceiveTimeout(boolean val)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_MASK, RXRFTO_BIT, val);\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_MASK, RXPTO_BIT, val);\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_MASK, RXSFDTO_BIT, val);\n\t\t}\n\n\t\tvoid _interruptOnReceiveTimestampAvailable(boolean val)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_MASK, LDEDONE_BIT, val);\n\t\t}\n\n\t\tvoid _interruptOnAutomaticAcknowledgeTrigger(boolean val)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_MASK, AAT_BIT, val);\n\t\t}\n\n\t\tvoid _manageLDE()\n\t\t{\n\t\t\t// transfer any ldo tune values\n\t\t\tbyte ldoTune[LEN_OTP_RDAT];\n\t\t\tuint16_t LDOTUNE_ADDRESS = 0x04;\n\t\t\t_readBytesOTP(LDOTUNE_ADDRESS, ldoTune); // TODO #define\n\t\t\tif (ldoTune[0] != 0)\n\t\t\t{\n\t\t\t\t// TODO tuning available, copy over to RAM: use OTP_LDO bit\n\t\t\t}\n\t\t\t// tell the chip to load the LDE microcode\n\t\t\t// TODO remove clock-related code (PMSC_CTRL) as handled separately\n\t\t\tbyte pmscctrl0[LEN_PMSC_CTRL0];\n\t\t\tbyte otpctrl[LEN_OTP_CTRL];\n\t\t\tmemset(pmscctrl0, 0, LEN_PMSC_CTRL0);\n\t\t\tmemset(otpctrl, 0, LEN_OTP_CTRL);\n\t\t\t_readBytes(PMSC, PMSC_CTRL0_SUB, pmscctrl0, LEN_PMSC_CTRL0);\n\t\t\t_readBytes(OTP_IF, OTP_CTRL_SUB, otpctrl, LEN_OTP_CTRL);\n\t\t\tpmscctrl0[0] = 0x01;\n\t\t\tpmscctrl0[1] = 0x03;\n\t\t\totpctrl[1] = 0x80;\n\t\t\t_writeBytesToRegister(PMSC, PMSC_CTRL0_SUB, pmscctrl0, 2);\n\t\t\t// uCode\n\t\t\t_enableClock(LDE_CLOCK);\n\t\t\tdelay(5);\n\t\t\t_writeBytesToRegister(OTP_IF, OTP_CTRL_SUB, otpctrl, 2);\n\t\t\tdelay(1);\n\t\t\t_enableClock(SYS_AUTO_CLOCK);\n\t\t\tdelay(5);\n\t\t\tpmscctrl0[0] = 0x00;\n\t\t\tpmscctrl0[1] &= 0x02;\n\t\t\t_writeBytesToRegister(PMSC, PMSC_CTRL0_SUB, pmscctrl0, 2);\n\t\t}\n\n\t\t/* Crystal calibration from OTP (if available)\n\t\t * FS_XTALT - reg:0x2B, sub-reg:0x0E\n\t\t * OTP(one-time-programmable) memory map - table 10 */\n\t\tvoid _fsxtalt()\n\t\t{\n\t\t\tbyte fsxtalt[LEN_FS_XTALT];\n\t\t\tbyte buf_otp[4];\n\t\t\t_readBytesOTP(0x01E, buf_otp); // 0x01E -> byte[0]=XTAL_Trim\n\t\t\tif (buf_otp[0] == 0)\n\t\t\t{\n\t\t\t\t// No trim value available from OTP, use midrange value of 0x10\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fsxtalt, ((0x10 & 0x1F) | 0x60), LEN_FS_XTALT);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fsxtalt, ((buf_otp[0] & 0x1F) | 0x60), LEN_FS_XTALT);\n\t\t\t}\n\t\t\t// write configuration back to chip\n\t\t\t_writeBytesToRegister(FS_CTRL, FS_XTALT_SUB, fsxtalt, LEN_FS_XTALT);\n\t\t}\n\n\t\tvoid _clearReceiveStatus()\n\t\t{\n\t\t\t// clear latched RX bits (i.e. write 1 to clear)\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXDFR_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXFCG_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXPRD_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXSFDD_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXPHD_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, LDEDONE_BIT, true);\n\t\t\t_writeBytesToRegister(SYS_STATUS, NO_SUB, _sysstatus, LEN_SYS_STATUS);\n\t\t}\n\n\t\tvoid _clearReceiveTimestampAvailableStatus()\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, LDEDONE_BIT, true);\n\t\t\t_writeBytesToRegister(SYS_STATUS, NO_SUB, _sysstatus, LEN_SYS_STATUS);\n\t\t}\n\n\t\tvoid _clearReceiveTimeoutStatus()\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXRFTO_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXPTO_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXSFDTO_BIT, true);\n\t\t\t_writeBytesToRegister(SYS_STATUS, NO_SUB, _sysstatus, LEN_SYS_STATUS);\n\t\t}\n\n\t\tvoid _clearReceiveFailedStatus()\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXPHE_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXFCE_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXRFSL_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, AFFREJ_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, LDEERR_BIT, true);\n\t\t\t_writeBytesToRegister(SYS_STATUS, NO_SUB, _sysstatus, LEN_SYS_STATUS);\n\t\t}\n\n\t\tvoid _clearTransmitStatus()\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, AAT_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, TXFRB_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, TXPRS_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, TXPHS_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, TXFRS_BIT, true);\n\t\t\t_writeBytesToRegister(SYS_STATUS, NO_SUB, _sysstatus, LEN_SYS_STATUS);\n\t\t}\n\n\t\tvoid _resetReceiver()\n\t\t{\n\t\t\t/* Set to 0 only bit 28 */\n\t\t\t_writeToRegister(PMSC, PMSC_SOFTRESET_SUB, 0xE0, LEN_PMSC_SOFTRESET);\n\t\t\t/* Set SOFTRESET to all ones */\n\t\t\t_writeToRegister(PMSC, PMSC_SOFTRESET_SUB, 0xF0, LEN_PMSC_SOFTRESET);\n\t\t}\n\n\t\t/* Internal helpers to read configuration */\n\n\t\tvoid _readSystemConfigurationRegister()\n\t\t{\n\t\t\t_readBytes(SYS_CFG, NO_SUB, _syscfg, LEN_SYS_CFG);\n\t\t}\n\n\t\tvoid _readSystemEventStatusRegister()\n\t\t{\n\t\t\t_readBytes(SYS_STATUS, NO_SUB, _sysstatus, LEN_SYS_STATUS);\n\t\t}\n\n\t\tvoid _readNetworkIdAndDeviceAddress()\n\t\t{\n\t\t\t_readBytes(PANADR, NO_SUB, _networkAndAddress, LEN_PANADR);\n\t\t}\n\n\t\tvoid _readSystemEventMaskRegister()\n\t\t{\n\t\t\t_readBytes(SYS_MASK, NO_SUB, _sysmask, LEN_SYS_MASK);\n\t\t}\n\n\t\tvoid _readChannelControlRegister()\n\t\t{\n\t\t\t_readBytes(CHAN_CTRL, NO_SUB, _chanctrl, LEN_CHAN_CTRL);\n\t\t}\n\n\t\tvoid _readTransmitFrameControlRegister()\n\t\t{\n\t\t\t_readBytes(TX_FCTRL, NO_SUB, _txfctrl, LEN_TX_FCTRL);\n\t\t}\n\n\t\tboolean _isTransmitDone()\n\t\t{\n\t\t\treturn DW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, TXFRS_BIT);\n\t\t}\n\n\t\tboolean _isReceiveTimestampAvailable()\n\t\t{\n\t\t\treturn DW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, LDEDONE_BIT);\n\t\t}\n\n\t\tboolean _isReceiveDone()\n\t\t{\n\t\t\tif (_frameCheck)\n\t\t\t{\n\t\t\t\treturn (DW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXFCG_BIT) &&\n\t\t\t\t\t\tDW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXDFR_BIT));\n\t\t\t}\n\t\t\treturn DW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXDFR_BIT);\n\t\t}\n\n\t\tboolean _isReceiveFailed()\n\t\t{\n\t\t\treturn (DW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXPHE_BIT) ||\n\t\t\t\t\tDW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXFCE_BIT) ||\n\t\t\t\t\tDW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXRFSL_BIT) ||\n\t\t\t\t\tDW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, LDEERR_BIT));\n\t\t}\n\n\t\tboolean _isReceiveTimeout()\n\t\t{\n\t\t\treturn (DW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXRFTO_BIT) ||\n\t\t\t\t\tDW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXPTO_BIT) ||\n\t\t\t\t\tDW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXSFDTO_BIT));\n\t\t}\n\n\t\tboolean _isClockProblem()\n\t\t{\n\t\t\treturn (DW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, CLKPLL_LL_BIT) ||\n\t\t\t\t\tDW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RFPLL_LL_BIT));\n\t\t}\n\n\t\tvoid _disableSequencing()\n\t\t{\n\t\t\t_enableClock(SYS_XTI_CLOCK);\n\t\t\tbyte zero[2];\n\t\t\tDW1000NgUtils::writeValueToBytes(zero, 0x0000, 2);\n\t\t\t_writeBytesToRegister(PMSC, PMSC_CTRL1_SUB, zero, 2); // To re-enable write 0xE7\n\t\t}\n\n\t\tvoid _configureRFTransmitPowerSpectrumTestMode()\n\t\t{\n\t\t\t/* Enabled TXFEN, PLLFEN, LDOFEN and set TXRXSW to TX */\n\t\t\tbyte enable_mask[4];\n\t\t\tDW1000NgUtils::writeValueToBytes(enable_mask, 0x005FFF00, LEN_RX_CONF_SUB);\n\t\t\t_writeBytesToRegister(RF_CONF, RF_CONF_SUB, enable_mask, LEN_RX_CONF_SUB);\n\t\t}\n\n\t\tvoid _uploadConfigToAON()\n\t\t{\n\t\t\t/* Write 1 in UPL_CFG_BIT */\n\t\t\t_writeToRegister(AON, AON_CTRL_SUB, 0x04, LEN_AON_CTRL);\n\t\t\t/* Clear the register */\n\t\t\t_writeToRegister(AON, AON_CTRL_SUB, 0x00, LEN_AON_CTRL);\n\t\t}\n\t}\n\n\t/* ####################### PUBLIC ###################### */\n\n\tvoid initialize(uint8_t ss, uint8_t irq, uint8_t rst)\n\t{\n\t\t// generous initial init/wake-up-idle delay\n\t\tdelay(5);\n\t\t_ss = ss;\n\t\t_irq = irq;\n\t\t_rst = rst;\n\n\t\tif (rst != 0xff)\n\t\t{\n\t\t\t// DW1000 data sheet v2.08 Â§5.6.1 page 20, the RSTn pin should not be driven high but left floating.\n\t\t\tpinMode(_rst, INPUT);\n\t\t}\n\n\t\tSPIporting::SPIinit();\n\t\t// pin and basic member setup\n\t\t// attach interrupt\n\t\t// TODO throw error if pin is not a interrupt pin\n\t\tif (_irq != 0xff)\n\t\t{\n\t\t\tattachInterrupt(digitalPinToInterrupt(_irq), interruptServiceRoutine, RISING);\n\t\t\t// attachInterrupt(digitalPinToInterrupt(_irq), interruptServiceRoutine, FALLING);\n\t\t}\n\n\t\tSPIporting::SPIselect(_ss, _irq);\n\t\t// reset chip (either soft or hard)\n\t\treset();\n\n\t\tSPIporting::setSPIspeed(SPIClock::SLOW);\n\t\t_enableClock(SYS_XTI_CLOCK);\n\t\tdelay(5);\n\n\t\t// Configure the CPLL lock detect\n\t\t_writeBitToRegister(EXT_SYNC, EC_CTRL_SUB, LEN_EC_CTRL, PLLLDT_BIT, true);\n\n\t\t// Configure XTAL trim\n\t\t_fsxtalt();\n\n\t\t// load LDE micro-code\n\t\t_manageLDE();\n\n\t\t// read the temp and vbat readings from OTP that were recorded during production test\n\t\t// see 6.3.1 OTP memory map\n\t\tbyte buf_otp[4];\n\t\t_readBytesOTP(0x008, buf_otp); // the stored 3.3 V reading\n\t\t_vmeas3v3 = buf_otp[0];\n\t\t// Serial.printf(\"_vmeas3v3=%d\\r\\n\", _vmeas3v3);\n\t\t_readBytesOTP(0x009, buf_otp); // the stored 23C reading\n\t\t_tmeas23C = buf_otp[0];\n\t\t// Serial.printf(\"_tmeas23C=%d\\r\\n\", _tmeas23C);\n\n\t\t_enableClock(SYS_AUTO_CLOCK);\n\t\tdelay(5);\n\t\tSPIporting::setSPIspeed(SPIClock::FAST);\n\n\t\t_readNetworkIdAndDeviceAddress();\n\t\t_readSystemConfigurationRegister();\n\t\t_readChannelControlRegister();\n\t\t_readTransmitFrameControlRegister();\n\t\t_readSystemEventMaskRegister();\n\n\t\t/* Cleared AON:CFG1(0x2C:0x0A) for proper operation of deepSleep */\n\t\t_writeToRegister(AON, AON_CFG1_SUB, 0x00, LEN_AON_CFG1);\n\t}\n\n\tvoid initializeNoInterrupt(uint8_t ss, uint8_t rst)\n\t{\n\t\tinitialize(ss, 0xff, rst);\n\t}\n\n\t/* callback handler management. */\n\tvoid attachErrorHandler(void (*handleError)(void))\n\t{\n\t\t_handleError = handleError;\n\t}\n\n\tvoid attachSentHandler(void (*handleSent)(void))\n\t{\n\t\t_handleSent = handleSent;\n\t}\n\n\tvoid attachReceivedHandler(void (*handleReceived)(void))\n\t{\n\t\t_handleReceived = handleReceived;\n\t}\n\n\tvoid attachReceiveFailedHandler(void (*handleReceiveFailed)(void))\n\t{\n\t\t_handleReceiveFailed = handleReceiveFailed;\n\t}\n\n\tvoid attachReceiveTimeoutHandler(void (*handleReceiveTimeout)(void))\n\t{\n\t\t_handleReceiveTimeout = handleReceiveTimeout;\n\t}\n\n\tvoid attachReceiveTimestampAvailableHandler(void (*handleReceiveTimestampAvailable)(void))\n\t{\n\t\t_handleReceiveTimestampAvailable = handleReceiveTimestampAvailable;\n\t}\n\n\tvoid interruptServiceRoutine()\n\t{\n\t\t// Serial.printf(\"test----------------------------0\\r\\n\");\n\t\t// read current status and handle via callbacks\n\t\t_readSystemEventStatusRegister();\n\t\tif (_isClockProblem() /* TODO and others */ && _handleError != 0)\n\t\t{\n\t\t\t(*_handleError)();\n\t\t\t// Serial.printf(\"interrupt----------------------------1\\r\\n\");\n\t\t}\n\t\tif (_isTransmitDone())\n\t\t{\n\t\t\t_clearTransmitStatus();\n\t\t\tif (_handleSent != nullptr)\n\t\t\t{\n\t\t\t\t(*_handleSent)();\n\t\t\t\t// Serial.printf(\"interrupt----------------------------2\\r\\n\");\n\t\t\t}\n\t\t}\n\t\tif (_isReceiveTimestampAvailable())\n\t\t{\n\t\t\t_clearReceiveTimestampAvailableStatus();\n\t\t\tif (_handleReceiveTimestampAvailable != nullptr)\n\t\t\t{\n\t\t\t\t(*_handleReceiveTimestampAvailable)();\n\t\t\t\t// Serial.printf(\"interrupt----------------------------3\\r\\n\");\n\t\t\t}\n\t\t}\n\t\tif (_isReceiveFailed())\n\t\t{\n\t\t\t_clearReceiveFailedStatus();\n\t\t\tforceTRxOff();\n\t\t\t_resetReceiver();\n\t\t\tif (_handleReceiveFailed != nullptr)\n\t\t\t{\n\t\t\t\t(*_handleReceiveFailed)();\n\t\t\t\t// Serial.printf(\"interrupt----------------------------4\\r\\n\");\n\t\t\t}\n\t\t}\n\t\telse if (_isReceiveTimeout())\n\t\t{\n\t\t\t_clearReceiveTimeoutStatus();\n\t\t\tforceTRxOff();\n\t\t\t_resetReceiver();\n\t\t\tif (_handleReceiveTimeout != nullptr)\n\t\t\t{\n\t\t\t\t(*_handleReceiveTimeout)();\n\t\t\t\t// Serial.printf(\"interrupt----------------------------5\\r\\n\");\n\t\t\t}\n\t\t}\n\t\telse if (_isReceiveDone())\n\t\t{\n\t\t\t_clearReceiveStatus();\n\t\t\tif (_handleReceived != nullptr)\n\t\t\t{\n\t\t\t\t(*_handleReceived)();\n\t\t\t\t// Serial.printf(\"interrupt----------------------------6\\r\\n\");\n\t\t\t}\n\t\t}\n\t\t// Latched bits in status register are reset by writing 1 to them\n\t\tmemset(_sysstatus, 0xff, LEN_SYS_STATUS);\n\t\t_writeBytesToRegister(SYS_STATUS, NO_SUB, _sysstatus, LEN_SYS_STATUS);\n\t}\n\n\tboolean isTransmitDone()\n\t{\n\t\t_readSystemEventStatusRegister();\n\t\treturn _isTransmitDone();\n\t}\n\n\tvoid clearTransmitStatus()\n\t{\n\t\t_clearTransmitStatus();\n\t}\n\n\tboolean isReceiveDone()\n\t{\n\t\t_readSystemEventStatusRegister();\n\t\treturn _isReceiveDone();\n\t}\n\n\tvoid clearReceiveStatus()\n\t{\n\t\t_clearReceiveStatus();\n\t}\n\n\tboolean isReceiveFailed()\n\t{\n\t\t_readSystemEventStatusRegister();\n\t\treturn _isReceiveFailed();\n\t}\n\n\tvoid clearReceiveFailedStatus()\n\t{\n\t\t_clearReceiveFailedStatus();\n\t\tforceTRxOff();\n\t\t_resetReceiver();\n\t}\n\n\tboolean isReceiveTimeout()\n\t{\n\t\t_readSystemEventMaskRegister();\n\t\treturn _isReceiveTimeout();\n\t}\n\n\tvoid clearReceiveTimeoutStatus()\n\t{\n\t\t_clearReceiveTimeoutStatus();\n\t\tforceTRxOff();\n\t\t_resetReceiver();\n\t}\n\n\tvoid enableDebounceClock()\n\t{\n\t\tbyte pmscctrl0[LEN_PMSC_CTRL0];\n\t\tmemset(pmscctrl0, 0, LEN_PMSC_CTRL0);\n\t\t_readBytes(PMSC, PMSC_CTRL0_SUB, pmscctrl0, LEN_PMSC_CTRL0);\n\t\tDW1000NgUtils::setBit(pmscctrl0, LEN_PMSC_CTRL0, GPDCE_BIT, 1);\n\t\tDW1000NgUtils::setBit(pmscctrl0, LEN_PMSC_CTRL0, KHZCLKEN_BIT, 1);\n\t\t_writeBytesToRegister(PMSC, PMSC_CTRL0_SUB, pmscctrl0, LEN_PMSC_CTRL0);\n\t\t_debounceClockEnabled = true;\n\t}\n\n\tvoid enableLedBlinking()\n\t{\n\t\tbyte pmscledc[LEN_PMSC_LEDC];\n\t\tmemset(pmscledc, 0, LEN_PMSC_LEDC);\n\t\t_readBytes(PMSC, PMSC_LEDC_SUB, pmscledc, LEN_PMSC_LEDC);\n\t\tDW1000NgUtils::setBit(pmscledc, LEN_PMSC_LEDC, BLNKEN, 1);\n\t\t_writeBytesToRegister(PMSC, PMSC_LEDC_SUB, pmscledc, LEN_PMSC_LEDC);\n\t}\n\n\tvoid setGPIOMode(uint8_t msgp, uint8_t mode)\n\t{\n\t\tbyte gpiomode[LEN_GPIO_MODE];\n\t\tmemset(gpiomode, 0, LEN_GPIO_MODE);\n\t\t_readBytes(GPIO_CTRL, GPIO_MODE_SUB, gpiomode, LEN_GPIO_MODE);\n\t\tfor (char i = 0; i < 2; i++)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(gpiomode, LEN_GPIO_MODE, msgp + i, (mode >> i) & 1);\n\t\t}\n\t\t_writeBytesToRegister(GPIO_CTRL, GPIO_MODE_SUB, gpiomode, LEN_GPIO_MODE);\n\t}\n\n\tvoid applySleepConfiguration(sleep_configuration_t sleep_config)\n\t{\n\t\tbyte aon_wcfg[LEN_AON_WCFG];\n\t\t_readBytes(AON, AON_WCFG_SUB, aon_wcfg, LEN_AON_WCFG);\n\t\tbyte aon_cfg0[1];\n\t\tmemset(aon_cfg0, 0, 1);\n\n\t\tDW1000NgUtils::setBit(aon_wcfg, LEN_AON_WCFG, ONW_RADC_BIT, sleep_config.onWakeUpRunADC);\n\t\tDW1000NgUtils::setBit(aon_wcfg, LEN_AON_WCFG, ONW_RX_BIT, sleep_config.onWakeUpReceive);\n\t\tDW1000NgUtils::setBit(aon_wcfg, LEN_AON_WCFG, ONW_LEUI_BIT, sleep_config.onWakeUpLoadEUI);\n\t\tDW1000NgUtils::setBit(aon_wcfg, LEN_AON_WCFG, ONW_LDC_BIT, true);\n\t\tDW1000NgUtils::setBit(aon_wcfg, LEN_AON_WCFG, ONW_L64P_BIT, sleep_config.onWakeUpLoadL64Param);\n\t\tDW1000NgUtils::setBit(aon_wcfg, LEN_AON_WCFG, ONW_PRES_SLEEP_BIT, sleep_config.preserveSleep);\n\t\tDW1000NgUtils::setBit(aon_wcfg, LEN_AON_WCFG, ONW_LLDE_BIT, true);\n\t\tDW1000NgUtils::setBit(aon_wcfg, LEN_AON_WCFG, ONW_LLDO_BIT, true);\n\t\t_writeBytesToRegister(AON, AON_WCFG_SUB, aon_wcfg, LEN_AON_WCFG);\n\n\t\tDW1000NgUtils::setBit(aon_cfg0, 1, WAKE_PIN_BIT, sleep_config.enableWakePIN);\n\t\tDW1000NgUtils::setBit(aon_cfg0, 1, WAKE_SPI_BIT, sleep_config.enableWakeSPI);\n\t\tDW1000NgUtils::setBit(aon_cfg0, 1, WAKE_CNT_BIT, false);\n\t\tDW1000NgUtils::setBit(aon_cfg0, 1, SLEEP_EN_BIT, sleep_config.enableSLP);\n\t\t_writeBytesToRegister(AON, AON_CFG0_SUB, aon_cfg0, 1); // Deletes 3 bits of the unused LPCLKDIVA\n\t}\n\n\t/*Puts the device into sleep/deepSleep mode. This function also upload sleep config to AON. */\n\tvoid deepSleep()\n\t{\n\t\t/* Clear the register */\n\t\t_writeToRegister(AON, AON_CTRL_SUB, 0x00, LEN_AON_CTRL);\n\t\t/* Write 1 in SAVE_BIT */\n\t\t_writeToRegister(AON, AON_CTRL_SUB, 0x02, LEN_AON_CTRL);\n\t}\n\n\tvoid spiWakeup()\n\t{\n\t\tbyte deviceId[LEN_DEV_ID];\n\t\tbyte expectedDeviceId[LEN_DEV_ID];\n\t\tDW1000NgUtils::writeValueToBytes(expectedDeviceId, 0xDECA0130, LEN_DEV_ID);\n\t\t_readBytes(DEV_ID, NO_SUB, deviceId, LEN_DEV_ID);\n\t\tif (memcmp(deviceId, expectedDeviceId, LEN_DEV_ID))\n\t\t{\n\t\t\tdigitalWrite(_ss, LOW);\n\t\t\tdelay(1);\n\t\t\tdigitalWrite(_ss, HIGH);\n\t\t\tdelay(5);\n\t\t\tsetTxAntennaDelay(_antennaTxDelay);\n\t\t\tif (_debounceClockEnabled)\n\t\t\t{\n\t\t\t\tenableDebounceClock();\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid reset()   \n\t{\n\t\tif (_rst == 0xff)\n\t\t{ /* Fallback to Software Reset */\n\t\t\tsoftwareReset();\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// DW1000Ng data sheet v2.08 Â§5.6.1 page 20, the RSTn pin should not be driven high but left floating.\n\t\t\tpinMode(_rst, OUTPUT);\n\t\t\tdigitalWrite(_rst, LOW);\n\t\t\tdelay(2); // DW1000Ng data sheet v2.08 Â§5.6.1 page 20: nominal 50ns, to be safe take more time\n\t\t\tpinMode(_rst, INPUT);\n\t\t\tdelay(5); // dw1000Ng data sheet v1.2 page 5: nominal 3 ms, to be safe take more time\n\t\t}\n\t}\n\n\tvoid softwareReset()\n\t{\n\t\tSPIporting::setSPIspeed(SPIClock::SLOW);\n\n\t\t/* Disable sequencing and go to state \"INIT\" - (a) Sets SYSCLKS to 01 */\n\t\t_disableSequencing();\n\t\t/* Clear AON and WakeUp configuration */\n\t\t_writeToRegister(AON, AON_WCFG_SUB, 0x00, LEN_AON_WCFG);\n\t\t_writeToRegister(AON, AON_CFG0_SUB, 0x00, LEN_AON_CFG0);\n\t\t// TODO change this with uploadToAON\n\t\t_writeToRegister(AON, AON_CTRL_SUB, 0x00, LEN_AON_CTRL);\n\t\t_writeToRegister(AON, AON_CTRL_SUB, 0x02, LEN_AON_CTRL);\n\t\t/* (b) Clear SOFTRESET to all zeroâ€™s */\n\t\t_writeToRegister(PMSC, PMSC_SOFTRESET_SUB, 0x00, LEN_PMSC_SOFTRESET);\n\t\tdelay(1);\n\t\t/* (c) Set SOFTRESET to all ones */\n\t\t_writeToRegister(PMSC, PMSC_SOFTRESET_SUB, 0xF0, LEN_PMSC_SOFTRESET);\n\t}\n\n\t/* ###########################################################################\n\t * #### Pretty printed device information ####################################\n\t * ######################################################################### */\n\n\tvoid getPrintableDeviceIdentifier(char msgBuffer[])\n\t{\n\t\tbyte data[LEN_DEV_ID];\n\t\t_readBytes(DEV_ID, NO_SUB, data, LEN_DEV_ID);\n\t\tsprintf(msgBuffer, \"%02X - model: %d, version: %d, revision: %d\",\n\t\t\t\t(uint16_t)((data[3] << 8) | data[2]), data[1], (data[0] >> 4) & 0x0F, data[0] & 0x0F);\n\t}\n\n\tvoid getPrintableExtendedUniqueIdentifier(char msgBuffer[])\n\t{\n\t\tbyte data[LEN_EUI];\n\t\t_readBytes(EUI, NO_SUB, data, LEN_EUI);\n\t\tsprintf(msgBuffer, \"%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X\",\n\t\t\t\tdata[7], data[6], data[5], data[4], data[3], data[2], data[1], data[0]);\n\t}\n\n\tvoid getPrintableNetworkIdAndShortAddress(char msgBuffer[])\n\t{\n\t\tbyte data[LEN_PANADR];\n\t\t_readBytes(PANADR, NO_SUB, data, LEN_PANADR);\n\t\tsprintf(msgBuffer, \"PAN: %02X, Short Address: %02X\",\n\t\t\t\t(uint16_t)((data[3] << 8) | data[2]), (uint16_t)((data[1] << 8) | data[0]));\n\t}\n\n\tvoid getPrintableDeviceMode(char msgBuffer[])\n\t{\n\t\tuint16_t dr;\n\t\tuint8_t prf;\n\t\tuint16_t plen;\n\t\tuint8_t pcode;\n\t\tuint8_t ch;\n\t\tbyte chan_ctrl[LEN_CHAN_CTRL];\n\t\tbyte tx_fctrl[LEN_TX_FCTRL];\n\t\t_readBytes(CHAN_CTRL, NO_SUB, chan_ctrl, LEN_CHAN_CTRL);\n\t\t_readBytes(TX_FCTRL, NO_SUB, tx_fctrl, LEN_TX_FCTRL);\n\t\t/* Data Rate from 0x08 bits:13-14(tx_fctrl) */\n\t\tdr = (uint16_t)(tx_fctrl[1] >> 5 & 0x3);\n\t\tswitch (dr)\n\t\t{\n\t\tcase 0x00:\n\t\t\tdr = 110;\n\t\t\tbreak;\n\t\tcase 0x01:\n\t\t\tdr = 850;\n\t\t\tbreak;\n\t\tcase 0x02:\n\t\t\tdr = 6800;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn; // TODO Error handling\n\t\t}\n\t\t/* PRF(16 or 64) from 0x1F bits:18-19(chan_ctrl) */\n\t\tprf = (uint8_t)(chan_ctrl[2] >> 2 & 0x03);\n\t\tif (prf == 0x01)\n\t\t{\n\t\t\tprf = 16;\n\t\t}\n\t\telse if (prf == 0x02)\n\t\t{\n\t\t\tprf = 64;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn; // TODO Error handling\n\t\t}\n\t\t/* PreambleLength from 0x08 bits:18-21(tx_fctrl) */\n\t\tplen = (uint16_t)(tx_fctrl[2] >> 2 & 0xF);\n\t\tswitch (plen)\n\t\t{\n\t\tcase 0x01:\n\t\t\tplen = 64;\n\t\t\tbreak;\n\t\tcase 0x05:\n\t\t\tplen = 128;\n\t\t\tbreak;\n\t\tcase 0x09:\n\t\t\tplen = 256;\n\t\t\tbreak;\n\t\tcase 0x0D:\n\t\t\tplen = 512;\n\t\t\tbreak;\n\t\tcase 0x02:\n\t\t\tplen = 1024;\n\t\t\tbreak;\n\t\tcase 0x06:\n\t\t\tplen = 1536;\n\t\t\tbreak;\n\t\tcase 0x0A:\n\t\t\tplen = 2048;\n\t\t\tbreak;\n\t\tcase 0x03:\n\t\t\tplen = 4096;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn; // TODO Error handling\n\t\t}\n\t\t/* Channel from 0x1F bits:0-4(tx_chan) */\n\t\tch = (uint8_t)(chan_ctrl[0] & 0xF);\n\t\t/* Preamble Code from 0x1F bits:24-31(chan_ctrl) */\n\t\tpcode = (uint8_t)(chan_ctrl[3] >> 3 & 0x1F);\n\t\tsprintf(msgBuffer, \"Data rate: %u kb/s, PRF: %u MHz, Preamble: %u symbols, Channel: #%u, Preamble code #%u\", dr, prf, plen, ch, pcode);\n\t}\n\n\t/* ###########################################################################\n\t * #### DW1000Ng operation functions ###########################################\n\t * ######################################################################### */\n\n\tvoid setNetworkId(uint16_t val)\n\t{\n\t\t_networkAndAddress[2] = (byte)(val & 0xFF);\n\t\t_networkAndAddress[3] = (byte)((val >> 8) & 0xFF);\n\t\t_writeNetworkIdAndDeviceAddress();\n\t}\n\n\tvoid getNetworkId(byte id[])\n\t{\n\t\t_readNetworkIdAndDeviceAddress();\n\t\tid[0] = _networkAndAddress[2];\n\t\tid[1] = _networkAndAddress[3];\n\t}\n\n\tvoid setDeviceAddress(uint16_t val)\n\t{\n\t\t_networkAndAddress[0] = (byte)(val & 0xFF);\n\t\t_networkAndAddress[1] = (byte)((val >> 8) & 0xFF);\n\t\t_writeNetworkIdAndDeviceAddress();\n\t}\n\n\tvoid getDeviceAddress(byte address[])\n\t{\n\t\t_readNetworkIdAndDeviceAddress();\n\t\taddress[0] = _networkAndAddress[0];\n\t\taddress[1] = _networkAndAddress[1];\n\t}\n\n\tvoid setEUI(char eui[])\n\t{\n\t\tbyte eui_byte[LEN_EUI];\n\t\tDW1000NgUtils::convertToByte(eui, eui_byte);\n\t\tsetEUI(eui_byte);\n\t}\n\n\tvoid setEUI(byte eui[])\n\t{\n\t\t// we reverse the address->\n\t\tbyte reverseEUI[8];\n\t\tuint8_t size = 8;\n\t\tfor (uint8_t i = 0; i < size; i++)\n\t\t{\n\t\t\t*(reverseEUI + i) = *(eui + size - i - 1);\n\t\t}\n\t\t_writeBytesToRegister(EUI, NO_SUB, reverseEUI, LEN_EUI);\n\t}\n\n\tvoid getEUI(byte eui[])\n\t{\n\t\t_readBytes(EUI, NO_SUB, eui, LEN_EUI);\n\t}\n\n\tfloat getTemperature()\n\t{\n\t\t_vbatAndTempSteps();\n\t\tbyte sar_ltemp = 0;\n\t\t_readBytes(TX_CAL, 0x04, &sar_ltemp, 1);\n\t\treturn (sar_ltemp - _tmeas23C) * 1.14f + 23.0f;\n\t}\n\n\tfloat getBatteryVoltage()\n\t{\n\t\t_vbatAndTempSteps();\n\t\tbyte sar_lvbat = 0;\n\t\t_readBytes(TX_CAL, 0x03, &sar_lvbat, 1);\n\t\treturn (sar_lvbat - _vmeas3v3) / 173.0f + 3.3f;\n\t}\n\n\tvoid getTemperatureAndBatteryVoltage(float &temp, float &vbat)\n\t{\n\t\t// follow the procedure from section 6.4 of the User Manual\n\t\t_vbatAndTempSteps();\n\t\tdelay(1);\n\t\tbyte sar_lvbat = 0;\n\t\t_readBytes(TX_CAL, 0x03, &sar_lvbat, 1);\n\t\tbyte sar_ltemp = 0;\n\t\t_readBytes(TX_CAL, 0x04, &sar_ltemp, 1);\n\n\t\t// calculate voltage and temperature\n\t\tvbat = (sar_lvbat - _vmeas3v3) / 173.0f + 3.3f;\n\t\ttemp = (sar_ltemp - _tmeas23C) * 1.14f + 23.0f;\n\t}\n\n\tvoid enableFrameFiltering(frame_filtering_configuration_t config)\n\t{\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFEN_BIT, true);\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFBC_BIT, config.behaveAsCoordinator);\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFAB_BIT, config.allowBeacon);\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFAD_BIT, config.allowData);\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFAA_BIT, config.allowAcknowledgement);\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFAM_BIT, config.allowMacCommand);\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFAR_BIT, config.allowAllReserved);\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFA4_BIT, config.allowReservedFour);\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFA5_BIT, config.allowReservedFive);\n\n\t\t_writeSystemConfigurationRegister();\n\t}\n\n\tvoid disableFrameFiltering()\n\t{\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFEN_BIT, false);\n\t\t_writeSystemConfigurationRegister();\n\t}\n\n\tvoid setDoubleBuffering(boolean val)\n\t{\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, DIS_DRXB_BIT, !val);\n\t}\n\n\tvoid setAntennaDelay(uint16_t value)\n\t{\n\t\t_antennaTxDelay = value;\n\t\t_antennaRxDelay = value;\n\t\t_writeAntennaDelayRegisters();\n\t}\n\n\tvoid setTxAntennaDelay(uint16_t value)\n\t{\n\t\t_antennaTxDelay = value;\n\t\t_writeAntennaDelayRegisters();\n\t}\n\tvoid setRxAntennaDelay(uint16_t value)\n\t{\n\t\t_antennaRxDelay = value;\n\t\t_writeAntennaDelayRegisters();\n\t}\n\n\tuint16_t getTxAntennaDelay()\n\t{\n\t\treturn _antennaTxDelay;\n\t}\n\tuint16_t getRxAntennaDelay()\n\t{\n\t\treturn _antennaRxDelay;\n\t}\n\n\tvoid forceTRxOff()\n\t{\n\t\tmemset(_sysctrl, 0, LEN_SYS_CTRL);\n\t\tDW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, TRXOFF_BIT, true);\n\t\t_writeBytesToRegister(SYS_CTRL, NO_SUB, _sysctrl, LEN_SYS_CTRL);\n\t}\n\n\tvoid startReceive(ReceiveMode mode)\n\t{\n\t\tmemset(_sysctrl, 0, LEN_SYS_CTRL);\n\t\tDW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, SFCST_BIT, !_frameCheck);\n\t\tif (mode == ReceiveMode::DELAYED)\n\t\t\tDW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, RXDLYS_BIT, true);\n\t\tDW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, RXENAB_BIT, true);\n\t\t_writeBytesToRegister(SYS_CTRL, NO_SUB, _sysctrl, LEN_SYS_CTRL);\n\t}\n\n\tvoid startTransmit(TransmitMode mode)\n\t{\n\t\tmemset(_sysctrl, 0, LEN_SYS_CTRL);\n\t\tDW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, SFCST_BIT, !_frameCheck);\n\t\tif (mode == TransmitMode::DELAYED)\n\t\t\tDW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, TXDLYS_BIT, true);\n\t\tif (_wait4resp)\n\t\t\tDW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, WAIT4RESP_BIT, true);\n\n\t\tDW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, TXSTRT_BIT, true);\n\t\t_writeBytesToRegister(SYS_CTRL, NO_SUB, _sysctrl, LEN_SYS_CTRL);\n\t}\n\n\tvoid setInterruptPolarity(boolean val)\n\t{\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, HIRQ_POL_BIT, val);\n\t\t_writeSystemConfigurationRegister();\n\t}\n\n\tvoid applyConfiguration(device_configuration_t config)\n\t{\n\t\tforceTRxOff();\n\n\t\t_useExtendedFrameLength(config.extendedFrameLength);\n\t\t_setReceiverAutoReenable(config.receiverAutoReenable);\n\t\t_useSmartPower(config.smartPower);\n\t\t_useFrameCheck(config.frameCheck);\n\t\t_setNlosOptimization(config.nlos);\n\t\t_setSFDMode(config.sfd);\n\t\t_setChannel(config.channel);\n\t\t_setDataRate(config.dataRate);\n\t\t_setPulseFrequency(config.pulseFreq);\n\t\t_setPreambleLength(config.preambleLen);\n\t\t_setPreambleCode(config.preaCode);\n\n\t\tif (!_checkPreambleCodeValidity())\n\t\t\t_setValidPreambleCode();\n\n\t\tif (!_standardSFD)\n\t\t\t_setNonStandardSFDLength();\n\n\t\t// writes configuration to registers\n\t\t_writeConfiguration();\n\t\t// tune according to configuration\n\t\t_tune();\n\t}\n\n\tChannel getChannel()\n\t{\n\t\treturn _channel;\n\t}\n\n\tPulseFrequency getPulseFrequency()\n\t{\n\t\treturn _pulseFrequency;\n\t}\n\n\tvoid setPreambleDetectionTimeout(uint16_t pacSize)\n\t{\n\t\tbyte drx_pretoc[LEN_DRX_PRETOC];\n\t\tDW1000NgUtils::writeValueToBytes(drx_pretoc, pacSize, LEN_DRX_PRETOC);\n\t\t_writeBytesToRegister(DRX_TUNE, DRX_PRETOC_SUB, drx_pretoc, LEN_DRX_PRETOC);\n\t}\n\n\tvoid setSfdDetectionTimeout(uint16_t preambleSymbols)\n\t{\n\t\tbyte drx_sfdtoc[LEN_DRX_SFDTOC];\n\t\tDW1000NgUtils::writeValueToBytes(drx_sfdtoc, preambleSymbols, LEN_DRX_SFDTOC);\n\t\t_writeBytesToRegister(DRX_TUNE, DRX_SFDTOC_SUB, drx_sfdtoc, LEN_DRX_SFDTOC);\n\t}\n\n\tvoid setReceiveFrameWaitTimeoutPeriod(uint16_t timeMicroSeconds)\n\t{\n\t\tif (timeMicroSeconds > 0)\n\t\t{\n\t\t\tbyte rx_wfto[LEN_RX_WFTO];\n\t\t\tDW1000NgUtils::writeValueToBytes(rx_wfto, timeMicroSeconds, LEN_RX_WFTO);\n\t\t\t_writeBytesToRegister(RX_WFTO, NO_SUB, rx_wfto, LEN_RX_WFTO);\n\t\t\t/* enable frame wait timeout bit */\n\t\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, RXWTOE_BIT, true);\n\t\t\t_writeSystemConfigurationRegister();\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* disable frame wait timeout bit */\n\t\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, RXWTOE_BIT, false);\n\t\t\t_writeSystemConfigurationRegister();\n\t\t}\n\t}\n\n\tvoid applyInterruptConfiguration(interrupt_configuration_t interrupt_config)\n\t{\n\t\tforceTRxOff();\n\n\t\t_interruptOnSent(interrupt_config.interruptOnSent);\n\t\t_interruptOnReceived(interrupt_config.interruptOnReceived);\n\t\t_interruptOnReceiveFailed(interrupt_config.interruptOnReceiveFailed);\n\t\t_interruptOnReceiveTimeout(interrupt_config.interruptOnReceiveTimeout);\n\t\t_interruptOnReceiveTimestampAvailable(interrupt_config.interruptOnReceiveTimestampAvailable);\n\t\t_interruptOnAutomaticAcknowledgeTrigger(interrupt_config.interruptOnAutomaticAcknowledgeTrigger);\n\n\t\t_writeSystemEventMaskRegister();\n\t}\n\n\tvoid setWait4Response(uint32_t timeMicroSeconds)\n\t{\n\t\t_wait4resp = timeMicroSeconds == 0 ? false : true;\n\n\t\t/* Check if it overflows 20 bits */\n\t\tif (timeMicroSeconds > 1048575)\n\t\t\ttimeMicroSeconds = 1048575;\n\n\t\tbyte W4R_TIME[LEN_ACK_RESP_T_W4R_TIME_SUB];\n\t\tDW1000NgUtils::writeValueToBytes(W4R_TIME, timeMicroSeconds, LEN_ACK_RESP_T_W4R_TIME_SUB);\n\t\tW4R_TIME[2] &= 0x0F;\n\t\t_writeBytesToRegister(ACK_RESP_T, ACK_RESP_T_W4R_TIME_SUB, W4R_TIME, LEN_ACK_RESP_T_W4R_TIME_SUB);\n\t}\n\n\tvoid setTXPower(byte power[])\n\t{\n\t\t// TODO Check byte length\n\t\t_writeBytesToRegister(TX_POWER, NO_SUB, power, LEN_TX_POWER);\n\t\t_autoTXPower = false;\n\t}\n\n\tvoid setTXPower(int32_t power)\n\t{\n\t\tbyte txpower[LEN_TX_POWER];\n\t\tDW1000NgUtils::writeValueToBytes(txpower, power, LEN_TX_POWER);\n\t\tsetTXPower(txpower);\n\t}\n\n\tvoid setTXPower(DriverAmplifierValue driver_amplifier, TransmitMixerValue mixer)\n\t{\n\t\tbyte txpower[LEN_TX_POWER];\n\t\tbyte pwr = 0x00;\n\n\t\tpwr |= ((byte)driver_amplifier << 5);\n\t\tpwr |= (byte)mixer;\n\n\t\tfor (auto i = 0; i < LEN_TX_POWER; i++)\n\t\t{\n\t\t\ttxpower[i] = pwr;\n\t\t}\n\n\t\tsetTXPower(txpower);\n\t}\n\n\tvoid setTXPowerAuto()\n\t{\n\t\t_autoTXPower = true;\n\t\t_txpowertune();\n\t}\n\n\tvoid setTCPGDelay(byte tcpgdelay)\n\t{\n\t\tbyte tcpgBytes[LEN_TC_PGDELAY];\n\t\tDW1000NgUtils::writeValueToBytes(tcpgBytes, tcpgdelay, LEN_TC_PGDELAY);\n\t\t_writeBytesToRegister(TX_CAL, TC_PGDELAY_SUB, tcpgBytes, LEN_TC_PGDELAY);\n\t\t_autoTCPGDelay = false;\n\t}\n\n\tvoid setTCPGDelayAuto()\n\t{\n\t\t_tcpgdelaytune();\n\t\t_autoTCPGDelay = true;\n\t}\n\n\tvoid enableTransmitPowerSpectrumTestMode(int32_t repeat_interval)\n\t{\n\t\t/* DW1000 clocks must be set to crystal speed so SPI rate have to be lowered and will\n\t\tnot be increased again */\n\t\tSPIporting::setSPIspeed(SPIClock::SLOW);\n\n\t\t_disableSequencing();\n\t\t_configureRFTransmitPowerSpectrumTestMode();\n\t\t_enableClock(SYS_PLL_CLOCK);\n\t\t_enableClock(TX_PLL_CLOCK);\n\n\t\tif (repeat_interval < 4)\n\t\t\trepeat_interval = 4;\n\n\t\t/* In diagnostic transmit power  mode (set next) the bytes 31:0 only are used for DX_TIME register */\n\t\tbyte delayBytes[4];\n\t\tDW1000NgUtils::writeValueToBytes(delayBytes, repeat_interval, 4);\n\t\t_writeBytesToRegister(DX_TIME, NO_SUB, delayBytes, 4);\n\n\t\t/* Enable Transmit Power Spectrum Test Mode */\n\t\tbyte diagnosticBytes[2];\n\t\tDW1000NgUtils::writeValueToBytes(diagnosticBytes, 0x0010, LEN_DIAG_TMC);\n\t\t_writeBytesToRegister(DIG_DIAG, DIAG_TMC_SUB, diagnosticBytes, LEN_DIAG_TMC);\n\t}\n\n\tvoid setDelayedTRX(byte futureTimeBytes[])\n\t{\n\t\t/* the least significant 9-bits are ignored in DX_TIME in functional modes */\n\t\t_writeBytesToRegister(DX_TIME, NO_SUB, futureTimeBytes, LEN_DX_TIME);\n\t}\n\n\tvoid setTransmitData(byte data[], uint16_t n)\n\t{\n\t\tif (_frameCheck)\n\t\t{\n\t\t\tn += 2; // two bytes CRC-16\n\t\t}\n\t\tif (n > LEN_EXT_UWB_FRAMES)\n\t\t{\n\t\t\treturn; // TODO proper error handling: frame/buffer size\n\t\t}\n\t\tif (n > LEN_UWB_FRAMES && !_extendedFrameLength)\n\t\t{\n\t\t\treturn; // TODO proper error handling: frame/buffer size\n\t\t}\n\t\t// transmit data and length\n\t\t_writeBytesToRegister(TX_BUFFER, NO_SUB, data, n);\n\n\t\t/* Sets up transmit frame control length based on data length */\n\t\t_txfctrl[0] = (byte)(n & 0xFF); // 1 byte (regular length + 1 bit)\n\t\t_txfctrl[1] &= 0xE0;\n\t\t_txfctrl[1] |= (byte)((n >> 8) & 0x03); // 2 added bits if extended length\n\t\t_writeTransmitFrameControlRegister();\n\t}\n\n\tvoid setTransmitData(const String &data)\n\t{\n\t\tuint16_t n = data.length() + 1;\n\t\tbyte *dataBytes = (byte *)malloc(n);\n\t\tdata.getBytes(dataBytes, n);\n\t\tsetTransmitData(dataBytes, n);\n\t\tfree(dataBytes);\n\t}\n\n\t// TODO reorder\n\tuint16_t getReceivedDataLength()\n\t{\n\t\tuint16_t len = 0;\n\n\t\t// 10 bits of RX frame control register\n\t\tbyte rxFrameInfo[LEN_RX_FINFO];\n\t\t_readBytes(RX_FINFO, NO_SUB, rxFrameInfo, LEN_RX_FINFO);\n\t\tlen = ((((uint16_t)rxFrameInfo[1] << 8) | (uint16_t)rxFrameInfo[0]) & 0x03FF);\n\n\t\tif (_frameCheck && len > 2)\n\t\t{\n\t\t\treturn len - 2;\n\t\t}\n\t\treturn len;\n\t}\n\n\tvoid getReceivedData(byte data[], uint16_t n)\n\t{\n\t\tif (n <= 0)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\t_readBytes(RX_BUFFER, NO_SUB, data, n);\n\t}\n\n\tvoid getReceivedData(String &data)\n\t{\n\t\tuint16_t i;\n\t\tuint16_t n = getReceivedDataLength(); // number of bytes w/o the two FCS ones\n\t\tif (n <= 0)\n\t\t{ // TODO\n\t\t\treturn;\n\t\t}\n\t\tbyte *dataBytes = (byte *)malloc(n);\n\t\tgetReceivedData(dataBytes, n);\n\t\t// clear string\n\t\tdata.remove(0);\n\t\tdata = \"\";\n\t\t// append to string\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tdata += (char)dataBytes[i];\n\t\t}\n\t\tfree(dataBytes);\n\t}\n\n\tuint64_t getTransmitTimestamp()\n\t{\n\t\tbyte data[LENGTH_TIMESTAMP];\n\t\tmemset(data, 0, LENGTH_TIMESTAMP);\n\t\t_readBytes(TX_TIME, TX_STAMP_SUB, data, LEN_TX_STAMP);\n\t\treturn DW1000NgUtils::bytesAsValue(data, LEN_TX_STAMP);\n\t}\n\n\tuint64_t getReceiveTimestamp()\n\t{\n\t\tbyte data[LEN_RX_STAMP];\n\t\tmemset(data, 0, LEN_RX_STAMP);\n\t\t_readBytes(RX_TIME, RX_STAMP_SUB, data, LEN_RX_STAMP);\n\t\treturn DW1000NgUtils::bytesAsValue(data, LEN_RX_STAMP);\n\t}\n\n\tuint64_t getSystemTimestamp()\n\t{\n\t\tbyte data[LEN_SYS_TIME];\n\t\tmemset(data, 0, LEN_SYS_TIME);\n\t\t_readBytes(SYS_TIME, NO_SUB, data, LEN_SYS_TIME);\n\t\treturn DW1000NgUtils::bytesAsValue(data, LEN_SYS_TIME);\n\t}\n\n\tfloat getReceiveQuality()\n\t{\n\t\tbyte noiseBytes[LEN_STD_NOISE];\n\t\tbyte fpAmpl2Bytes[LEN_FP_AMPL2];\n\t\tuint16_t noise, f2;\n\t\t_readBytes(RX_FQUAL, STD_NOISE_SUB, noiseBytes, LEN_STD_NOISE);\n\t\t_readBytes(RX_FQUAL, FP_AMPL2_SUB, fpAmpl2Bytes, LEN_FP_AMPL2);\n\t\tnoise = (uint16_t)noiseBytes[0] | ((uint16_t)noiseBytes[1] << 8);\n\t\tf2 = (uint16_t)fpAmpl2Bytes[0] | ((uint16_t)fpAmpl2Bytes[1] << 8);\n\t\treturn (float)f2 / noise;\n\t}\n\n\tfloat getFirstPathPower()\n\t{\n\t\tbyte fpAmpl1Bytes[LEN_FP_AMPL1];\n\t\tbyte fpAmpl2Bytes[LEN_FP_AMPL2];\n\t\tbyte fpAmpl3Bytes[LEN_FP_AMPL3];\n\t\tbyte rxFrameInfo[LEN_RX_FINFO];\n\t\tuint16_t f1, f2, f3, N;\n\t\tfloat A, corrFac;\n\t\t_readBytes(RX_TIME, FP_AMPL1_SUB, fpAmpl1Bytes, LEN_FP_AMPL1);\n\t\t_readBytes(RX_FQUAL, FP_AMPL2_SUB, fpAmpl2Bytes, LEN_FP_AMPL2);\n\t\t_readBytes(RX_FQUAL, FP_AMPL3_SUB, fpAmpl3Bytes, LEN_FP_AMPL3);\n\t\t_readBytes(RX_FINFO, NO_SUB, rxFrameInfo, LEN_RX_FINFO);\n\t\tf1 = (uint16_t)fpAmpl1Bytes[0] | ((uint16_t)fpAmpl1Bytes[1] << 8);\n\t\tf2 = (uint16_t)fpAmpl2Bytes[0] | ((uint16_t)fpAmpl2Bytes[1] << 8);\n\t\tf3 = (uint16_t)fpAmpl3Bytes[0] | ((uint16_t)fpAmpl3Bytes[1] << 8);\n\t\tN = (((uint16_t)rxFrameInfo[2] >> 4) & 0xFF) | ((uint16_t)rxFrameInfo[3] << 4);\n\n\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t{\n\t\t\tA = 113.77;\n\t\t\tcorrFac = 2.3334;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tA = 121.74;\n\t\t\tcorrFac = 1.1667;\n\t\t}\n\t\tfloat estFpPwr = 10.0 * log10(((float)f1 * (float)f1 + (float)f2 * (float)f2 + (float)f3 * (float)f3) / ((float)N * (float)N)) - A;\n\t\tif (estFpPwr <= -88)\n\t\t{\n\t\t\treturn estFpPwr;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// approximation of Fig. 22 in user manual for dbm correction\n\t\t\testFpPwr += (estFpPwr + 88) * corrFac;\n\t\t}\n\t\treturn estFpPwr;\n\t}\n\n\tfloat getReceivePower()\n\t{\n\t\tbyte cirPwrBytes[LEN_CIR_PWR];\n\t\tbyte rxFrameInfo[LEN_RX_FINFO];\n\t\tuint32_t twoPower17 = 131072;\n\t\tuint16_t C, N;\n\t\tfloat A, corrFac;\n\t\t_readBytes(RX_FQUAL, CIR_PWR_SUB, cirPwrBytes, LEN_CIR_PWR);\n\t\t_readBytes(RX_FINFO, NO_SUB, rxFrameInfo, LEN_RX_FINFO);\n\t\tC = (uint16_t)cirPwrBytes[0] | ((uint16_t)cirPwrBytes[1] << 8);\n\t\tN = (((uint16_t)rxFrameInfo[2] >> 4) & 0xFF) | ((uint16_t)rxFrameInfo[3] << 4);\n\n\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t{\n\t\t\tA = 113.77;\n\t\t\tcorrFac = 2.3334;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tA = 121.74;\n\t\t\tcorrFac = 1.1667;\n\t\t}\n\n\t\tfloat estRxPwr = 10.0 * log10(((float)C * (float)twoPower17) / ((float)N * (float)N)) - A;\n\t\tif (estRxPwr <= -88)\n\t\t{\n\t\t\treturn estRxPwr;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// approximation of Fig. 22 in user manual for dbm correction\n\t\t\testRxPwr += (estRxPwr + 88) * corrFac;\n\t\t}\n\t\treturn estRxPwr;\n\t}\n\n#if DW1000NG_DEBUG\n\tvoid getPrettyBytes(byte data[], char msgBuffer[], uint16_t n)\n\t{\n\t\tuint16_t i, j, b;\n\t\tb = sprintf(msgBuffer, \"Data, bytes: %d\\nB: 7 6 5 4 3 2 1 0\\n\", n); // TODO - type\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tbyte curByte = data[i];\n\t\t\tsnprintf(&msgBuffer[b++], 2, \"%d\", (i + 1));\n\t\t\tmsgBuffer[b++] = (char)((i + 1) & 0xFF);\n\t\t\tmsgBuffer[b++] = ':';\n\t\t\tmsgBuffer[b++] = ' ';\n\t\t\tfor (j = 0; j < 8; j++)\n\t\t\t{\n\t\t\t\tmsgBuffer[b++] = ((curByte >> (7 - j)) & 0x01) ? '1' : '0';\n\t\t\t\tif (j < 7)\n\t\t\t\t{\n\t\t\t\t\tmsgBuffer[b++] = ' ';\n\t\t\t\t}\n\t\t\t\telse if (i < n - 1)\n\t\t\t\t{\n\t\t\t\t\tmsgBuffer[b++] = '\\n';\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmsgBuffer[b++] = '\\0';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmsgBuffer[b++] = '\\0';\n\t}\n\n\tvoid getPrettyBytes(byte cmd, uint16_t offset, char msgBuffer[], uint16_t n)\n\t{\n\t\tuint16_t i, j, b;\n\t\tbyte *readBuf = (byte *)malloc(n);\n\t\t_readBytes(cmd, offset, readBuf, n);\n\t\tb = sprintf(msgBuffer, \"Reg: 0x%02x, bytes: %d\\nB: 7 6 5 4 3 2 1 0\\n\", cmd, n); // TODO - tpye\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tbyte curByte = readBuf[i];\n\t\t\tsnprintf(&msgBuffer[b++], 2, \"%d\", (i + 1));\n\t\t\tmsgBuffer[b++] = (char)((i + 1) & 0xFF);\n\t\t\tmsgBuffer[b++] = ':';\n\t\t\tmsgBuffer[b++] = ' ';\n\t\t\tfor (j = 0; j < 8; j++)\n\t\t\t{\n\t\t\t\tmsgBuffer[b++] = ((curByte >> (7 - j)) & 0x01) ? '1' : '0';\n\t\t\t\tif (j < 7)\n\t\t\t\t{\n\t\t\t\t\tmsgBuffer[b++] = ' ';\n\t\t\t\t}\n\t\t\t\telse if (i < n - 1)\n\t\t\t\t{\n\t\t\t\t\tmsgBuffer[b++] = '\\n';\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmsgBuffer[b++] = '\\0';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmsgBuffer[b++] = '\\0';\n\t\tfree(readBuf);\n\t}\n#endif\n}"}}}Content-Length: 175

{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"}}}
>>>
Content-Length: 183

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///c:/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","diagnostics":[]},"jsonrpc":"2.0"}
<<<
Content-Length: 228

{"jsonrpc":"2.0","id":124,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":53,"character":24}}}
>>>
Content-Length: 771

{"id":124,"result":{"contents":{"kind":"markdown","value":"### function `initializeNoInterrupt`  \n\n---\nâ†’ `void`  \nParameters:  \n- `uint8_t ss`\n- `uint8_t rst = 255`\n\nInitiates and starts a sessions with a DW1000 without interrupt. If rst is not set or value 0xff, a soft resets (i.e. command triggered) are used and it is assumed that no reset line is wired.  \n@param[in] ss The SPI Selection pin used to identify the specific connection  \n@param[in] rst The reset line/pin for hard resets of ICs that connect to the Arduino. Value 0xff means soft reset.  \n\n---\n```cpp\n// In namespace DW1000Ng\nvoid initializeNoInterrupt(uint8_t ss, uint8_t rst = 255)\n```"},"range":{"start":{"line":53,"character":12},"end":{"line":53,"character":33}}},"jsonrpc":"2.0"}
<<<
Content-Length: 233

{"jsonrpc":"2.0","id":125,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":53,"character":24}}}
>>>
Content-Length: 215

{"id":125,"result":[{"uri":"file:///C:/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","range":{"start":{"line":1643,"character":6},"end":{"line":1643,"character":27}}}],"jsonrpc":"2.0"}
<<<
Content-Length: 82613

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","languageId":"cpp","version":1,"text":"/*\n * MIT License\n *\n * Copyright (c) 2018 Michele Biondi, Andrea Salvatori\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n/*\n * Copyright (c) 2015 by Thomas Trojer <thomas@trojer.net>\n * Decawave DW1000Ng library for arduino.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @file DW1000Ng.cpp\n * Arduino driver library (source file) for the Decawave DW1000Ng UWB transceiver Module.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"DW1000Ng.hpp\"\n#include \"DW1000NgUtils.hpp\"\n#include \"DW1000NgConstants.hpp\"\n#include \"DW1000NgRegisters.hpp\"\n#include \"SPIporting.hpp\"\n\nnamespace DW1000Ng\n{\n\n\t/* anonymous namespace to host private-like variables and methods */\n\tnamespace\n\t{\n\n\t\t/* ########################### PRIVATE VARIABLES ################################# */\n\n\t\t/* SPI select pin and interrupt pin*/\n\t\tuint8_t _ss = 0xff;\n\t\tuint8_t _irq = 0xff;\n\t\tuint8_t _rst = 0xff;\n\n\t\t/* IRQ callbacks */\n\t\tvoid (*_handleSent)(void) = nullptr;\n\t\tvoid (*_handleError)(void) = nullptr;\n\t\tvoid (*_handleReceived)(void) = nullptr;\n\t\tvoid (*_handleReceiveFailed)(void) = nullptr;\n\t\tvoid (*_handleReceiveTimeout)(void) = nullptr;\n\t\tvoid (*_handleReceiveTimestampAvailable)(void) = nullptr;\n\n\t\t/* registers */\n\t\tbyte _syscfg[LEN_SYS_CFG];\n\t\tbyte _sysctrl[LEN_SYS_CTRL];\n\t\tbyte _sysstatus[LEN_SYS_STATUS];\n\t\tbyte _txfctrl[LEN_TX_FCTRL];\n\t\tbyte _sysmask[LEN_SYS_MASK];\n\t\tbyte _chanctrl[LEN_CHAN_CTRL];\n\t\tbyte _networkAndAddress[LEN_PANADR];\n\n\t\t/* Temperature and Voltage monitoring */\n\t\tbyte _vmeas3v3 = 0;\n\t\tbyte _tmeas23C = 0;\n\n\t\t/* Driver Internal State Trackers */\n\t\tbyte _extendedFrameLength;\n\t\tPacSize _pacSize;\n\t\tPulseFrequency _pulseFrequency;\n\t\tDataRate _dataRate;\n\t\tPreambleLength _preambleLength;\n\t\tPreambleCode _preambleCode;\n\t\tChannel _channel;\n\t\tboolean _smartPower;\n\t\tboolean _frameCheck;\n\t\tboolean _debounceClockEnabled = false;\n\t\tboolean _nlos = false;\n\t\tboolean _standardSFD = true;\n\t\tboolean _autoTXPower = true;\n\t\tboolean _autoTCPGDelay = true;\n\t\tboolean _wait4resp = false;\n\t\tuint16_t _antennaTxDelay = 0;\n\t\tuint16_t _antennaRxDelay = 0;\n\n\t\t/* ############################# PRIVATE METHODS ################################### */\n\t\t/*\n\t\t * Write bytes to the DW1000Ng. Single bytes can be written to registers via sub-addressing.\n\t\t * @param cmd\n\t\t * \t\tThe register address (see Chapter 7 in the DW1000Ng user manual).\n\t\t * @param offset\n\t\t *\t\tThe offset to select register sub-parts for writing, or 0x00 to disable\n\t\t * \t\tsub-adressing.\n\t\t * @param data\n\t\t *\t\tThe data array to be written.\n\t\t * @param data_size\n\t\t *\t\tThe number of bytes to be written (take care not to go out of bounds of\n\t\t * \t\tthe register).\n\t\t */\n\t\t// TODO offset really bigger than byte?\n\n\t\tvoid _writeBytesToRegister(byte cmd, uint16_t offset, byte data[], uint16_t data_size)\n\t\t{\n\t\t\tbyte header[3];\n\t\t\tuint8_t headerLen = 1;\n\n\t\t\t// TODO proper error handling: address out of bounds\n\t\t\t// build SPI header\n\t\t\tif (offset == NO_SUB)\n\t\t\t{\n\t\t\t\theader[0] = WRITE | cmd;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\theader[0] = WRITE_SUB | cmd;\n\t\t\t\tif (offset < 128)\n\t\t\t\t{\n\t\t\t\t\theader[1] = (byte)offset;\n\t\t\t\t\theaderLen++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\theader[1] = RW_SUB_EXT | (byte)offset;\n\t\t\t\t\theader[2] = (byte)(offset >> 7);\n\t\t\t\t\theaderLen += 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSPIporting::writeToSPI(_ss, headerLen, header, data_size, data);\n\t\t}\n\n\t\tvoid _writeToRegister(byte cmd, uint16_t offset, uint32_t data, uint16_t data_size)\n\t\t{\n\t\t\tbyte dataBytes[data_size];\n\t\t\tDW1000NgUtils::writeValueToBytes(dataBytes, data, data_size);\n\t\t\t_writeBytesToRegister(cmd, offset, dataBytes, data_size);\n\t\t}\n\n\t\t// Helper to set a single register\n\t\tvoid _writeByte(byte cmd, uint16_t offset, byte data)\n\t\t{\n\t\t\t_writeBytesToRegister(cmd, offset, &data, 1);\n\t\t}\n\n\t\t/*\n\t\t * Read bytes from the DW1000Ng. Number of bytes depend on register length.\n\t\t * @param cmd\n\t\t * \t\tThe register address (see Chapter 7 in the DW1000Ng user manual).\n\t\t * @param data\n\t\t *\t\tThe data array to be read into.\n\t\t * @param n\n\t\t *\t\tThe number of bytes expected to be received.\n\t\t */\n\t\t// TODO incomplete doc\n\t\tvoid _readBytes(byte cmd, uint16_t offset, byte data[], uint16_t data_size)\n\t\t{\n\t\t\tbyte header[3];\n\t\t\tuint8_t headerLen = 1;\n\n\t\t\t// build SPI header\n\t\t\tif (offset == NO_SUB)\n\t\t\t{\n\t\t\t\theader[0] = READ | cmd;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\theader[0] = READ_SUB | cmd;\n\t\t\t\tif (offset < 128)\n\t\t\t\t{\n\t\t\t\t\theader[1] = (byte)offset;\n\t\t\t\t\theaderLen++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\theader[1] = RW_SUB_EXT | (byte)offset;\n\t\t\t\t\theader[2] = (byte)(offset >> 7);\n\t\t\t\t\theaderLen += 2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSPIporting::readFromSPI(_ss, headerLen, header, data_size, data);\n\t\t}\n\n\t\t// always 4 bytes\n\t\t// TODO why always 4 bytes? can be different, see p. 58 table 10 otp memory map\n\t\tvoid _readBytesOTP(uint16_t address, byte data[])\n\t\t{\n\t\t\tbyte addressBytes[LEN_OTP_ADDR];\n\n\t\t\t// p60 - 6.3.3 Reading a value from OTP memory\n\t\t\t// bytes of address\n\t\t\taddressBytes[0] = (address & 0xFF);\n\t\t\taddressBytes[1] = ((address >> 8) & 0xFF);\n\t\t\t// set address\n\t\t\t_writeBytesToRegister(OTP_IF, OTP_ADDR_SUB, addressBytes, LEN_OTP_ADDR);\n\t\t\t// switch into read mode\n\t\t\t_writeByte(OTP_IF, OTP_CTRL_SUB, 0x03); // OTPRDEN | OTPREAD\n\t\t\t_writeByte(OTP_IF, OTP_CTRL_SUB, 0x01); // OTPRDEN\n\t\t\t// read value/block - 4 bytes\n\t\t\t_readBytes(OTP_IF, OTP_RDAT_SUB, data, LEN_OTP_RDAT);\n\t\t\t// end read mode\n\t\t\t_writeByte(OTP_IF, OTP_CTRL_SUB, 0x00);\n\t\t}\n\n\t\tvoid _writeBitToRegister(byte bitRegister, uint16_t RegisterOffset, uint16_t bitRegister_LEN, uint16_t selectedBit, boolean value)\n\t\t{\n\t\t\tuint16_t idx;\n\t\t\tuint8_t bitPosition;\n\n\t\t\tidx = selectedBit / 8;\n\t\t\tif (idx >= bitRegister_LEN)\n\t\t\t{\n\t\t\t\treturn; // TODO proper error handling: out of bounds\n\t\t\t}\n\t\t\tbyte targetByte;\n\t\t\tmemset(&targetByte, 0, 1);\n\t\t\tbitPosition = selectedBit % 8;\n\t\t\t_readBytes(bitRegister, RegisterOffset + idx, &targetByte, 1);\n\n\t\t\tvalue ? bitSet(targetByte, bitPosition) : bitClear(targetByte, bitPosition);\n\n\t\t\tif (RegisterOffset == NO_SUB)\n\t\t\t\tRegisterOffset = 0x00;\n\n\t\t\t_writeBytesToRegister(bitRegister, RegisterOffset + idx, &targetByte, 1);\n\t\t}\n\n\t\tvoid _enableClock(byte clock)\n\t\t{\n\t\t\tbyte pmscctrl0[LEN_PMSC_CTRL0];\n\t\t\tmemset(pmscctrl0, 0, LEN_PMSC_CTRL0);\n\t\t\t_readBytes(PMSC, PMSC_CTRL0_SUB, pmscctrl0, LEN_PMSC_CTRL0);\n\t\t\tif (clock == SYS_AUTO_CLOCK)\n\t\t\t{\n\t\t\t\tpmscctrl0[0] = SYS_AUTO_CLOCK;\n\t\t\t\tpmscctrl0[1] &= 0xFE;\n\t\t\t}\n\t\t\telse if (clock == SYS_XTI_CLOCK)\n\t\t\t{\n\t\t\t\tpmscctrl0[0] &= 0xFC;\n\t\t\t\tpmscctrl0[0] |= SYS_XTI_CLOCK;\n\t\t\t}\n\t\t\telse if (clock == SYS_PLL_CLOCK)\n\t\t\t{\n\t\t\t\tpmscctrl0[0] &= 0xFC;\n\t\t\t\tpmscctrl0[0] |= SYS_PLL_CLOCK;\n\t\t\t}\n\t\t\telse if (clock == TX_PLL_CLOCK)\n\t\t\t{\n\t\t\t\tpmscctrl0[0] &= 0xCF;\n\t\t\t\tpmscctrl0[0] |= TX_PLL_CLOCK;\n\t\t\t}\n\t\t\telse if (clock == LDE_CLOCK)\n\t\t\t{\n\t\t\t\tpmscctrl0[0] = SYS_XTI_CLOCK;\n\t\t\t\tpmscctrl0[1] = 0x03;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO deliver proper warning\n\t\t\t}\n\t\t\t_writeBytesToRegister(PMSC, PMSC_CTRL0_SUB, pmscctrl0, 2);\n\t\t}\n\n\t\t/* Steps used to get Temp and Voltage */\n\t\tvoid _vbatAndTempSteps()\n\t\t{\n\t\t\tbyte step1 = 0x80;\n\t\t\t_writeBytesToRegister(RF_CONF, 0x11, &step1, 1);\n\t\t\tbyte step2 = 0x0A;\n\t\t\t_writeBytesToRegister(RF_CONF, 0x12, &step2, 1);\n\t\t\tbyte step3 = 0x0F;\n\t\t\t_writeBytesToRegister(RF_CONF, 0x12, &step3, 1);\n\t\t\tbyte step4 = 0x01;\n\t\t\t_writeBytesToRegister(TX_CAL, NO_SUB, &step4, 1);\n\t\t\tbyte step5 = 0x00;\n\t\t\t_writeBytesToRegister(TX_CAL, NO_SUB, &step5, 1);\n\t\t}\n\n\t\t/* AGC_TUNE1 - reg:0x23, sub-reg:0x04, table 24 */\n\t\tvoid _agctune1()\n\t\t{\n\t\t\tbyte agctune1[LEN_AGC_TUNE1];\n\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(agctune1, 0x8870, LEN_AGC_TUNE1);\n\t\t\t}\n\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(agctune1, 0x889B, LEN_AGC_TUNE1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(AGC_TUNE, AGC_TUNE1_SUB, agctune1, LEN_AGC_TUNE1);\n\t\t}\n\n\t\t/* AGC_TUNE2 - reg:0x23, sub-reg:0x0C, table 25 */\n\t\tvoid _agctune2()\n\t\t{\n\t\t\tbyte agctune2[LEN_AGC_TUNE2];\n\t\t\tDW1000NgUtils::writeValueToBytes(agctune2, 0x2502A907L, LEN_AGC_TUNE2);\n\t\t\t_writeBytesToRegister(AGC_TUNE, AGC_TUNE2_SUB, agctune2, LEN_AGC_TUNE2);\n\t\t}\n\n\t\t/* AGC_TUNE3 - reg:0x23, sub-reg:0x12, table 26 */\n\t\tvoid _agctune3()\n\t\t{\n\t\t\tbyte agctune3[LEN_AGC_TUNE3];\n\t\t\tDW1000NgUtils::writeValueToBytes(agctune3, 0x0035, LEN_AGC_TUNE3);\n\t\t\t_writeBytesToRegister(AGC_TUNE, AGC_TUNE3_SUB, agctune3, LEN_AGC_TUNE3);\n\t\t}\n\n\t\t/* DRX_TUNE0b - reg:0x27, sub-reg:0x02, table 30 */\n\t\tvoid _drxtune0b()\n\t\t{\n\t\t\tbyte drxtune0b[LEN_DRX_TUNE0b];\n\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t{\n\t\t\t\tif (!_standardSFD)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune0b, 0x0016, LEN_DRX_TUNE0b);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune0b, 0x000A, LEN_DRX_TUNE0b);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_dataRate == DataRate::RATE_850KBPS)\n\t\t\t{\n\t\t\t\tif (!_standardSFD)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune0b, 0x0006, LEN_DRX_TUNE0b);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune0b, 0x0001, LEN_DRX_TUNE0b);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_dataRate == DataRate::RATE_6800KBPS)\n\t\t\t{\n\t\t\t\tif (!_standardSFD)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune0b, 0x0002, LEN_DRX_TUNE0b);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune0b, 0x0001, LEN_DRX_TUNE0b);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(DRX_TUNE, DRX_TUNE0b_SUB, drxtune0b, LEN_DRX_TUNE0b);\n\t\t}\n\n\t\t/* DRX_TUNE1a - reg:0x27, sub-reg:0x04, table 31 */\n\t\tvoid _drxtune1a()\n\t\t{\n\t\t\tbyte drxtune1a[LEN_DRX_TUNE1a];\n\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune1a, 0x0087, LEN_DRX_TUNE1a);\n\t\t\t}\n\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune1a, 0x008D, LEN_DRX_TUNE1a);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(DRX_TUNE, DRX_TUNE1a_SUB, drxtune1a, LEN_DRX_TUNE1a);\n\t\t}\n\n\t\t/* DRX_TUNE1b - reg:0x27, sub-reg:0x06, table 32 */\n\t\tvoid _drxtune1b()\n\t\t{\n\t\t\tbyte drxtune1b[LEN_DRX_TUNE1b];\n\t\t\tif (_preambleLength == PreambleLength::LEN_1536 || _preambleLength == PreambleLength::LEN_2048 ||\n\t\t\t\t_preambleLength == PreambleLength::LEN_4096)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune1b, 0x0064, LEN_DRX_TUNE1b);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleLength != PreambleLength::LEN_64)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_850KBPS || _dataRate == DataRate::RATE_6800KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune1b, 0x0020, LEN_DRX_TUNE1b);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_6800KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune1b, 0x0010, LEN_DRX_TUNE1b);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\t_writeBytesToRegister(DRX_TUNE, DRX_TUNE1b_SUB, drxtune1b, LEN_DRX_TUNE1b);\n\t\t}\n\n\t\t/* DRX_TUNE2 - reg:0x27, sub-reg:0x08, table 33 */\n\t\tvoid _drxtune2()\n\t\t{\n\t\t\tbyte drxtune2[LEN_DRX_TUNE2];\n\t\t\tif (_pacSize == PacSize::SIZE_8)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune2, 0x311A002DL, LEN_DRX_TUNE2);\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune2, 0x313B006BL, LEN_DRX_TUNE2);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_pacSize == PacSize::SIZE_16)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune2, 0x331A0052L, LEN_DRX_TUNE2);\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune2, 0x333B00BEL, LEN_DRX_TUNE2);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_pacSize == PacSize::SIZE_32)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune2, 0x351A009AL, LEN_DRX_TUNE2);\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune2, 0x353B015EL, LEN_DRX_TUNE2);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_pacSize == PacSize::SIZE_64)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune2, 0x371A011DL, LEN_DRX_TUNE2);\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune2, 0x373B0296L, LEN_DRX_TUNE2);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(DRX_TUNE, DRX_TUNE2_SUB, drxtune2, LEN_DRX_TUNE2);\n\t\t}\n\n\t\t/* DRX_TUNE4H - reg:0x27, sub-reg:0x26, table 34 */\n\t\tvoid _drxtune4H()\n\t\t{\n\t\t\tbyte drxtune4H[LEN_DRX_TUNE4H];\n\t\t\tif (_preambleLength == PreambleLength::LEN_64)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune4H, 0x0010, LEN_DRX_TUNE4H);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune4H, 0x0028, LEN_DRX_TUNE4H);\n\t\t\t}\n\t\t\t_writeBytesToRegister(DRX_TUNE, DRX_TUNE4H_SUB, drxtune4H, LEN_DRX_TUNE4H);\n\t\t}\n\n\t\t/* LDE_CFG1 - reg 0x2E, sub-reg:0x0806 */\n\t\tvoid _ldecfg1()\n\t\t{\n\t\t\tbyte ldecfg1[LEN_LDE_CFG1];\n\t\t\t_nlos == true ? DW1000NgUtils::writeValueToBytes(ldecfg1, 0x7, LEN_LDE_CFG1) : DW1000NgUtils::writeValueToBytes(ldecfg1, 0xD, LEN_LDE_CFG1);\n\t\t\t_writeBytesToRegister(LDE_IF, LDE_CFG1_SUB, ldecfg1, LEN_LDE_CFG1);\n\t\t}\n\n\t\t/* LDE_CFG2 - reg 0x2E, sub-reg:0x1806, table 50 */\n\t\tvoid _ldecfg2()\n\t\t{\n\t\t\tbyte ldecfg2[LEN_LDE_CFG2];\n\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t{\n\t\t\t\t_nlos == true ? DW1000NgUtils::writeValueToBytes(ldecfg2, 0x0003, LEN_LDE_CFG2) : DW1000NgUtils::writeValueToBytes(ldecfg2, 0x1607, LEN_LDE_CFG2);\n\t\t\t}\n\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(ldecfg2, 0x0607, LEN_LDE_CFG2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(LDE_IF, LDE_CFG2_SUB, ldecfg2, LEN_LDE_CFG2);\n\t\t}\n\n\t\t/* LDE_REPC - reg 0x2E, sub-reg:0x2804, table 51 */\n\t\tvoid _lderepc()\n\t\t{\n\t\t\tbyte lderepc[LEN_LDE_REPC];\n\t\t\tif (_preambleCode == PreambleCode::CODE_1 || _preambleCode == PreambleCode::CODE_2)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x5998 >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x5998, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_3 || _preambleCode == PreambleCode::CODE_8)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x51EA >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x51EA, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_4)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x428E >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x428E, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_5)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x451E >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x451E, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_6)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x2E14 >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x2E14, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_7)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x8000 >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x8000, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_9)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x28F4 >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x28F4, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_10 || _preambleCode == PreambleCode::CODE_17)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x3332 >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x3332, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_11)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x3AE0 >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x3AE0, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_12)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x3D70 >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x3D70, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_18 || _preambleCode == PreambleCode::CODE_19)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x35C2 >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x35C2, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_20)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x47AE >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x47AE, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\n\t\t\t_writeBytesToRegister(LDE_IF, LDE_REPC_SUB, lderepc, LEN_LDE_REPC);\n\t\t}\n\n\t\t/* TX_POWER (enabled smart transmit power control) - reg:0x1E, tables 19-20\n\t\t * These values are based on a typical IC and an assumed IC to antenna loss of 1.5 dB with a 0 dBi antenna */\n\t\tvoid _txpowertune()\n\t\t{\n\t\t\tbyte txpower[LEN_TX_POWER];\n\t\t\tif (_channel == Channel::CHANNEL_1 || _channel == Channel::CHANNEL_2)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x1B153555L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x15355575L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x55555555L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x75757575L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x0D072747L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x07274767L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x47474747L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x67676767L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_3)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x150F2F4FL, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x0F2F4F6FL, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x4F4F4F4FL, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x6F6F6F6FL, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x0B2B4B6BL, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x2B4B6B8BL, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x6B6B6B6BL, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x8B8B8B8BL, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_4)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x1F1F1F3FL, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x1F1F3F5FL, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x3F3F3F3FL, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x5F5F5F5FL, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x1A3A5A7AL, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x3A5A7A9AL, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x7A7A7A7AL, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x9A9A9A9AL, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_5)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x140E0828L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x0E082848L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x28282828L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x48484848L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x05254565L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x25456585L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x65656565L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x85858585L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_7)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x12325272L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x32527292L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x72727272L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x92929292L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x315191B1L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x5171B1D1L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0xB1B1B1B1L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0xD1D1D1D1L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(TX_POWER, NO_SUB, txpower, LEN_TX_POWER);\n\t\t}\n\n\t\t/* RF_RXCTRLH - reg:0x28, sub-reg:0x0B, table 37 */\n\t\tvoid _rfrxctrlh()\n\t\t{\n\t\t\tbyte rfrxctrlh[LEN_RF_RXCTRLH];\n\t\t\tif (_channel != Channel::CHANNEL_4 && _channel != Channel::CHANNEL_7)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(rfrxctrlh, 0xD8, LEN_RF_RXCTRLH);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(rfrxctrlh, 0xBC, LEN_RF_RXCTRLH);\n\t\t\t}\n\t\t\t_writeBytesToRegister(RF_CONF, RF_RXCTRLH_SUB, rfrxctrlh, LEN_RF_RXCTRLH);\n\t\t}\n\n\t\t/* RX_TXCTRL - reg:0x28, sub-reg:0x0C */\n\t\tvoid _rftxctrl()\n\t\t{\n\t\t\tbyte rftxctrl[LEN_RF_TXCTRL];\n\t\t\tif (_channel == Channel::CHANNEL_1)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(rftxctrl, 0x00005C40L, LEN_RF_TXCTRL);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_2)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(rftxctrl, 0x00045CA0L, LEN_RF_TXCTRL);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_3)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(rftxctrl, 0x00086CC0L, LEN_RF_TXCTRL);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_4)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(rftxctrl, 0x00045C80L, LEN_RF_TXCTRL);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_5)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(rftxctrl, 0x001E3FE0L, LEN_RF_TXCTRL);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_7)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(rftxctrl, 0x001E7DE0L, LEN_RF_TXCTRL);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(RF_CONF, RF_TXCTRL_SUB, rftxctrl, LEN_RF_TXCTRL);\n\t\t}\n\n\t\t/* TC_PGDELAY - reg:0x2A, sub-reg:0x0B, table 40 */\n\t\tvoid _tcpgdelaytune()\n\t\t{\n\t\t\tbyte tcpgdelay[LEN_TC_PGDELAY];\n\t\t\tif (_channel == Channel::CHANNEL_1)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(tcpgdelay, 0xC9, LEN_TC_PGDELAY);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_2)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(tcpgdelay, 0xC2, LEN_TC_PGDELAY);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_3)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(tcpgdelay, 0xC5, LEN_TC_PGDELAY);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_4)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(tcpgdelay, 0x95, LEN_TC_PGDELAY);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_5)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(tcpgdelay, 0xC0, LEN_TC_PGDELAY);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_7)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(tcpgdelay, 0x93, LEN_TC_PGDELAY);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(TX_CAL, TC_PGDELAY_SUB, tcpgdelay, LEN_TC_PGDELAY);\n\t\t}\n\n\t\t// FS_PLLCFG and FS_PLLTUNE - reg:0x2B, sub-reg:0x07-0x0B, tables 43-44\n\t\tvoid _fspll()\n\t\t{\n\t\t\tbyte fspllcfg[LEN_FS_PLLCFG];\n\t\t\tbyte fsplltune[LEN_FS_PLLTUNE];\n\t\t\tif (_channel == Channel::CHANNEL_1)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fspllcfg, 0x09000407L, LEN_FS_PLLCFG);\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fsplltune, 0x1E, LEN_FS_PLLTUNE);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_2 || _channel == Channel::CHANNEL_4)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fspllcfg, 0x08400508L, LEN_FS_PLLCFG);\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fsplltune, 0x26, LEN_FS_PLLTUNE);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_3)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fspllcfg, 0x08401009L, LEN_FS_PLLCFG);\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fsplltune, 0x56, LEN_FS_PLLTUNE);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_5 || _channel == Channel::CHANNEL_7)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fspllcfg, 0x0800041DL, LEN_FS_PLLCFG);\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fsplltune, 0xBE, LEN_FS_PLLTUNE);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(FS_CTRL, FS_PLLTUNE_SUB, fsplltune, LEN_FS_PLLTUNE);\n\t\t\t_writeBytesToRegister(FS_CTRL, FS_PLLCFG_SUB, fspllcfg, LEN_FS_PLLCFG);\n\t\t}\n\n\t\tvoid _tune()\n\t\t{\n\t\t\t// these registers are going to be tuned/configured\n\t\t\t_agctune1();\n\t\t\t_agctune2();\n\t\t\t_agctune3();\n\t\t\t_drxtune0b();\n\t\t\t_drxtune1a();\n\t\t\t_drxtune1b();\n\t\t\t_drxtune2();\n\t\t\t_drxtune4H();\n\t\t\t_ldecfg1();\n\t\t\t_ldecfg2();\n\t\t\t_lderepc();\n\t\t\tif (_autoTXPower)\n\t\t\t\t_txpowertune();\n\t\t\t_rfrxctrlh();\n\t\t\t_rftxctrl();\n\t\t\tif (_autoTCPGDelay)\n\t\t\t\t_tcpgdelaytune();\n\t\t\t_fspll();\n\t\t}\n\n\t\tvoid _writeNetworkIdAndDeviceAddress()\n\t\t{\n\t\t\t_writeBytesToRegister(PANADR, NO_SUB, _networkAndAddress, LEN_PANADR);\n\t\t}\n\n\t\tvoid _writeSystemConfigurationRegister()\n\t\t{\n\t\t\t_writeBytesToRegister(SYS_CFG, NO_SUB, _syscfg, LEN_SYS_CFG);\n\t\t}\n\n\t\tvoid _writeChannelControlRegister()\n\t\t{\n\t\t\t_writeBytesToRegister(CHAN_CTRL, NO_SUB, _chanctrl, LEN_CHAN_CTRL);\n\t\t}\n\n\t\tvoid _writeTransmitFrameControlRegister()\n\t\t{\n\t\t\t_writeBytesToRegister(TX_FCTRL, NO_SUB, _txfctrl, LEN_TX_FCTRL);\n\t\t}\n\n\t\tvoid _writeSystemEventMaskRegister()\n\t\t{\n\t\t\t_writeBytesToRegister(SYS_MASK, NO_SUB, _sysmask, LEN_SYS_MASK);\n\t\t}\n\n\t\tvoid _writeAntennaDelayRegisters()\n\t\t{\n\t\t\tbyte antennaTxDelayBytes[2];\n\t\t\tbyte antennaRxDelayBytes[2];\n\t\t\tDW1000NgUtils::writeValueToBytes(antennaTxDelayBytes, _antennaTxDelay, LEN_TX_ANTD);\n\t\t\tDW1000NgUtils::writeValueToBytes(antennaRxDelayBytes, _antennaRxDelay, LEN_LDE_RXANTD);\n\t\t\t_writeBytesToRegister(TX_ANTD, NO_SUB, antennaTxDelayBytes, LEN_TX_ANTD);\n\t\t\t_writeBytesToRegister(LDE_IF, LDE_RXANTD_SUB, antennaRxDelayBytes, LEN_LDE_RXANTD);\n\t\t}\n\n\t\tvoid _writeConfiguration()\n\t\t{\n\t\t\t// write all configurations back to device\n\t\t\t_writeSystemConfigurationRegister();\n\t\t\t_writeChannelControlRegister();\n\t\t\t_writeTransmitFrameControlRegister();\n\t\t}\n\n\t\tvoid _useExtendedFrameLength(boolean val)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, PHR_MODE_0_BIT, val);\n\t\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, PHR_MODE_1_BIT, val);\n\t\t}\n\n\t\tvoid _setReceiverAutoReenable(boolean val)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, RXAUTR_BIT, val);\n\t\t}\n\n\t\tvoid _useFrameCheck(boolean val)\n\t\t{\n\t\t\t_frameCheck = val;\n\t\t}\n\n\t\tvoid _setNlosOptimization(boolean val)\n\t\t{\n\t\t\t_nlos = val;\n\t\t\tif (_nlos)\n\t\t\t{\n\t\t\t\t_ldecfg1();\n\t\t\t\t_ldecfg2();\n\t\t\t}\n\t\t}\n\n\t\tvoid _useSmartPower(boolean smartPower)\n\t\t{\n\t\t\t_smartPower = smartPower;\n\t\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, DIS_STXP_BIT, !smartPower);\n\t\t\t_writeSystemConfigurationRegister();\n\t\t\tif (_autoTXPower)\n\t\t\t\t_txpowertune();\n\t\t}\n\n\t\tvoid _setSFDMode(SFDMode mode)\n\t\t{\n\t\t\tswitch (mode)\n\t\t\t{\n\t\t\tcase SFDMode::STANDARD_SFD:\n\t\t\t\tDW1000NgUtils::setBit(_chanctrl, LEN_CHAN_CTRL, DWSFD_BIT, false);\n\t\t\t\tDW1000NgUtils::setBit(_chanctrl, LEN_CHAN_CTRL, TNSSFD_BIT, false);\n\t\t\t\tDW1000NgUtils::setBit(_chanctrl, LEN_CHAN_CTRL, RNSSFD_BIT, false);\n\t\t\t\t_standardSFD = true;\n\t\t\t\tbreak;\n\t\t\tcase SFDMode::DECAWAVE_SFD:\n\t\t\t\tDW1000NgUtils::setBit(_chanctrl, LEN_CHAN_CTRL, DWSFD_BIT, true);\n\t\t\t\tDW1000NgUtils::setBit(_chanctrl, LEN_CHAN_CTRL, TNSSFD_BIT, true);\n\t\t\t\tDW1000NgUtils::setBit(_chanctrl, LEN_CHAN_CTRL, RNSSFD_BIT, true);\n\t\t\t\t_standardSFD = false;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn; // TODO Proper error handling\n\t\t\t}\n\t\t}\n\n\t\tvoid _setChannel(Channel channel)\n\t\t{\n\t\t\tbyte chan = static_cast<byte>(channel);\n\t\t\tchan &= 0xF;\n\t\t\t_chanctrl[0] = ((chan | (chan << 4)) & 0xFF);\n\n\t\t\t_channel = channel;\n\t\t}\n\n\t\tvoid _setDataRate(DataRate data_rate)\n\t\t{\n\t\t\tbyte rate = static_cast<byte>(data_rate);\n\t\t\trate &= 0x03;\n\t\t\t_txfctrl[1] &= 0x83;\n\t\t\t_txfctrl[1] |= (byte)((rate << 5) & 0xFF);\n\t\t\t// special 110kbps flag\n\t\t\tif (data_rate == DataRate::RATE_110KBPS)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, RXM110K_BIT, true);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, RXM110K_BIT, false);\n\t\t\t}\n\t\t\t_dataRate = data_rate;\n\t\t}\n\n\t\tvoid _setPulseFrequency(PulseFrequency frequency)\n\t\t{\n\t\t\tbyte freq = static_cast<byte>(frequency);\n\t\t\tfreq &= 0x03;\n\t\t\t_txfctrl[2] &= 0xFC;\n\t\t\t_txfctrl[2] |= (byte)(freq & 0xFF);\n\t\t\t_chanctrl[2] &= 0xF3;\n\t\t\t_chanctrl[2] |= (byte)((freq << 2) & 0xFF);\n\n\t\t\t_pulseFrequency = frequency;\n\t\t}\n\n\t\tvoid _setPreambleLength(PreambleLength preamble_length)\n\t\t{\n\t\t\tbyte prealen = static_cast<byte>(preamble_length);\n\t\t\tprealen &= 0x0F;\n\t\t\t_txfctrl[2] &= 0xC3;\n\t\t\t_txfctrl[2] |= (byte)((prealen << 2) & 0xFF);\n\n\t\t\tswitch (preamble_length)\n\t\t\t{\n\t\t\tcase PreambleLength::LEN_64:\n\t\t\t\t_pacSize = PacSize::SIZE_8;\n\t\t\t\tbreak;\n\t\t\tcase PreambleLength::LEN_128:\n\t\t\t\t_pacSize = PacSize::SIZE_8;\n\t\t\t\tbreak;\n\t\t\tcase PreambleLength::LEN_256:\n\t\t\t\t_pacSize = PacSize::SIZE_16;\n\t\t\t\tbreak;\n\t\t\tcase PreambleLength::LEN_512:\n\t\t\t\t_pacSize = PacSize::SIZE_16;\n\t\t\t\tbreak;\n\t\t\tcase PreambleLength::LEN_1024:\n\t\t\t\t_pacSize = PacSize::SIZE_32;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t_pacSize = PacSize::SIZE_64; // In case of 1536, 2048 or 4096 preamble length.\n\t\t\t}\n\n\t\t\t_preambleLength = preamble_length;\n\t\t}\n\n\t\tvoid _setPreambleCode(PreambleCode preamble_code)\n\t\t{\n\t\t\tbyte preacode = static_cast<byte>(preamble_code);\n\t\t\tpreacode &= 0x1F;\n\t\t\t_chanctrl[2] &= 0x3F;\n\t\t\t_chanctrl[2] |= ((preacode << 6) & 0xFF);\n\t\t\t_chanctrl[3] = 0x00;\n\t\t\t_chanctrl[3] = ((((preacode >> 2) & 0x07) | (preacode << 3)) & 0xFF);\n\n\t\t\t_preambleCode = preamble_code;\n\t\t}\n\n\t\tboolean _checkPreambleCodeValidity()\n\t\t{\n\t\t\tbyte preacode = static_cast<byte>(_preambleCode);\n\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t{\n\t\t\t\tfor (auto i = 0; i < 2; i++)\n\t\t\t\t{\n\t\t\t\t\tif (preacode == preamble_validity_matrix_PRF16[(int)_channel][i])\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t{\n\t\t\t\tfor (auto i = 0; i < 4; i++)\n\t\t\t\t{\n\t\t\t\t\tif (preacode == preamble_validity_matrix_PRF64[(int)_channel][i])\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn false; // TODO Proper error handling\n\t\t\t}\n\t\t}\n\n\t\tvoid _setValidPreambleCode()\n\t\t{\n\t\t\tPreambleCode preamble_code;\n\n\t\t\tswitch (_channel)\n\t\t\t{\n\t\t\tcase Channel::CHANNEL_1:\n\t\t\t\tpreamble_code = _pulseFrequency == PulseFrequency::FREQ_16MHZ ? PreambleCode::CODE_2 : PreambleCode::CODE_10;\n\t\t\t\tbreak;\n\t\t\tcase Channel::CHANNEL_3:\n\t\t\t\tpreamble_code = _pulseFrequency == PulseFrequency::FREQ_16MHZ ? PreambleCode::CODE_6 : PreambleCode::CODE_10;\n\t\t\t\tbreak;\n\t\t\tcase Channel::CHANNEL_4:\n\t\t\tcase Channel::CHANNEL_7:\n\t\t\t\tpreamble_code = _pulseFrequency == PulseFrequency::FREQ_16MHZ ? PreambleCode::CODE_8 : PreambleCode::CODE_18;\n\t\t\t\tbreak;\n\t\t\tcase Channel::CHANNEL_2:\n\t\t\tcase Channel::CHANNEL_5:\n\t\t\t\tpreamble_code = _pulseFrequency == PulseFrequency::FREQ_16MHZ ? PreambleCode::CODE_3 : PreambleCode::CODE_10;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn; // TODO Proper Error Handling\n\t\t\t}\n\t\t\tbyte preacode = static_cast<byte>(preamble_code);\n\t\t\tpreacode &= 0x1F;\n\t\t\t_chanctrl[2] &= 0x3F;\n\t\t\t_chanctrl[2] |= ((preacode << 6) & 0xFF);\n\t\t\t_chanctrl[3] = 0x00;\n\t\t\t_chanctrl[3] = ((((preacode >> 2) & 0x07) | (preacode << 3)) & 0xFF);\n\n\t\t\t_preambleCode = preamble_code;\n\t\t}\n\n\t\tvoid _setNonStandardSFDLength()\n\t\t{\n\t\t\tswitch (_dataRate)\n\t\t\t{\n\t\t\tcase DataRate::RATE_6800KBPS:\n\t\t\t\t_writeByte(USR_SFD, SFD_LENGTH_SUB, 0x08);\n\t\t\t\tbreak;\n\t\t\tcase DataRate::RATE_850KBPS:\n\t\t\t\t_writeByte(USR_SFD, SFD_LENGTH_SUB, 0x10);\n\t\t\t\tbreak;\n\t\t\tcase DataRate::RATE_110KBPS:\n\t\t\t\t_writeByte(USR_SFD, SFD_LENGTH_SUB, 0x40);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn; // TODO Proper error handling\n\t\t\t}\n\t\t}\n\n\t\tvoid _interruptOnSent(boolean val)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_MASK, TXFRS_BIT, val);\n\t\t}\n\n\t\tvoid _interruptOnReceived(boolean val)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_MASK, RXDFR_BIT, val);\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_MASK, RXFCG_BIT, val);\n\t\t}\n\n\t\tvoid _interruptOnReceiveFailed(boolean val)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_STATUS, RXPHE_BIT, val);\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_STATUS, RXFCE_BIT, val);\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_STATUS, RXRFSL_BIT, val);\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_STATUS, LDEERR_BIT, val);\n\t\t}\n\n\t\tvoid _interruptOnReceiveTimeout(boolean val)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_MASK, RXRFTO_BIT, val);\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_MASK, RXPTO_BIT, val);\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_MASK, RXSFDTO_BIT, val);\n\t\t}\n\n\t\tvoid _interruptOnReceiveTimestampAvailable(boolean val)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_MASK, LDEDONE_BIT, val);\n\t\t}\n\n\t\tvoid _interruptOnAutomaticAcknowledgeTrigger(boolean val)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_MASK, AAT_BIT, val);\n\t\t}\n\n\t\tvoid _manageLDE()\n\t\t{\n\t\t\t// transfer any ldo tune values\n\t\t\tbyte ldoTune[LEN_OTP_RDAT];\n\t\t\tuint16_t LDOTUNE_ADDRESS = 0x04;\n\t\t\t_readBytesOTP(LDOTUNE_ADDRESS, ldoTune); // TODO #define\n\t\t\tif (ldoTune[0] != 0)\n\t\t\t{\n\t\t\t\t// TODO tuning available, copy over to RAM: use OTP_LDO bit\n\t\t\t}\n\t\t\t// tell the chip to load the LDE microcode\n\t\t\t// TODO remove clock-related code (PMSC_CTRL) as handled separately\n\t\t\tbyte pmscctrl0[LEN_PMSC_CTRL0];\n\t\t\tbyte otpctrl[LEN_OTP_CTRL];\n\t\t\tmemset(pmscctrl0, 0, LEN_PMSC_CTRL0);\n\t\t\tmemset(otpctrl, 0, LEN_OTP_CTRL);\n\t\t\t_readBytes(PMSC, PMSC_CTRL0_SUB, pmscctrl0, LEN_PMSC_CTRL0);\n\t\t\t_readBytes(OTP_IF, OTP_CTRL_SUB, otpctrl, LEN_OTP_CTRL);\n\t\t\tpmscctrl0[0] = 0x01;\n\t\t\tpmscctrl0[1] = 0x03;\n\t\t\totpctrl[1] = 0x80;\n\t\t\t_writeBytesToRegister(PMSC, PMSC_CTRL0_SUB, pmscctrl0, 2);\n\t\t\t// uCode\n\t\t\t_enableClock(LDE_CLOCK);\n\t\t\tdelay(5);\n\t\t\t_writeBytesToRegister(OTP_IF, OTP_CTRL_SUB, otpctrl, 2);\n\t\t\tdelay(1);\n\t\t\t_enableClock(SYS_AUTO_CLOCK);\n\t\t\tdelay(5);\n\t\t\tpmscctrl0[0] = 0x00;\n\t\t\tpmscctrl0[1] &= 0x02;\n\t\t\t_writeBytesToRegister(PMSC, PMSC_CTRL0_SUB, pmscctrl0, 2);\n\t\t}\n\n\t\t/* Crystal calibration from OTP (if available)\n\t\t * FS_XTALT - reg:0x2B, sub-reg:0x0E\n\t\t * OTP(one-time-programmable) memory map - table 10 */\n\t\tvoid _fsxtalt()\n\t\t{\n\t\t\tbyte fsxtalt[LEN_FS_XTALT];\n\t\t\tbyte buf_otp[4];\n\t\t\t_readBytesOTP(0x01E, buf_otp); // 0x01E -> byte[0]=XTAL_Trim\n\t\t\tif (buf_otp[0] == 0)\n\t\t\t{\n\t\t\t\t// No trim value available from OTP, use midrange value of 0x10\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fsxtalt, ((0x10 & 0x1F) | 0x60), LEN_FS_XTALT);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fsxtalt, ((buf_otp[0] & 0x1F) | 0x60), LEN_FS_XTALT);\n\t\t\t}\n\t\t\t// write configuration back to chip\n\t\t\t_writeBytesToRegister(FS_CTRL, FS_XTALT_SUB, fsxtalt, LEN_FS_XTALT);\n\t\t}\n\n\t\tvoid _clearReceiveStatus()\n\t\t{\n\t\t\t// clear latched RX bits (i.e. write 1 to clear)\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXDFR_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXFCG_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXPRD_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXSFDD_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXPHD_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, LDEDONE_BIT, true);\n\t\t\t_writeBytesToRegister(SYS_STATUS, NO_SUB, _sysstatus, LEN_SYS_STATUS);\n\t\t}\n\n\t\tvoid _clearReceiveTimestampAvailableStatus()\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, LDEDONE_BIT, true);\n\t\t\t_writeBytesToRegister(SYS_STATUS, NO_SUB, _sysstatus, LEN_SYS_STATUS);\n\t\t}\n\n\t\tvoid _clearReceiveTimeoutStatus()\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXRFTO_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXPTO_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXSFDTO_BIT, true);\n\t\t\t_writeBytesToRegister(SYS_STATUS, NO_SUB, _sysstatus, LEN_SYS_STATUS);\n\t\t}\n\n\t\tvoid _clearReceiveFailedStatus()\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXPHE_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXFCE_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXRFSL_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, AFFREJ_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, LDEERR_BIT, true);\n\t\t\t_writeBytesToRegister(SYS_STATUS, NO_SUB, _sysstatus, LEN_SYS_STATUS);\n\t\t}\n\n\t\tvoid _clearTransmitStatus()\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, AAT_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, TXFRB_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, TXPRS_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, TXPHS_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, TXFRS_BIT, true);\n\t\t\t_writeBytesToRegister(SYS_STATUS, NO_SUB, _sysstatus, LEN_SYS_STATUS);\n\t\t}\n\n\t\tvoid _resetReceiver()\n\t\t{\n\t\t\t/* Set to 0 only bit 28 */\n\t\t\t_writeToRegister(PMSC, PMSC_SOFTRESET_SUB, 0xE0, LEN_PMSC_SOFTRESET);\n\t\t\t/* Set SOFTRESET to all ones */\n\t\t\t_writeToRegister(PMSC, PMSC_SOFTRESET_SUB, 0xF0, LEN_PMSC_SOFTRESET);\n\t\t}\n\n\t\t/* Internal helpers to read configuration */\n\n\t\tvoid _readSystemConfigurationRegister()\n\t\t{\n\t\t\t_readBytes(SYS_CFG, NO_SUB, _syscfg, LEN_SYS_CFG);\n\t\t}\n\n\t\tvoid _readSystemEventStatusRegister()\n\t\t{\n\t\t\t_readBytes(SYS_STATUS, NO_SUB, _sysstatus, LEN_SYS_STATUS);\n\t\t}\n\n\t\tvoid _readNetworkIdAndDeviceAddress()\n\t\t{\n\t\t\t_readBytes(PANADR, NO_SUB, _networkAndAddress, LEN_PANADR);\n\t\t}\n\n\t\tvoid _readSystemEventMaskRegister()\n\t\t{\n\t\t\t_readBytes(SYS_MASK, NO_SUB, _sysmask, LEN_SYS_MASK);\n\t\t}\n\n\t\tvoid _readChannelControlRegister()\n\t\t{\n\t\t\t_readBytes(CHAN_CTRL, NO_SUB, _chanctrl, LEN_CHAN_CTRL);\n\t\t}\n\n\t\tvoid _readTransmitFrameControlRegister()\n\t\t{\n\t\t\t_readBytes(TX_FCTRL, NO_SUB, _txfctrl, LEN_TX_FCTRL);\n\t\t}\n\n\t\tboolean _isTransmitDone()\n\t\t{\n\t\t\treturn DW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, TXFRS_BIT);\n\t\t}\n\n\t\tboolean _isReceiveTimestampAvailable()\n\t\t{\n\t\t\treturn DW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, LDEDONE_BIT);\n\t\t}\n\n\t\tboolean _isReceiveDone()\n\t\t{\n\t\t\tif (_frameCheck)\n\t\t\t{\n\t\t\t\treturn (DW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXFCG_BIT) &&\n\t\t\t\t\t\tDW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXDFR_BIT));\n\t\t\t}\n\t\t\treturn DW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXDFR_BIT);\n\t\t}\n\n\t\tboolean _isReceiveFailed()\n\t\t{\n\t\t\treturn (DW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXPHE_BIT) ||\n\t\t\t\t\tDW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXFCE_BIT) ||\n\t\t\t\t\tDW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXRFSL_BIT) ||\n\t\t\t\t\tDW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, LDEERR_BIT));\n\t\t}\n\n\t\tboolean _isReceiveTimeout()\n\t\t{\n\t\t\treturn (DW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXRFTO_BIT) ||\n\t\t\t\t\tDW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXPTO_BIT) ||\n\t\t\t\t\tDW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXSFDTO_BIT));\n\t\t}\n\n\t\tboolean _isClockProblem()\n\t\t{\n\t\t\treturn (DW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, CLKPLL_LL_BIT) ||\n\t\t\t\t\tDW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RFPLL_LL_BIT));\n\t\t}\n\n\t\tvoid _disableSequencing()\n\t\t{\n\t\t\t_enableClock(SYS_XTI_CLOCK);\n\t\t\tbyte zero[2];\n\t\t\tDW1000NgUtils::writeValueToBytes(zero, 0x0000, 2);\n\t\t\t_writeBytesToRegister(PMSC, PMSC_CTRL1_SUB, zero, 2); // To re-enable write 0xE7\n\t\t}\n\n\t\tvoid _configureRFTransmitPowerSpectrumTestMode()\n\t\t{\n\t\t\t/* Enabled TXFEN, PLLFEN, LDOFEN and set TXRXSW to TX */\n\t\t\tbyte enable_mask[4];\n\t\t\tDW1000NgUtils::writeValueToBytes(enable_mask, 0x005FFF00, LEN_RX_CONF_SUB);\n\t\t\t_writeBytesToRegister(RF_CONF, RF_CONF_SUB, enable_mask, LEN_RX_CONF_SUB);\n\t\t}\n\n\t\tvoid _uploadConfigToAON()\n\t\t{\n\t\t\t/* Write 1 in UPL_CFG_BIT */\n\t\t\t_writeToRegister(AON, AON_CTRL_SUB, 0x04, LEN_AON_CTRL);\n\t\t\t/* Clear the register */\n\t\t\t_writeToRegister(AON, AON_CTRL_SUB, 0x00, LEN_AON_CTRL);\n\t\t}\n\t}\n\n\t/* ####################### PUBLIC ###################### */\n\n\tvoid initialize(uint8_t ss, uint8_t irq, uint8_t rst)\n\t{\n\t\t// generous initial init/wake-up-idle delay\n\t\tdelay(5);\n\t\t_ss = ss;\n\t\t_irq = irq;\n\t\t_rst = rst;\n\n\t\tif (rst != 0xff)\n\t\t{\n\t\t\t// DW1000 data sheet v2.08 Â§5.6.1 page 20, the RSTn pin should not be driven high but left floating.\n\t\t\tpinMode(_rst, INPUT);\n\t\t}\n\n\t\tSPIporting::SPIinit();\n\t\t// pin and basic member setup\n\t\t// attach interrupt\n\t\t// TODO throw error if pin is not a interrupt pin\n\t\tif (_irq != 0xff)\n\t\t{\n\t\t\tattachInterrupt(digitalPinToInterrupt(_irq), interruptServiceRoutine, RISING);\n\t\t\t// attachInterrupt(digitalPinToInterrupt(_irq), interruptServiceRoutine, FALLING);\n\t\t}\n\n\t\tSPIporting::SPIselect(_ss, _irq);\n\t\t// reset chip (either soft or hard)\n\t\treset();\n\n\t\tSPIporting::setSPIspeed(SPIClock::SLOW);\n\t\t_enableClock(SYS_XTI_CLOCK);\n\t\tdelay(5);\n\n\t\t// Configure the CPLL lock detect\n\t\t_writeBitToRegister(EXT_SYNC, EC_CTRL_SUB, LEN_EC_CTRL, PLLLDT_BIT, true);\n\n\t\t// Configure XTAL trim\n\t\t_fsxtalt();\n\n\t\t// load LDE micro-code\n\t\t_manageLDE();\n\n\t\t// read the temp and vbat readings from OTP that were recorded during production test\n\t\t// see 6.3.1 OTP memory map\n\t\tbyte buf_otp[4];\n\t\t_readBytesOTP(0x008, buf_otp); // the stored 3.3 V reading\n\t\t_vmeas3v3 = buf_otp[0];\n\t\t// Serial.printf(\"_vmeas3v3=%d\\r\\n\", _vmeas3v3);\n\t\t_readBytesOTP(0x009, buf_otp); // the stored 23C reading\n\t\t_tmeas23C = buf_otp[0];\n\t\t// Serial.printf(\"_tmeas23C=%d\\r\\n\", _tmeas23C);\n\n\t\t_enableClock(SYS_AUTO_CLOCK);\n\t\tdelay(5);\n\t\tSPIporting::setSPIspeed(SPIClock::FAST);\n\n\t\t_readNetworkIdAndDeviceAddress();\n\t\t_readSystemConfigurationRegister();\n\t\t_readChannelControlRegister();\n\t\t_readTransmitFrameControlRegister();\n\t\t_readSystemEventMaskRegister();\n\n\t\t/* Cleared AON:CFG1(0x2C:0x0A) for proper operation of deepSleep */\n\t\t_writeToRegister(AON, AON_CFG1_SUB, 0x00, LEN_AON_CFG1);\n\t}\n\n\tvoid initializeNoInterrupt(uint8_t ss, uint8_t rst)\n\t{\n\t\tinitialize(ss, 0xff, rst);\n\t}\n\n\t/* callback handler management. */\n\tvoid attachErrorHandler(void (*handleError)(void))\n\t{\n\t\t_handleError = handleError;\n\t}\n\n\tvoid attachSentHandler(void (*handleSent)(void))\n\t{\n\t\t_handleSent = handleSent;\n\t}\n\n\tvoid attachReceivedHandler(void (*handleReceived)(void))\n\t{\n\t\t_handleReceived = handleReceived;\n\t}\n\n\tvoid attachReceiveFailedHandler(void (*handleReceiveFailed)(void))\n\t{\n\t\t_handleReceiveFailed = handleReceiveFailed;\n\t}\n\n\tvoid attachReceiveTimeoutHandler(void (*handleReceiveTimeout)(void))\n\t{\n\t\t_handleReceiveTimeout = handleReceiveTimeout;\n\t}\n\n\tvoid attachReceiveTimestampAvailableHandler(void (*handleReceiveTimestampAvailable)(void))\n\t{\n\t\t_handleReceiveTimestampAvailable = handleReceiveTimestampAvailable;\n\t}\n\n\tvoid interruptServiceRoutine()\n\t{\n\t\t// Serial.printf(\"test----------------------------0\\r\\n\");\n\t\t// read current status and handle via callbacks\n\t\t_readSystemEventStatusRegister();\n\t\tif (_isClockProblem() /* TODO and others */ && _handleError != 0)\n\t\t{\n\t\t\t(*_handleError)();\n\t\t\t// Serial.printf(\"interrupt----------------------------1\\r\\n\");\n\t\t}\n\t\tif (_isTransmitDone())\n\t\t{\n\t\t\t_clearTransmitStatus();\n\t\t\tif (_handleSent != nullptr)\n\t\t\t{\n\t\t\t\t(*_handleSent)();\n\t\t\t\t// Serial.printf(\"interrupt----------------------------2\\r\\n\");\n\t\t\t}\n\t\t}\n\t\tif (_isReceiveTimestampAvailable())\n\t\t{\n\t\t\t_clearReceiveTimestampAvailableStatus();\n\t\t\tif (_handleReceiveTimestampAvailable != nullptr)\n\t\t\t{\n\t\t\t\t(*_handleReceiveTimestampAvailable)();\n\t\t\t\t// Serial.printf(\"interrupt----------------------------3\\r\\n\");\n\t\t\t}\n\t\t}\n\t\tif (_isReceiveFailed())\n\t\t{\n\t\t\t_clearReceiveFailedStatus();\n\t\t\tforceTRxOff();\n\t\t\t_resetReceiver();\n\t\t\tif (_handleReceiveFailed != nullptr)\n\t\t\t{\n\t\t\t\t(*_handleReceiveFailed)();\n\t\t\t\t// Serial.printf(\"interrupt----------------------------4\\r\\n\");\n\t\t\t}\n\t\t}\n\t\telse if (_isReceiveTimeout())\n\t\t{\n\t\t\t_clearReceiveTimeoutStatus();\n\t\t\tforceTRxOff();\n\t\t\t_resetReceiver();\n\t\t\tif (_handleReceiveTimeout != nullptr)\n\t\t\t{\n\t\t\t\t(*_handleReceiveTimeout)();\n\t\t\t\t// Serial.printf(\"interrupt----------------------------5\\r\\n\");\n\t\t\t}\n\t\t}\n\t\telse if (_isReceiveDone())\n\t\t{\n\t\t\t_clearReceiveStatus();\n\t\t\tif (_handleReceived != nullptr)\n\t\t\t{\n\t\t\t\t(*_handleReceived)();\n\t\t\t\t// Serial.printf(\"interrupt----------------------------6\\r\\n\");\n\t\t\t}\n\t\t}\n\t\t// Latched bits in status register are reset by writing 1 to them\n\t\tmemset(_sysstatus, 0xff, LEN_SYS_STATUS);\n\t\t_writeBytesToRegister(SYS_STATUS, NO_SUB, _sysstatus, LEN_SYS_STATUS);\n\t}\n\n\tboolean isTransmitDone()\n\t{\n\t\t_readSystemEventStatusRegister();\n\t\treturn _isTransmitDone();\n\t}\n\n\tvoid clearTransmitStatus()\n\t{\n\t\t_clearTransmitStatus();\n\t}\n\n\tboolean isReceiveDone()\n\t{\n\t\t_readSystemEventStatusRegister();\n\t\treturn _isReceiveDone();\n\t}\n\n\tvoid clearReceiveStatus()\n\t{\n\t\t_clearReceiveStatus();\n\t}\n\n\tboolean isReceiveFailed()\n\t{\n\t\t_readSystemEventStatusRegister();\n\t\treturn _isReceiveFailed();\n\t}\n\n\tvoid clearReceiveFailedStatus()\n\t{\n\t\t_clearReceiveFailedStatus();\n\t\tforceTRxOff();\n\t\t_resetReceiver();\n\t}\n\n\tboolean isReceiveTimeout()\n\t{\n\t\t_readSystemEventMaskRegister();\n\t\treturn _isReceiveTimeout();\n\t}\n\n\tvoid clearReceiveTimeoutStatus()\n\t{\n\t\t_clearReceiveTimeoutStatus();\n\t\tforceTRxOff();\n\t\t_resetReceiver();\n\t}\n\n\tvoid enableDebounceClock()\n\t{\n\t\tbyte pmscctrl0[LEN_PMSC_CTRL0];\n\t\tmemset(pmscctrl0, 0, LEN_PMSC_CTRL0);\n\t\t_readBytes(PMSC, PMSC_CTRL0_SUB, pmscctrl0, LEN_PMSC_CTRL0);\n\t\tDW1000NgUtils::setBit(pmscctrl0, LEN_PMSC_CTRL0, GPDCE_BIT, 1);\n\t\tDW1000NgUtils::setBit(pmscctrl0, LEN_PMSC_CTRL0, KHZCLKEN_BIT, 1);\n\t\t_writeBytesToRegister(PMSC, PMSC_CTRL0_SUB, pmscctrl0, LEN_PMSC_CTRL0);\n\t\t_debounceClockEnabled = true;\n\t}\n\n\tvoid enableLedBlinking()\n\t{\n\t\tbyte pmscledc[LEN_PMSC_LEDC];\n\t\tmemset(pmscledc, 0, LEN_PMSC_LEDC);\n\t\t_readBytes(PMSC, PMSC_LEDC_SUB, pmscledc, LEN_PMSC_LEDC);\n\t\tDW1000NgUtils::setBit(pmscledc, LEN_PMSC_LEDC, BLNKEN, 1);\n\t\t_writeBytesToRegister(PMSC, PMSC_LEDC_SUB, pmscledc, LEN_PMSC_LEDC);\n\t}\n\n\tvoid setGPIOMode(uint8_t msgp, uint8_t mode)\n\t{\n\t\tbyte gpiomode[LEN_GPIO_MODE];\n\t\tmemset(gpiomode, 0, LEN_GPIO_MODE);\n\t\t_readBytes(GPIO_CTRL, GPIO_MODE_SUB, gpiomode, LEN_GPIO_MODE);\n\t\tfor (char i = 0; i < 2; i++)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(gpiomode, LEN_GPIO_MODE, msgp + i, (mode >> i) & 1);\n\t\t}\n\t\t_writeBytesToRegister(GPIO_CTRL, GPIO_MODE_SUB, gpiomode, LEN_GPIO_MODE);\n\t}\n\n\tvoid applySleepConfiguration(sleep_configuration_t sleep_config)\n\t{\n\t\tbyte aon_wcfg[LEN_AON_WCFG];\n\t\t_readBytes(AON, AON_WCFG_SUB, aon_wcfg, LEN_AON_WCFG);\n\t\tbyte aon_cfg0[1];\n\t\tmemset(aon_cfg0, 0, 1);\n\n\t\tDW1000NgUtils::setBit(aon_wcfg, LEN_AON_WCFG, ONW_RADC_BIT, sleep_config.onWakeUpRunADC);\n\t\tDW1000NgUtils::setBit(aon_wcfg, LEN_AON_WCFG, ONW_RX_BIT, sleep_config.onWakeUpReceive);\n\t\tDW1000NgUtils::setBit(aon_wcfg, LEN_AON_WCFG, ONW_LEUI_BIT, sleep_config.onWakeUpLoadEUI);\n\t\tDW1000NgUtils::setBit(aon_wcfg, LEN_AON_WCFG, ONW_LDC_BIT, true);\n\t\tDW1000NgUtils::setBit(aon_wcfg, LEN_AON_WCFG, ONW_L64P_BIT, sleep_config.onWakeUpLoadL64Param);\n\t\tDW1000NgUtils::setBit(aon_wcfg, LEN_AON_WCFG, ONW_PRES_SLEEP_BIT, sleep_config.preserveSleep);\n\t\tDW1000NgUtils::setBit(aon_wcfg, LEN_AON_WCFG, ONW_LLDE_BIT, true);\n\t\tDW1000NgUtils::setBit(aon_wcfg, LEN_AON_WCFG, ONW_LLDO_BIT, true);\n\t\t_writeBytesToRegister(AON, AON_WCFG_SUB, aon_wcfg, LEN_AON_WCFG);\n\n\t\tDW1000NgUtils::setBit(aon_cfg0, 1, WAKE_PIN_BIT, sleep_config.enableWakePIN);\n\t\tDW1000NgUtils::setBit(aon_cfg0, 1, WAKE_SPI_BIT, sleep_config.enableWakeSPI);\n\t\tDW1000NgUtils::setBit(aon_cfg0, 1, WAKE_CNT_BIT, false);\n\t\tDW1000NgUtils::setBit(aon_cfg0, 1, SLEEP_EN_BIT, sleep_config.enableSLP);\n\t\t_writeBytesToRegister(AON, AON_CFG0_SUB, aon_cfg0, 1); // Deletes 3 bits of the unused LPCLKDIVA\n\t}\n\n\t/*Puts the device into sleep/deepSleep mode. This function also upload sleep config to AON. */\n\tvoid deepSleep()\n\t{\n\t\t/* Clear the register */\n\t\t_writeToRegister(AON, AON_CTRL_SUB, 0x00, LEN_AON_CTRL);\n\t\t/* Write 1 in SAVE_BIT */\n\t\t_writeToRegister(AON, AON_CTRL_SUB, 0x02, LEN_AON_CTRL);\n\t}\n\n\tvoid spiWakeup()\n\t{\n\t\tbyte deviceId[LEN_DEV_ID];\n\t\tbyte expectedDeviceId[LEN_DEV_ID];\n\t\tDW1000NgUtils::writeValueToBytes(expectedDeviceId, 0xDECA0130, LEN_DEV_ID);\n\t\t_readBytes(DEV_ID, NO_SUB, deviceId, LEN_DEV_ID);\n\t\tif (memcmp(deviceId, expectedDeviceId, LEN_DEV_ID))\n\t\t{\n\t\t\tdigitalWrite(_ss, LOW);\n\t\t\tdelay(1);\n\t\t\tdigitalWrite(_ss, HIGH);\n\t\t\tdelay(5);\n\t\t\tsetTxAntennaDelay(_antennaTxDelay);\n\t\t\tif (_debounceClockEnabled)\n\t\t\t{\n\t\t\t\tenableDebounceClock();\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid reset()   \n\t{\n\t\tif (_rst == 0xff)\n\t\t{ /* Fallback to Software Reset */\n\t\t\tsoftwareReset();\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// DW1000Ng data sheet v2.08 Â§5.6.1 page 20, the RSTn pin should not be driven high but left floating.\n\t\t\tpinMode(_rst, OUTPUT);\n\t\t\tdigitalWrite(_rst, LOW);\n\t\t\tdelay(2); // DW1000Ng data sheet v2.08 Â§5.6.1 page 20: nominal 50ns, to be safe take more time\n\t\t\tpinMode(_rst, INPUT);\n\t\t\tdelay(5); // dw1000Ng data sheet v1.2 page 5: nominal 3 ms, to be safe take more time\n\t\t}\n\t}\n\n\tvoid softwareReset()\n\t{\n\t\tSPIporting::setSPIspeed(SPIClock::SLOW);\n\n\t\t/* Disable sequencing and go to state \"INIT\" - (a) Sets SYSCLKS to 01 */\n\t\t_disableSequencing();\n\t\t/* Clear AON and WakeUp configuration */\n\t\t_writeToRegister(AON, AON_WCFG_SUB, 0x00, LEN_AON_WCFG);\n\t\t_writeToRegister(AON, AON_CFG0_SUB, 0x00, LEN_AON_CFG0);\n\t\t// TODO change this with uploadToAON\n\t\t_writeToRegister(AON, AON_CTRL_SUB, 0x00, LEN_AON_CTRL);\n\t\t_writeToRegister(AON, AON_CTRL_SUB, 0x02, LEN_AON_CTRL);\n\t\t/* (b) Clear SOFTRESET to all zeroâ€™s */\n\t\t_writeToRegister(PMSC, PMSC_SOFTRESET_SUB, 0x00, LEN_PMSC_SOFTRESET);\n\t\tdelay(1);\n\t\t/* (c) Set SOFTRESET to all ones */\n\t\t_writeToRegister(PMSC, PMSC_SOFTRESET_SUB, 0xF0, LEN_PMSC_SOFTRESET);\n\t}\n\n\t/* ###########################################################################\n\t * #### Pretty printed device information ####################################\n\t * ######################################################################### */\n\n\tvoid getPrintableDeviceIdentifier(char msgBuffer[])\n\t{\n\t\tbyte data[LEN_DEV_ID];\n\t\t_readBytes(DEV_ID, NO_SUB, data, LEN_DEV_ID);\n\t\tsprintf(msgBuffer, \"%02X - model: %d, version: %d, revision: %d\",\n\t\t\t\t(uint16_t)((data[3] << 8) | data[2]), data[1], (data[0] >> 4) & 0x0F, data[0] & 0x0F);\n\t}\n\n\tvoid getPrintableExtendedUniqueIdentifier(char msgBuffer[])\n\t{\n\t\tbyte data[LEN_EUI];\n\t\t_readBytes(EUI, NO_SUB, data, LEN_EUI);\n\t\tsprintf(msgBuffer, \"%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X\",\n\t\t\t\tdata[7], data[6], data[5], data[4], data[3], data[2], data[1], data[0]);\n\t}\n\n\tvoid getPrintableNetworkIdAndShortAddress(char msgBuffer[])\n\t{\n\t\tbyte data[LEN_PANADR];\n\t\t_readBytes(PANADR, NO_SUB, data, LEN_PANADR);\n\t\tsprintf(msgBuffer, \"PAN: %02X, Short Address: %02X\",\n\t\t\t\t(uint16_t)((data[3] << 8) | data[2]), (uint16_t)((data[1] << 8) | data[0]));\n\t}\n\n\tvoid getPrintableDeviceMode(char msgBuffer[])\n\t{\n\t\tuint16_t dr;\n\t\tuint8_t prf;\n\t\tuint16_t plen;\n\t\tuint8_t pcode;\n\t\tuint8_t ch;\n\t\tbyte chan_ctrl[LEN_CHAN_CTRL];\n\t\tbyte tx_fctrl[LEN_TX_FCTRL];\n\t\t_readBytes(CHAN_CTRL, NO_SUB, chan_ctrl, LEN_CHAN_CTRL);\n\t\t_readBytes(TX_FCTRL, NO_SUB, tx_fctrl, LEN_TX_FCTRL);\n\t\t/* Data Rate from 0x08 bits:13-14(tx_fctrl) */\n\t\tdr = (uint16_t)(tx_fctrl[1] >> 5 & 0x3);\n\t\tswitch (dr)\n\t\t{\n\t\tcase 0x00:\n\t\t\tdr = 110;\n\t\t\tbreak;\n\t\tcase 0x01:\n\t\t\tdr = 850;\n\t\t\tbreak;\n\t\tcase 0x02:\n\t\t\tdr = 6800;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn; // TODO Error handling\n\t\t}\n\t\t/* PRF(16 or 64) from 0x1F bits:18-19(chan_ctrl) */\n\t\tprf = (uint8_t)(chan_ctrl[2] >> 2 & 0x03);\n\t\tif (prf == 0x01)\n\t\t{\n\t\t\tprf = 16;\n\t\t}\n\t\telse if (prf == 0x02)\n\t\t{\n\t\t\tprf = 64;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn; // TODO Error handling\n\t\t}\n\t\t/* PreambleLength from 0x08 bits:18-21(tx_fctrl) */\n\t\tplen = (uint16_t)(tx_fctrl[2] >> 2 & 0xF);\n\t\tswitch (plen)\n\t\t{\n\t\tcase 0x01:\n\t\t\tplen = 64;\n\t\t\tbreak;\n\t\tcase 0x05:\n\t\t\tplen = 128;\n\t\t\tbreak;\n\t\tcase 0x09:\n\t\t\tplen = 256;\n\t\t\tbreak;\n\t\tcase 0x0D:\n\t\t\tplen = 512;\n\t\t\tbreak;\n\t\tcase 0x02:\n\t\t\tplen = 1024;\n\t\t\tbreak;\n\t\tcase 0x06:\n\t\t\tplen = 1536;\n\t\t\tbreak;\n\t\tcase 0x0A:\n\t\t\tplen = 2048;\n\t\t\tbreak;\n\t\tcase 0x03:\n\t\t\tplen = 4096;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn; // TODO Error handling\n\t\t}\n\t\t/* Channel from 0x1F bits:0-4(tx_chan) */\n\t\tch = (uint8_t)(chan_ctrl[0] & 0xF);\n\t\t/* Preamble Code from 0x1F bits:24-31(chan_ctrl) */\n\t\tpcode = (uint8_t)(chan_ctrl[3] >> 3 & 0x1F);\n\t\tsprintf(msgBuffer, \"Data rate: %u kb/s, PRF: %u MHz, Preamble: %u symbols, Channel: #%u, Preamble code #%u\", dr, prf, plen, ch, pcode);\n\t}\n\n\t/* ###########################################################################\n\t * #### DW1000Ng operation functions ###########################################\n\t * ######################################################################### */\n\n\tvoid setNetworkId(uint16_t val)\n\t{\n\t\t_networkAndAddress[2] = (byte)(val & 0xFF);\n\t\t_networkAndAddress[3] = (byte)((val >> 8) & 0xFF);\n\t\t_writeNetworkIdAndDeviceAddress();\n\t}\n\n\tvoid getNetworkId(byte id[])\n\t{\n\t\t_readNetworkIdAndDeviceAddress();\n\t\tid[0] = _networkAndAddress[2];\n\t\tid[1] = _networkAndAddress[3];\n\t}\n\n\tvoid setDeviceAddress(uint16_t val)\n\t{\n\t\t_networkAndAddress[0] = (byte)(val & 0xFF);\n\t\t_networkAndAddress[1] = (byte)((val >> 8) & 0xFF);\n\t\t_writeNetworkIdAndDeviceAddress();\n\t}\n\n\tvoid getDeviceAddress(byte address[])\n\t{\n\t\t_readNetworkIdAndDeviceAddress();\n\t\taddress[0] = _networkAndAddress[0];\n\t\taddress[1] = _networkAndAddress[1];\n\t}\n\n\tvoid setEUI(char eui[])\n\t{\n\t\tbyte eui_byte[LEN_EUI];\n\t\tDW1000NgUtils::convertToByte(eui, eui_byte);\n\t\tsetEUI(eui_byte);\n\t}\n\n\tvoid setEUI(byte eui[])\n\t{\n\t\t// we reverse the address->\n\t\tbyte reverseEUI[8];\n\t\tuint8_t size = 8;\n\t\tfor (uint8_t i = 0; i < size; i++)\n\t\t{\n\t\t\t*(reverseEUI + i) = *(eui + size - i - 1);\n\t\t}\n\t\t_writeBytesToRegister(EUI, NO_SUB, reverseEUI, LEN_EUI);\n\t}\n\n\tvoid getEUI(byte eui[])\n\t{\n\t\t_readBytes(EUI, NO_SUB, eui, LEN_EUI);\n\t}\n\n\tfloat getTemperature()\n\t{\n\t\t_vbatAndTempSteps();\n\t\tbyte sar_ltemp = 0;\n\t\t_readBytes(TX_CAL, 0x04, &sar_ltemp, 1);\n\t\treturn (sar_ltemp - _tmeas23C) * 1.14f + 23.0f;\n\t}\n\n\tfloat getBatteryVoltage()\n\t{\n\t\t_vbatAndTempSteps();\n\t\tbyte sar_lvbat = 0;\n\t\t_readBytes(TX_CAL, 0x03, &sar_lvbat, 1);\n\t\treturn (sar_lvbat - _vmeas3v3) / 173.0f + 3.3f;\n\t}\n\n\tvoid getTemperatureAndBatteryVoltage(float &temp, float &vbat)\n\t{\n\t\t// follow the procedure from section 6.4 of the User Manual\n\t\t_vbatAndTempSteps();\n\t\tdelay(1);\n\t\tbyte sar_lvbat = 0;\n\t\t_readBytes(TX_CAL, 0x03, &sar_lvbat, 1);\n\t\tbyte sar_ltemp = 0;\n\t\t_readBytes(TX_CAL, 0x04, &sar_ltemp, 1);\n\n\t\t// calculate voltage and temperature\n\t\tvbat = (sar_lvbat - _vmeas3v3) / 173.0f + 3.3f;\n\t\ttemp = (sar_ltemp - _tmeas23C) * 1.14f + 23.0f;\n\t}\n\n\tvoid enableFrameFiltering(frame_filtering_configuration_t config)\n\t{\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFEN_BIT, true);\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFBC_BIT, config.behaveAsCoordinator);\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFAB_BIT, config.allowBeacon);\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFAD_BIT, config.allowData);\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFAA_BIT, config.allowAcknowledgement);\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFAM_BIT, config.allowMacCommand);\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFAR_BIT, config.allowAllReserved);\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFA4_BIT, config.allowReservedFour);\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFA5_BIT, config.allowReservedFive);\n\n\t\t_writeSystemConfigurationRegister();\n\t}\n\n\tvoid disableFrameFiltering()\n\t{\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFEN_BIT, false);\n\t\t_writeSystemConfigurationRegister();\n\t}\n\n\tvoid setDoubleBuffering(boolean val)\n\t{\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, DIS_DRXB_BIT, !val);\n\t}\n\n\tvoid setAntennaDelay(uint16_t value)\n\t{\n\t\t_antennaTxDelay = value;\n\t\t_antennaRxDelay = value;\n\t\t_writeAntennaDelayRegisters();\n\t}\n\n\tvoid setTxAntennaDelay(uint16_t value)\n\t{\n\t\t_antennaTxDelay = value;\n\t\t_writeAntennaDelayRegisters();\n\t}\n\tvoid setRxAntennaDelay(uint16_t value)\n\t{\n\t\t_antennaRxDelay = value;\n\t\t_writeAntennaDelayRegisters();\n\t}\n\n\tuint16_t getTxAntennaDelay()\n\t{\n\t\treturn _antennaTxDelay;\n\t}\n\tuint16_t getRxAntennaDelay()\n\t{\n\t\treturn _antennaRxDelay;\n\t}\n\n\tvoid forceTRxOff()\n\t{\n\t\tmemset(_sysctrl, 0, LEN_SYS_CTRL);\n\t\tDW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, TRXOFF_BIT, true);\n\t\t_writeBytesToRegister(SYS_CTRL, NO_SUB, _sysctrl, LEN_SYS_CTRL);\n\t}\n\n\tvoid startReceive(ReceiveMode mode)\n\t{\n\t\tmemset(_sysctrl, 0, LEN_SYS_CTRL);\n\t\tDW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, SFCST_BIT, !_frameCheck);\n\t\tif (mode == ReceiveMode::DELAYED)\n\t\t\tDW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, RXDLYS_BIT, true);\n\t\tDW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, RXENAB_BIT, true);\n\t\t_writeBytesToRegister(SYS_CTRL, NO_SUB, _sysctrl, LEN_SYS_CTRL);\n\t}\n\n\tvoid startTransmit(TransmitMode mode)\n\t{\n\t\tmemset(_sysctrl, 0, LEN_SYS_CTRL);\n\t\tDW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, SFCST_BIT, !_frameCheck);\n\t\tif (mode == TransmitMode::DELAYED)\n\t\t\tDW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, TXDLYS_BIT, true);\n\t\tif (_wait4resp)\n\t\t\tDW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, WAIT4RESP_BIT, true);\n\n\t\tDW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, TXSTRT_BIT, true);\n\t\t_writeBytesToRegister(SYS_CTRL, NO_SUB, _sysctrl, LEN_SYS_CTRL);\n\t}\n\n\tvoid setInterruptPolarity(boolean val)\n\t{\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, HIRQ_POL_BIT, val);\n\t\t_writeSystemConfigurationRegister();\n\t}\n\n\tvoid applyConfiguration(device_configuration_t config)\n\t{\n\t\tforceTRxOff();\n\n\t\t_useExtendedFrameLength(config.extendedFrameLength);\n\t\t_setReceiverAutoReenable(config.receiverAutoReenable);\n\t\t_useSmartPower(config.smartPower);\n\t\t_useFrameCheck(config.frameCheck);\n\t\t_setNlosOptimization(config.nlos);\n\t\t_setSFDMode(config.sfd);\n\t\t_setChannel(config.channel);\n\t\t_setDataRate(config.dataRate);\n\t\t_setPulseFrequency(config.pulseFreq);\n\t\t_setPreambleLength(config.preambleLen);\n\t\t_setPreambleCode(config.preaCode);\n\n\t\tif (!_checkPreambleCodeValidity())\n\t\t\t_setValidPreambleCode();\n\n\t\tif (!_standardSFD)\n\t\t\t_setNonStandardSFDLength();\n\n\t\t// writes configuration to registers\n\t\t_writeConfiguration();\n\t\t// tune according to configuration\n\t\t_tune();\n\t}\n\n\tChannel getChannel()\n\t{\n\t\treturn _channel;\n\t}\n\n\tPulseFrequency getPulseFrequency()\n\t{\n\t\treturn _pulseFrequency;\n\t}\n\n\tvoid setPreambleDetectionTimeout(uint16_t pacSize)\n\t{\n\t\tbyte drx_pretoc[LEN_DRX_PRETOC];\n\t\tDW1000NgUtils::writeValueToBytes(drx_pretoc, pacSize, LEN_DRX_PRETOC);\n\t\t_writeBytesToRegister(DRX_TUNE, DRX_PRETOC_SUB, drx_pretoc, LEN_DRX_PRETOC);\n\t}\n\n\tvoid setSfdDetectionTimeout(uint16_t preambleSymbols)\n\t{\n\t\tbyte drx_sfdtoc[LEN_DRX_SFDTOC];\n\t\tDW1000NgUtils::writeValueToBytes(drx_sfdtoc, preambleSymbols, LEN_DRX_SFDTOC);\n\t\t_writeBytesToRegister(DRX_TUNE, DRX_SFDTOC_SUB, drx_sfdtoc, LEN_DRX_SFDTOC);\n\t}\n\n\tvoid setReceiveFrameWaitTimeoutPeriod(uint16_t timeMicroSeconds)\n\t{\n\t\tif (timeMicroSeconds > 0)\n\t\t{\n\t\t\tbyte rx_wfto[LEN_RX_WFTO];\n\t\t\tDW1000NgUtils::writeValueToBytes(rx_wfto, timeMicroSeconds, LEN_RX_WFTO);\n\t\t\t_writeBytesToRegister(RX_WFTO, NO_SUB, rx_wfto, LEN_RX_WFTO);\n\t\t\t/* enable frame wait timeout bit */\n\t\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, RXWTOE_BIT, true);\n\t\t\t_writeSystemConfigurationRegister();\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* disable frame wait timeout bit */\n\t\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, RXWTOE_BIT, false);\n\t\t\t_writeSystemConfigurationRegister();\n\t\t}\n\t}\n\n\tvoid applyInterruptConfiguration(interrupt_configuration_t interrupt_config)\n\t{\n\t\tforceTRxOff();\n\n\t\t_interruptOnSent(interrupt_config.interruptOnSent);\n\t\t_interruptOnReceived(interrupt_config.interruptOnReceived);\n\t\t_interruptOnReceiveFailed(interrupt_config.interruptOnReceiveFailed);\n\t\t_interruptOnReceiveTimeout(interrupt_config.interruptOnReceiveTimeout);\n\t\t_interruptOnReceiveTimestampAvailable(interrupt_config.interruptOnReceiveTimestampAvailable);\n\t\t_interruptOnAutomaticAcknowledgeTrigger(interrupt_config.interruptOnAutomaticAcknowledgeTrigger);\n\n\t\t_writeSystemEventMaskRegister();\n\t}\n\n\tvoid setWait4Response(uint32_t timeMicroSeconds)\n\t{\n\t\t_wait4resp = timeMicroSeconds == 0 ? false : true;\n\n\t\t/* Check if it overflows 20 bits */\n\t\tif (timeMicroSeconds > 1048575)\n\t\t\ttimeMicroSeconds = 1048575;\n\n\t\tbyte W4R_TIME[LEN_ACK_RESP_T_W4R_TIME_SUB];\n\t\tDW1000NgUtils::writeValueToBytes(W4R_TIME, timeMicroSeconds, LEN_ACK_RESP_T_W4R_TIME_SUB);\n\t\tW4R_TIME[2] &= 0x0F;\n\t\t_writeBytesToRegister(ACK_RESP_T, ACK_RESP_T_W4R_TIME_SUB, W4R_TIME, LEN_ACK_RESP_T_W4R_TIME_SUB);\n\t}\n\n\tvoid setTXPower(byte power[])\n\t{\n\t\t// TODO Check byte length\n\t\t_writeBytesToRegister(TX_POWER, NO_SUB, power, LEN_TX_POWER);\n\t\t_autoTXPower = false;\n\t}\n\n\tvoid setTXPower(int32_t power)\n\t{\n\t\tbyte txpower[LEN_TX_POWER];\n\t\tDW1000NgUtils::writeValueToBytes(txpower, power, LEN_TX_POWER);\n\t\tsetTXPower(txpower);\n\t}\n\n\tvoid setTXPower(DriverAmplifierValue driver_amplifier, TransmitMixerValue mixer)\n\t{\n\t\tbyte txpower[LEN_TX_POWER];\n\t\tbyte pwr = 0x00;\n\n\t\tpwr |= ((byte)driver_amplifier << 5);\n\t\tpwr |= (byte)mixer;\n\n\t\tfor (auto i = 0; i < LEN_TX_POWER; i++)\n\t\t{\n\t\t\ttxpower[i] = pwr;\n\t\t}\n\n\t\tsetTXPower(txpower);\n\t}\n\n\tvoid setTXPowerAuto()\n\t{\n\t\t_autoTXPower = true;\n\t\t_txpowertune();\n\t}\n\n\tvoid setTCPGDelay(byte tcpgdelay)\n\t{\n\t\tbyte tcpgBytes[LEN_TC_PGDELAY];\n\t\tDW1000NgUtils::writeValueToBytes(tcpgBytes, tcpgdelay, LEN_TC_PGDELAY);\n\t\t_writeBytesToRegister(TX_CAL, TC_PGDELAY_SUB, tcpgBytes, LEN_TC_PGDELAY);\n\t\t_autoTCPGDelay = false;\n\t}\n\n\tvoid setTCPGDelayAuto()\n\t{\n\t\t_tcpgdelaytune();\n\t\t_autoTCPGDelay = true;\n\t}\n\n\tvoid enableTransmitPowerSpectrumTestMode(int32_t repeat_interval)\n\t{\n\t\t/* DW1000 clocks must be set to crystal speed so SPI rate have to be lowered and will\n\t\tnot be increased again */\n\t\tSPIporting::setSPIspeed(SPIClock::SLOW);\n\n\t\t_disableSequencing();\n\t\t_configureRFTransmitPowerSpectrumTestMode();\n\t\t_enableClock(SYS_PLL_CLOCK);\n\t\t_enableClock(TX_PLL_CLOCK);\n\n\t\tif (repeat_interval < 4)\n\t\t\trepeat_interval = 4;\n\n\t\t/* In diagnostic transmit power  mode (set next) the bytes 31:0 only are used for DX_TIME register */\n\t\tbyte delayBytes[4];\n\t\tDW1000NgUtils::writeValueToBytes(delayBytes, repeat_interval, 4);\n\t\t_writeBytesToRegister(DX_TIME, NO_SUB, delayBytes, 4);\n\n\t\t/* Enable Transmit Power Spectrum Test Mode */\n\t\tbyte diagnosticBytes[2];\n\t\tDW1000NgUtils::writeValueToBytes(diagnosticBytes, 0x0010, LEN_DIAG_TMC);\n\t\t_writeBytesToRegister(DIG_DIAG, DIAG_TMC_SUB, diagnosticBytes, LEN_DIAG_TMC);\n\t}\n\n\tvoid setDelayedTRX(byte futureTimeBytes[])\n\t{\n\t\t/* the least significant 9-bits are ignored in DX_TIME in functional modes */\n\t\t_writeBytesToRegister(DX_TIME, NO_SUB, futureTimeBytes, LEN_DX_TIME);\n\t}\n\n\tvoid setTransmitData(byte data[], uint16_t n)\n\t{\n\t\tif (_frameCheck)\n\t\t{\n\t\t\tn += 2; // two bytes CRC-16\n\t\t}\n\t\tif (n > LEN_EXT_UWB_FRAMES)\n\t\t{\n\t\t\treturn; // TODO proper error handling: frame/buffer size\n\t\t}\n\t\tif (n > LEN_UWB_FRAMES && !_extendedFrameLength)\n\t\t{\n\t\t\treturn; // TODO proper error handling: frame/buffer size\n\t\t}\n\t\t// transmit data and length\n\t\t_writeBytesToRegister(TX_BUFFER, NO_SUB, data, n);\n\n\t\t/* Sets up transmit frame control length based on data length */\n\t\t_txfctrl[0] = (byte)(n & 0xFF); // 1 byte (regular length + 1 bit)\n\t\t_txfctrl[1] &= 0xE0;\n\t\t_txfctrl[1] |= (byte)((n >> 8) & 0x03); // 2 added bits if extended length\n\t\t_writeTransmitFrameControlRegister();\n\t}\n\n\tvoid setTransmitData(const String &data)\n\t{\n\t\tuint16_t n = data.length() + 1;\n\t\tbyte *dataBytes = (byte *)malloc(n);\n\t\tdata.getBytes(dataBytes, n);\n\t\tsetTransmitData(dataBytes, n);\n\t\tfree(dataBytes);\n\t}\n\n\t// TODO reorder\n\tuint16_t getReceivedDataLength()\n\t{\n\t\tuint16_t len = 0;\n\n\t\t// 10 bits of RX frame control register\n\t\tbyte rxFrameInfo[LEN_RX_FINFO];\n\t\t_readBytes(RX_FINFO, NO_SUB, rxFrameInfo, LEN_RX_FINFO);\n\t\tlen = ((((uint16_t)rxFrameInfo[1] << 8) | (uint16_t)rxFrameInfo[0]) & 0x03FF);\n\n\t\tif (_frameCheck && len > 2)\n\t\t{\n\t\t\treturn len - 2;\n\t\t}\n\t\treturn len;\n\t}\n\n\tvoid getReceivedData(byte data[], uint16_t n)\n\t{\n\t\tif (n <= 0)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\t_readBytes(RX_BUFFER, NO_SUB, data, n);\n\t}\n\n\tvoid getReceivedData(String &data)\n\t{\n\t\tuint16_t i;\n\t\tuint16_t n = getReceivedDataLength(); // number of bytes w/o the two FCS ones\n\t\tif (n <= 0)\n\t\t{ // TODO\n\t\t\treturn;\n\t\t}\n\t\tbyte *dataBytes = (byte *)malloc(n);\n\t\tgetReceivedData(dataBytes, n);\n\t\t// clear string\n\t\tdata.remove(0);\n\t\tdata = \"\";\n\t\t// append to string\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tdata += (char)dataBytes[i];\n\t\t}\n\t\tfree(dataBytes);\n\t}\n\n\tuint64_t getTransmitTimestamp()\n\t{\n\t\tbyte data[LENGTH_TIMESTAMP];\n\t\tmemset(data, 0, LENGTH_TIMESTAMP);\n\t\t_readBytes(TX_TIME, TX_STAMP_SUB, data, LEN_TX_STAMP);\n\t\treturn DW1000NgUtils::bytesAsValue(data, LEN_TX_STAMP);\n\t}\n\n\tuint64_t getReceiveTimestamp()\n\t{\n\t\tbyte data[LEN_RX_STAMP];\n\t\tmemset(data, 0, LEN_RX_STAMP);\n\t\t_readBytes(RX_TIME, RX_STAMP_SUB, data, LEN_RX_STAMP);\n\t\treturn DW1000NgUtils::bytesAsValue(data, LEN_RX_STAMP);\n\t}\n\n\tuint64_t getSystemTimestamp()\n\t{\n\t\tbyte data[LEN_SYS_TIME];\n\t\tmemset(data, 0, LEN_SYS_TIME);\n\t\t_readBytes(SYS_TIME, NO_SUB, data, LEN_SYS_TIME);\n\t\treturn DW1000NgUtils::bytesAsValue(data, LEN_SYS_TIME);\n\t}\n\n\tfloat getReceiveQuality()\n\t{\n\t\tbyte noiseBytes[LEN_STD_NOISE];\n\t\tbyte fpAmpl2Bytes[LEN_FP_AMPL2];\n\t\tuint16_t noise, f2;\n\t\t_readBytes(RX_FQUAL, STD_NOISE_SUB, noiseBytes, LEN_STD_NOISE);\n\t\t_readBytes(RX_FQUAL, FP_AMPL2_SUB, fpAmpl2Bytes, LEN_FP_AMPL2);\n\t\tnoise = (uint16_t)noiseBytes[0] | ((uint16_t)noiseBytes[1] << 8);\n\t\tf2 = (uint16_t)fpAmpl2Bytes[0] | ((uint16_t)fpAmpl2Bytes[1] << 8);\n\t\treturn (float)f2 / noise;\n\t}\n\n\tfloat getFirstPathPower()\n\t{\n\t\tbyte fpAmpl1Bytes[LEN_FP_AMPL1];\n\t\tbyte fpAmpl2Bytes[LEN_FP_AMPL2];\n\t\tbyte fpAmpl3Bytes[LEN_FP_AMPL3];\n\t\tbyte rxFrameInfo[LEN_RX_FINFO];\n\t\tuint16_t f1, f2, f3, N;\n\t\tfloat A, corrFac;\n\t\t_readBytes(RX_TIME, FP_AMPL1_SUB, fpAmpl1Bytes, LEN_FP_AMPL1);\n\t\t_readBytes(RX_FQUAL, FP_AMPL2_SUB, fpAmpl2Bytes, LEN_FP_AMPL2);\n\t\t_readBytes(RX_FQUAL, FP_AMPL3_SUB, fpAmpl3Bytes, LEN_FP_AMPL3);\n\t\t_readBytes(RX_FINFO, NO_SUB, rxFrameInfo, LEN_RX_FINFO);\n\t\tf1 = (uint16_t)fpAmpl1Bytes[0] | ((uint16_t)fpAmpl1Bytes[1] << 8);\n\t\tf2 = (uint16_t)fpAmpl2Bytes[0] | ((uint16_t)fpAmpl2Bytes[1] << 8);\n\t\tf3 = (uint16_t)fpAmpl3Bytes[0] | ((uint16_t)fpAmpl3Bytes[1] << 8);\n\t\tN = (((uint16_t)rxFrameInfo[2] >> 4) & 0xFF) | ((uint16_t)rxFrameInfo[3] << 4);\n\n\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t{\n\t\t\tA = 113.77;\n\t\t\tcorrFac = 2.3334;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tA = 121.74;\n\t\t\tcorrFac = 1.1667;\n\t\t}\n\t\tfloat estFpPwr = 10.0 * log10(((float)f1 * (float)f1 + (float)f2 * (float)f2 + (float)f3 * (float)f3) / ((float)N * (float)N)) - A;\n\t\tif (estFpPwr <= -88)\n\t\t{\n\t\t\treturn estFpPwr;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// approximation of Fig. 22 in user manual for dbm correction\n\t\t\testFpPwr += (estFpPwr + 88) * corrFac;\n\t\t}\n\t\treturn estFpPwr;\n\t}\n\n\tfloat getReceivePower()\n\t{\n\t\tbyte cirPwrBytes[LEN_CIR_PWR];\n\t\tbyte rxFrameInfo[LEN_RX_FINFO];\n\t\tuint32_t twoPower17 = 131072;\n\t\tuint16_t C, N;\n\t\tfloat A, corrFac;\n\t\t_readBytes(RX_FQUAL, CIR_PWR_SUB, cirPwrBytes, LEN_CIR_PWR);\n\t\t_readBytes(RX_FINFO, NO_SUB, rxFrameInfo, LEN_RX_FINFO);\n\t\tC = (uint16_t)cirPwrBytes[0] | ((uint16_t)cirPwrBytes[1] << 8);\n\t\tN = (((uint16_t)rxFrameInfo[2] >> 4) & 0xFF) | ((uint16_t)rxFrameInfo[3] << 4);\n\n\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t{\n\t\t\tA = 113.77;\n\t\t\tcorrFac = 2.3334;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tA = 121.74;\n\t\t\tcorrFac = 1.1667;\n\t\t}\n\n\t\tfloat estRxPwr = 10.0 * log10(((float)C * (float)twoPower17) / ((float)N * (float)N)) - A;\n\t\tif (estRxPwr <= -88)\n\t\t{\n\t\t\treturn estRxPwr;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// approximation of Fig. 22 in user manual for dbm correction\n\t\t\testRxPwr += (estRxPwr + 88) * corrFac;\n\t\t}\n\t\treturn estRxPwr;\n\t}\n\n#if DW1000NG_DEBUG\n\tvoid getPrettyBytes(byte data[], char msgBuffer[], uint16_t n)\n\t{\n\t\tuint16_t i, j, b;\n\t\tb = sprintf(msgBuffer, \"Data, bytes: %d\\nB: 7 6 5 4 3 2 1 0\\n\", n); // TODO - type\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tbyte curByte = data[i];\n\t\t\tsnprintf(&msgBuffer[b++], 2, \"%d\", (i + 1));\n\t\t\tmsgBuffer[b++] = (char)((i + 1) & 0xFF);\n\t\t\tmsgBuffer[b++] = ':';\n\t\t\tmsgBuffer[b++] = ' ';\n\t\t\tfor (j = 0; j < 8; j++)\n\t\t\t{\n\t\t\t\tmsgBuffer[b++] = ((curByte >> (7 - j)) & 0x01) ? '1' : '0';\n\t\t\t\tif (j < 7)\n\t\t\t\t{\n\t\t\t\t\tmsgBuffer[b++] = ' ';\n\t\t\t\t}\n\t\t\t\telse if (i < n - 1)\n\t\t\t\t{\n\t\t\t\t\tmsgBuffer[b++] = '\\n';\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmsgBuffer[b++] = '\\0';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmsgBuffer[b++] = '\\0';\n\t}\n\n\tvoid getPrettyBytes(byte cmd, uint16_t offset, char msgBuffer[], uint16_t n)\n\t{\n\t\tuint16_t i, j, b;\n\t\tbyte *readBuf = (byte *)malloc(n);\n\t\t_readBytes(cmd, offset, readBuf, n);\n\t\tb = sprintf(msgBuffer, \"Reg: 0x%02x, bytes: %d\\nB: 7 6 5 4 3 2 1 0\\n\", cmd, n); // TODO - tpye\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tbyte curByte = readBuf[i];\n\t\t\tsnprintf(&msgBuffer[b++], 2, \"%d\", (i + 1));\n\t\t\tmsgBuffer[b++] = (char)((i + 1) & 0xFF);\n\t\t\tmsgBuffer[b++] = ':';\n\t\t\tmsgBuffer[b++] = ' ';\n\t\t\tfor (j = 0; j < 8; j++)\n\t\t\t{\n\t\t\t\tmsgBuffer[b++] = ((curByte >> (7 - j)) & 0x01) ? '1' : '0';\n\t\t\t\tif (j < 7)\n\t\t\t\t{\n\t\t\t\t\tmsgBuffer[b++] = ' ';\n\t\t\t\t}\n\t\t\t\telse if (i < n - 1)\n\t\t\t\t{\n\t\t\t\t\tmsgBuffer[b++] = '\\n';\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmsgBuffer[b++] = '\\0';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmsgBuffer[b++] = '\\0';\n\t\tfree(readBuf);\n\t}\n#endif\n}"}}}Content-Length: 175

{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"}}}
>>>
Content-Length: 183

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///c:/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","diagnostics":[]},"jsonrpc":"2.0"}
<<<
Content-Length: 228

{"jsonrpc":"2.0","id":126,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":53,"character":24}}}
>>>
Content-Length: 771

{"id":126,"result":{"contents":{"kind":"markdown","value":"### function `initializeNoInterrupt`  \n\n---\nâ†’ `void`  \nParameters:  \n- `uint8_t ss`\n- `uint8_t rst = 255`\n\nInitiates and starts a sessions with a DW1000 without interrupt. If rst is not set or value 0xff, a soft resets (i.e. command triggered) are used and it is assumed that no reset line is wired.  \n@param[in] ss The SPI Selection pin used to identify the specific connection  \n@param[in] rst The reset line/pin for hard resets of ICs that connect to the Arduino. Value 0xff means soft reset.  \n\n---\n```cpp\n// In namespace DW1000Ng\nvoid initializeNoInterrupt(uint8_t ss, uint8_t rst = 255)\n```"},"range":{"start":{"line":53,"character":12},"end":{"line":53,"character":33}}},"jsonrpc":"2.0"}
<<<
Content-Length: 228

{"jsonrpc":"2.0","id":127,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":53,"character":25}}}
>>>
Content-Length: 771

{"id":127,"result":{"contents":{"kind":"markdown","value":"### function `initializeNoInterrupt`  \n\n---\nâ†’ `void`  \nParameters:  \n- `uint8_t ss`\n- `uint8_t rst = 255`\n\nInitiates and starts a sessions with a DW1000 without interrupt. If rst is not set or value 0xff, a soft resets (i.e. command triggered) are used and it is assumed that no reset line is wired.  \n@param[in] ss The SPI Selection pin used to identify the specific connection  \n@param[in] rst The reset line/pin for hard resets of ICs that connect to the Arduino. Value 0xff means soft reset.  \n\n---\n```cpp\n// In namespace DW1000Ng\nvoid initializeNoInterrupt(uint8_t ss, uint8_t rst = 255)\n```"},"range":{"start":{"line":53,"character":12},"end":{"line":53,"character":33}}},"jsonrpc":"2.0"}
<<<
Content-Length: 233

{"jsonrpc":"2.0","id":128,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":53,"character":26}}}
>>>
Content-Length: 215

{"id":128,"result":[{"uri":"file:///C:/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","range":{"start":{"line":1643,"character":6},"end":{"line":1643,"character":27}}}],"jsonrpc":"2.0"}
<<<
Content-Length: 82613

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","languageId":"cpp","version":1,"text":"/*\n * MIT License\n *\n * Copyright (c) 2018 Michele Biondi, Andrea Salvatori\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n/*\n * Copyright (c) 2015 by Thomas Trojer <thomas@trojer.net>\n * Decawave DW1000Ng library for arduino.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @file DW1000Ng.cpp\n * Arduino driver library (source file) for the Decawave DW1000Ng UWB transceiver Module.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"DW1000Ng.hpp\"\n#include \"DW1000NgUtils.hpp\"\n#include \"DW1000NgConstants.hpp\"\n#include \"DW1000NgRegisters.hpp\"\n#include \"SPIporting.hpp\"\n\nnamespace DW1000Ng\n{\n\n\t/* anonymous namespace to host private-like variables and methods */\n\tnamespace\n\t{\n\n\t\t/* ########################### PRIVATE VARIABLES ################################# */\n\n\t\t/* SPI select pin and interrupt pin*/\n\t\tuint8_t _ss = 0xff;\n\t\tuint8_t _irq = 0xff;\n\t\tuint8_t _rst = 0xff;\n\n\t\t/* IRQ callbacks */\n\t\tvoid (*_handleSent)(void) = nullptr;\n\t\tvoid (*_handleError)(void) = nullptr;\n\t\tvoid (*_handleReceived)(void) = nullptr;\n\t\tvoid (*_handleReceiveFailed)(void) = nullptr;\n\t\tvoid (*_handleReceiveTimeout)(void) = nullptr;\n\t\tvoid (*_handleReceiveTimestampAvailable)(void) = nullptr;\n\n\t\t/* registers */\n\t\tbyte _syscfg[LEN_SYS_CFG];\n\t\tbyte _sysctrl[LEN_SYS_CTRL];\n\t\tbyte _sysstatus[LEN_SYS_STATUS];\n\t\tbyte _txfctrl[LEN_TX_FCTRL];\n\t\tbyte _sysmask[LEN_SYS_MASK];\n\t\tbyte _chanctrl[LEN_CHAN_CTRL];\n\t\tbyte _networkAndAddress[LEN_PANADR];\n\n\t\t/* Temperature and Voltage monitoring */\n\t\tbyte _vmeas3v3 = 0;\n\t\tbyte _tmeas23C = 0;\n\n\t\t/* Driver Internal State Trackers */\n\t\tbyte _extendedFrameLength;\n\t\tPacSize _pacSize;\n\t\tPulseFrequency _pulseFrequency;\n\t\tDataRate _dataRate;\n\t\tPreambleLength _preambleLength;\n\t\tPreambleCode _preambleCode;\n\t\tChannel _channel;\n\t\tboolean _smartPower;\n\t\tboolean _frameCheck;\n\t\tboolean _debounceClockEnabled = false;\n\t\tboolean _nlos = false;\n\t\tboolean _standardSFD = true;\n\t\tboolean _autoTXPower = true;\n\t\tboolean _autoTCPGDelay = true;\n\t\tboolean _wait4resp = false;\n\t\tuint16_t _antennaTxDelay = 0;\n\t\tuint16_t _antennaRxDelay = 0;\n\n\t\t/* ############################# PRIVATE METHODS ################################### */\n\t\t/*\n\t\t * Write bytes to the DW1000Ng. Single bytes can be written to registers via sub-addressing.\n\t\t * @param cmd\n\t\t * \t\tThe register address (see Chapter 7 in the DW1000Ng user manual).\n\t\t * @param offset\n\t\t *\t\tThe offset to select register sub-parts for writing, or 0x00 to disable\n\t\t * \t\tsub-adressing.\n\t\t * @param data\n\t\t *\t\tThe data array to be written.\n\t\t * @param data_size\n\t\t *\t\tThe number of bytes to be written (take care not to go out of bounds of\n\t\t * \t\tthe register).\n\t\t */\n\t\t// TODO offset really bigger than byte?\n\n\t\tvoid _writeBytesToRegister(byte cmd, uint16_t offset, byte data[], uint16_t data_size)\n\t\t{\n\t\t\tbyte header[3];\n\t\t\tuint8_t headerLen = 1;\n\n\t\t\t// TODO proper error handling: address out of bounds\n\t\t\t// build SPI header\n\t\t\tif (offset == NO_SUB)\n\t\t\t{\n\t\t\t\theader[0] = WRITE | cmd;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\theader[0] = WRITE_SUB | cmd;\n\t\t\t\tif (offset < 128)\n\t\t\t\t{\n\t\t\t\t\theader[1] = (byte)offset;\n\t\t\t\t\theaderLen++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\theader[1] = RW_SUB_EXT | (byte)offset;\n\t\t\t\t\theader[2] = (byte)(offset >> 7);\n\t\t\t\t\theaderLen += 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSPIporting::writeToSPI(_ss, headerLen, header, data_size, data);\n\t\t}\n\n\t\tvoid _writeToRegister(byte cmd, uint16_t offset, uint32_t data, uint16_t data_size)\n\t\t{\n\t\t\tbyte dataBytes[data_size];\n\t\t\tDW1000NgUtils::writeValueToBytes(dataBytes, data, data_size);\n\t\t\t_writeBytesToRegister(cmd, offset, dataBytes, data_size);\n\t\t}\n\n\t\t// Helper to set a single register\n\t\tvoid _writeByte(byte cmd, uint16_t offset, byte data)\n\t\t{\n\t\t\t_writeBytesToRegister(cmd, offset, &data, 1);\n\t\t}\n\n\t\t/*\n\t\t * Read bytes from the DW1000Ng. Number of bytes depend on register length.\n\t\t * @param cmd\n\t\t * \t\tThe register address (see Chapter 7 in the DW1000Ng user manual).\n\t\t * @param data\n\t\t *\t\tThe data array to be read into.\n\t\t * @param n\n\t\t *\t\tThe number of bytes expected to be received.\n\t\t */\n\t\t// TODO incomplete doc\n\t\tvoid _readBytes(byte cmd, uint16_t offset, byte data[], uint16_t data_size)\n\t\t{\n\t\t\tbyte header[3];\n\t\t\tuint8_t headerLen = 1;\n\n\t\t\t// build SPI header\n\t\t\tif (offset == NO_SUB)\n\t\t\t{\n\t\t\t\theader[0] = READ | cmd;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\theader[0] = READ_SUB | cmd;\n\t\t\t\tif (offset < 128)\n\t\t\t\t{\n\t\t\t\t\theader[1] = (byte)offset;\n\t\t\t\t\theaderLen++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\theader[1] = RW_SUB_EXT | (byte)offset;\n\t\t\t\t\theader[2] = (byte)(offset >> 7);\n\t\t\t\t\theaderLen += 2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSPIporting::readFromSPI(_ss, headerLen, header, data_size, data);\n\t\t}\n\n\t\t// always 4 bytes\n\t\t// TODO why always 4 bytes? can be different, see p. 58 table 10 otp memory map\n\t\tvoid _readBytesOTP(uint16_t address, byte data[])\n\t\t{\n\t\t\tbyte addressBytes[LEN_OTP_ADDR];\n\n\t\t\t// p60 - 6.3.3 Reading a value from OTP memory\n\t\t\t// bytes of address\n\t\t\taddressBytes[0] = (address & 0xFF);\n\t\t\taddressBytes[1] = ((address >> 8) & 0xFF);\n\t\t\t// set address\n\t\t\t_writeBytesToRegister(OTP_IF, OTP_ADDR_SUB, addressBytes, LEN_OTP_ADDR);\n\t\t\t// switch into read mode\n\t\t\t_writeByte(OTP_IF, OTP_CTRL_SUB, 0x03); // OTPRDEN | OTPREAD\n\t\t\t_writeByte(OTP_IF, OTP_CTRL_SUB, 0x01); // OTPRDEN\n\t\t\t// read value/block - 4 bytes\n\t\t\t_readBytes(OTP_IF, OTP_RDAT_SUB, data, LEN_OTP_RDAT);\n\t\t\t// end read mode\n\t\t\t_writeByte(OTP_IF, OTP_CTRL_SUB, 0x00);\n\t\t}\n\n\t\tvoid _writeBitToRegister(byte bitRegister, uint16_t RegisterOffset, uint16_t bitRegister_LEN, uint16_t selectedBit, boolean value)\n\t\t{\n\t\t\tuint16_t idx;\n\t\t\tuint8_t bitPosition;\n\n\t\t\tidx = selectedBit / 8;\n\t\t\tif (idx >= bitRegister_LEN)\n\t\t\t{\n\t\t\t\treturn; // TODO proper error handling: out of bounds\n\t\t\t}\n\t\t\tbyte targetByte;\n\t\t\tmemset(&targetByte, 0, 1);\n\t\t\tbitPosition = selectedBit % 8;\n\t\t\t_readBytes(bitRegister, RegisterOffset + idx, &targetByte, 1);\n\n\t\t\tvalue ? bitSet(targetByte, bitPosition) : bitClear(targetByte, bitPosition);\n\n\t\t\tif (RegisterOffset == NO_SUB)\n\t\t\t\tRegisterOffset = 0x00;\n\n\t\t\t_writeBytesToRegister(bitRegister, RegisterOffset + idx, &targetByte, 1);\n\t\t}\n\n\t\tvoid _enableClock(byte clock)\n\t\t{\n\t\t\tbyte pmscctrl0[LEN_PMSC_CTRL0];\n\t\t\tmemset(pmscctrl0, 0, LEN_PMSC_CTRL0);\n\t\t\t_readBytes(PMSC, PMSC_CTRL0_SUB, pmscctrl0, LEN_PMSC_CTRL0);\n\t\t\tif (clock == SYS_AUTO_CLOCK)\n\t\t\t{\n\t\t\t\tpmscctrl0[0] = SYS_AUTO_CLOCK;\n\t\t\t\tpmscctrl0[1] &= 0xFE;\n\t\t\t}\n\t\t\telse if (clock == SYS_XTI_CLOCK)\n\t\t\t{\n\t\t\t\tpmscctrl0[0] &= 0xFC;\n\t\t\t\tpmscctrl0[0] |= SYS_XTI_CLOCK;\n\t\t\t}\n\t\t\telse if (clock == SYS_PLL_CLOCK)\n\t\t\t{\n\t\t\t\tpmscctrl0[0] &= 0xFC;\n\t\t\t\tpmscctrl0[0] |= SYS_PLL_CLOCK;\n\t\t\t}\n\t\t\telse if (clock == TX_PLL_CLOCK)\n\t\t\t{\n\t\t\t\tpmscctrl0[0] &= 0xCF;\n\t\t\t\tpmscctrl0[0] |= TX_PLL_CLOCK;\n\t\t\t}\n\t\t\telse if (clock == LDE_CLOCK)\n\t\t\t{\n\t\t\t\tpmscctrl0[0] = SYS_XTI_CLOCK;\n\t\t\t\tpmscctrl0[1] = 0x03;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO deliver proper warning\n\t\t\t}\n\t\t\t_writeBytesToRegister(PMSC, PMSC_CTRL0_SUB, pmscctrl0, 2);\n\t\t}\n\n\t\t/* Steps used to get Temp and Voltage */\n\t\tvoid _vbatAndTempSteps()\n\t\t{\n\t\t\tbyte step1 = 0x80;\n\t\t\t_writeBytesToRegister(RF_CONF, 0x11, &step1, 1);\n\t\t\tbyte step2 = 0x0A;\n\t\t\t_writeBytesToRegister(RF_CONF, 0x12, &step2, 1);\n\t\t\tbyte step3 = 0x0F;\n\t\t\t_writeBytesToRegister(RF_CONF, 0x12, &step3, 1);\n\t\t\tbyte step4 = 0x01;\n\t\t\t_writeBytesToRegister(TX_CAL, NO_SUB, &step4, 1);\n\t\t\tbyte step5 = 0x00;\n\t\t\t_writeBytesToRegister(TX_CAL, NO_SUB, &step5, 1);\n\t\t}\n\n\t\t/* AGC_TUNE1 - reg:0x23, sub-reg:0x04, table 24 */\n\t\tvoid _agctune1()\n\t\t{\n\t\t\tbyte agctune1[LEN_AGC_TUNE1];\n\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(agctune1, 0x8870, LEN_AGC_TUNE1);\n\t\t\t}\n\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(agctune1, 0x889B, LEN_AGC_TUNE1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(AGC_TUNE, AGC_TUNE1_SUB, agctune1, LEN_AGC_TUNE1);\n\t\t}\n\n\t\t/* AGC_TUNE2 - reg:0x23, sub-reg:0x0C, table 25 */\n\t\tvoid _agctune2()\n\t\t{\n\t\t\tbyte agctune2[LEN_AGC_TUNE2];\n\t\t\tDW1000NgUtils::writeValueToBytes(agctune2, 0x2502A907L, LEN_AGC_TUNE2);\n\t\t\t_writeBytesToRegister(AGC_TUNE, AGC_TUNE2_SUB, agctune2, LEN_AGC_TUNE2);\n\t\t}\n\n\t\t/* AGC_TUNE3 - reg:0x23, sub-reg:0x12, table 26 */\n\t\tvoid _agctune3()\n\t\t{\n\t\t\tbyte agctune3[LEN_AGC_TUNE3];\n\t\t\tDW1000NgUtils::writeValueToBytes(agctune3, 0x0035, LEN_AGC_TUNE3);\n\t\t\t_writeBytesToRegister(AGC_TUNE, AGC_TUNE3_SUB, agctune3, LEN_AGC_TUNE3);\n\t\t}\n\n\t\t/* DRX_TUNE0b - reg:0x27, sub-reg:0x02, table 30 */\n\t\tvoid _drxtune0b()\n\t\t{\n\t\t\tbyte drxtune0b[LEN_DRX_TUNE0b];\n\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t{\n\t\t\t\tif (!_standardSFD)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune0b, 0x0016, LEN_DRX_TUNE0b);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune0b, 0x000A, LEN_DRX_TUNE0b);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_dataRate == DataRate::RATE_850KBPS)\n\t\t\t{\n\t\t\t\tif (!_standardSFD)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune0b, 0x0006, LEN_DRX_TUNE0b);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune0b, 0x0001, LEN_DRX_TUNE0b);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_dataRate == DataRate::RATE_6800KBPS)\n\t\t\t{\n\t\t\t\tif (!_standardSFD)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune0b, 0x0002, LEN_DRX_TUNE0b);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune0b, 0x0001, LEN_DRX_TUNE0b);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(DRX_TUNE, DRX_TUNE0b_SUB, drxtune0b, LEN_DRX_TUNE0b);\n\t\t}\n\n\t\t/* DRX_TUNE1a - reg:0x27, sub-reg:0x04, table 31 */\n\t\tvoid _drxtune1a()\n\t\t{\n\t\t\tbyte drxtune1a[LEN_DRX_TUNE1a];\n\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune1a, 0x0087, LEN_DRX_TUNE1a);\n\t\t\t}\n\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune1a, 0x008D, LEN_DRX_TUNE1a);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(DRX_TUNE, DRX_TUNE1a_SUB, drxtune1a, LEN_DRX_TUNE1a);\n\t\t}\n\n\t\t/* DRX_TUNE1b - reg:0x27, sub-reg:0x06, table 32 */\n\t\tvoid _drxtune1b()\n\t\t{\n\t\t\tbyte drxtune1b[LEN_DRX_TUNE1b];\n\t\t\tif (_preambleLength == PreambleLength::LEN_1536 || _preambleLength == PreambleLength::LEN_2048 ||\n\t\t\t\t_preambleLength == PreambleLength::LEN_4096)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune1b, 0x0064, LEN_DRX_TUNE1b);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleLength != PreambleLength::LEN_64)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_850KBPS || _dataRate == DataRate::RATE_6800KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune1b, 0x0020, LEN_DRX_TUNE1b);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_6800KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune1b, 0x0010, LEN_DRX_TUNE1b);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\t_writeBytesToRegister(DRX_TUNE, DRX_TUNE1b_SUB, drxtune1b, LEN_DRX_TUNE1b);\n\t\t}\n\n\t\t/* DRX_TUNE2 - reg:0x27, sub-reg:0x08, table 33 */\n\t\tvoid _drxtune2()\n\t\t{\n\t\t\tbyte drxtune2[LEN_DRX_TUNE2];\n\t\t\tif (_pacSize == PacSize::SIZE_8)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune2, 0x311A002DL, LEN_DRX_TUNE2);\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune2, 0x313B006BL, LEN_DRX_TUNE2);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_pacSize == PacSize::SIZE_16)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune2, 0x331A0052L, LEN_DRX_TUNE2);\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune2, 0x333B00BEL, LEN_DRX_TUNE2);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_pacSize == PacSize::SIZE_32)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune2, 0x351A009AL, LEN_DRX_TUNE2);\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune2, 0x353B015EL, LEN_DRX_TUNE2);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_pacSize == PacSize::SIZE_64)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune2, 0x371A011DL, LEN_DRX_TUNE2);\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune2, 0x373B0296L, LEN_DRX_TUNE2);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(DRX_TUNE, DRX_TUNE2_SUB, drxtune2, LEN_DRX_TUNE2);\n\t\t}\n\n\t\t/* DRX_TUNE4H - reg:0x27, sub-reg:0x26, table 34 */\n\t\tvoid _drxtune4H()\n\t\t{\n\t\t\tbyte drxtune4H[LEN_DRX_TUNE4H];\n\t\t\tif (_preambleLength == PreambleLength::LEN_64)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune4H, 0x0010, LEN_DRX_TUNE4H);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(drxtune4H, 0x0028, LEN_DRX_TUNE4H);\n\t\t\t}\n\t\t\t_writeBytesToRegister(DRX_TUNE, DRX_TUNE4H_SUB, drxtune4H, LEN_DRX_TUNE4H);\n\t\t}\n\n\t\t/* LDE_CFG1 - reg 0x2E, sub-reg:0x0806 */\n\t\tvoid _ldecfg1()\n\t\t{\n\t\t\tbyte ldecfg1[LEN_LDE_CFG1];\n\t\t\t_nlos == true ? DW1000NgUtils::writeValueToBytes(ldecfg1, 0x7, LEN_LDE_CFG1) : DW1000NgUtils::writeValueToBytes(ldecfg1, 0xD, LEN_LDE_CFG1);\n\t\t\t_writeBytesToRegister(LDE_IF, LDE_CFG1_SUB, ldecfg1, LEN_LDE_CFG1);\n\t\t}\n\n\t\t/* LDE_CFG2 - reg 0x2E, sub-reg:0x1806, table 50 */\n\t\tvoid _ldecfg2()\n\t\t{\n\t\t\tbyte ldecfg2[LEN_LDE_CFG2];\n\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t{\n\t\t\t\t_nlos == true ? DW1000NgUtils::writeValueToBytes(ldecfg2, 0x0003, LEN_LDE_CFG2) : DW1000NgUtils::writeValueToBytes(ldecfg2, 0x1607, LEN_LDE_CFG2);\n\t\t\t}\n\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(ldecfg2, 0x0607, LEN_LDE_CFG2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(LDE_IF, LDE_CFG2_SUB, ldecfg2, LEN_LDE_CFG2);\n\t\t}\n\n\t\t/* LDE_REPC - reg 0x2E, sub-reg:0x2804, table 51 */\n\t\tvoid _lderepc()\n\t\t{\n\t\t\tbyte lderepc[LEN_LDE_REPC];\n\t\t\tif (_preambleCode == PreambleCode::CODE_1 || _preambleCode == PreambleCode::CODE_2)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x5998 >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x5998, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_3 || _preambleCode == PreambleCode::CODE_8)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x51EA >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x51EA, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_4)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x428E >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x428E, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_5)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x451E >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x451E, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_6)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x2E14 >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x2E14, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_7)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x8000 >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x8000, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_9)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x28F4 >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x28F4, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_10 || _preambleCode == PreambleCode::CODE_17)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x3332 >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x3332, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_11)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x3AE0 >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x3AE0, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_12)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x3D70 >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x3D70, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_18 || _preambleCode == PreambleCode::CODE_19)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x35C2 >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x35C2, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_preambleCode == PreambleCode::CODE_20)\n\t\t\t{\n\t\t\t\tif (_dataRate == DataRate::RATE_110KBPS)\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, ((0x47AE >> 3) & 0xFFFF), LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDW1000NgUtils::writeValueToBytes(lderepc, 0x47AE, LEN_LDE_REPC);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\n\t\t\t_writeBytesToRegister(LDE_IF, LDE_REPC_SUB, lderepc, LEN_LDE_REPC);\n\t\t}\n\n\t\t/* TX_POWER (enabled smart transmit power control) - reg:0x1E, tables 19-20\n\t\t * These values are based on a typical IC and an assumed IC to antenna loss of 1.5 dB with a 0 dBi antenna */\n\t\tvoid _txpowertune()\n\t\t{\n\t\t\tbyte txpower[LEN_TX_POWER];\n\t\t\tif (_channel == Channel::CHANNEL_1 || _channel == Channel::CHANNEL_2)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x1B153555L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x15355575L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x55555555L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x75757575L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x0D072747L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x07274767L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x47474747L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x67676767L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_3)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x150F2F4FL, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x0F2F4F6FL, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x4F4F4F4FL, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x6F6F6F6FL, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x0B2B4B6BL, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x2B4B6B8BL, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x6B6B6B6BL, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x8B8B8B8BL, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_4)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x1F1F1F3FL, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x1F1F3F5FL, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x3F3F3F3FL, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x5F5F5F5FL, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x1A3A5A7AL, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x3A5A7A9AL, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x7A7A7A7AL, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x9A9A9A9AL, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_5)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x140E0828L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x0E082848L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x28282828L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x48484848L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x05254565L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x25456585L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x65656565L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x85858585L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_7)\n\t\t\t{\n\t\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x12325272L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x32527292L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x72727272L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x92929292L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t\t{\n\t\t\t\t\tif (_smartPower)\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x315191B1L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0x5171B1D1L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n#if DWM1000_OPTIMIZED\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0xB1B1B1B1L, LEN_TX_POWER);\n#else\n\t\t\t\t\t\tDW1000NgUtils::writeValueToBytes(txpower, 0xD1D1D1D1L, LEN_TX_POWER);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// TODO proper error/warning handling\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(TX_POWER, NO_SUB, txpower, LEN_TX_POWER);\n\t\t}\n\n\t\t/* RF_RXCTRLH - reg:0x28, sub-reg:0x0B, table 37 */\n\t\tvoid _rfrxctrlh()\n\t\t{\n\t\t\tbyte rfrxctrlh[LEN_RF_RXCTRLH];\n\t\t\tif (_channel != Channel::CHANNEL_4 && _channel != Channel::CHANNEL_7)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(rfrxctrlh, 0xD8, LEN_RF_RXCTRLH);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(rfrxctrlh, 0xBC, LEN_RF_RXCTRLH);\n\t\t\t}\n\t\t\t_writeBytesToRegister(RF_CONF, RF_RXCTRLH_SUB, rfrxctrlh, LEN_RF_RXCTRLH);\n\t\t}\n\n\t\t/* RX_TXCTRL - reg:0x28, sub-reg:0x0C */\n\t\tvoid _rftxctrl()\n\t\t{\n\t\t\tbyte rftxctrl[LEN_RF_TXCTRL];\n\t\t\tif (_channel == Channel::CHANNEL_1)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(rftxctrl, 0x00005C40L, LEN_RF_TXCTRL);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_2)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(rftxctrl, 0x00045CA0L, LEN_RF_TXCTRL);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_3)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(rftxctrl, 0x00086CC0L, LEN_RF_TXCTRL);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_4)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(rftxctrl, 0x00045C80L, LEN_RF_TXCTRL);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_5)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(rftxctrl, 0x001E3FE0L, LEN_RF_TXCTRL);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_7)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(rftxctrl, 0x001E7DE0L, LEN_RF_TXCTRL);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(RF_CONF, RF_TXCTRL_SUB, rftxctrl, LEN_RF_TXCTRL);\n\t\t}\n\n\t\t/* TC_PGDELAY - reg:0x2A, sub-reg:0x0B, table 40 */\n\t\tvoid _tcpgdelaytune()\n\t\t{\n\t\t\tbyte tcpgdelay[LEN_TC_PGDELAY];\n\t\t\tif (_channel == Channel::CHANNEL_1)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(tcpgdelay, 0xC9, LEN_TC_PGDELAY);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_2)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(tcpgdelay, 0xC2, LEN_TC_PGDELAY);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_3)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(tcpgdelay, 0xC5, LEN_TC_PGDELAY);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_4)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(tcpgdelay, 0x95, LEN_TC_PGDELAY);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_5)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(tcpgdelay, 0xC0, LEN_TC_PGDELAY);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_7)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(tcpgdelay, 0x93, LEN_TC_PGDELAY);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(TX_CAL, TC_PGDELAY_SUB, tcpgdelay, LEN_TC_PGDELAY);\n\t\t}\n\n\t\t// FS_PLLCFG and FS_PLLTUNE - reg:0x2B, sub-reg:0x07-0x0B, tables 43-44\n\t\tvoid _fspll()\n\t\t{\n\t\t\tbyte fspllcfg[LEN_FS_PLLCFG];\n\t\t\tbyte fsplltune[LEN_FS_PLLTUNE];\n\t\t\tif (_channel == Channel::CHANNEL_1)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fspllcfg, 0x09000407L, LEN_FS_PLLCFG);\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fsplltune, 0x1E, LEN_FS_PLLTUNE);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_2 || _channel == Channel::CHANNEL_4)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fspllcfg, 0x08400508L, LEN_FS_PLLCFG);\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fsplltune, 0x26, LEN_FS_PLLTUNE);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_3)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fspllcfg, 0x08401009L, LEN_FS_PLLCFG);\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fsplltune, 0x56, LEN_FS_PLLTUNE);\n\t\t\t}\n\t\t\telse if (_channel == Channel::CHANNEL_5 || _channel == Channel::CHANNEL_7)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fspllcfg, 0x0800041DL, LEN_FS_PLLCFG);\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fsplltune, 0xBE, LEN_FS_PLLTUNE);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO proper error/warning handling\n\t\t\t}\n\t\t\t_writeBytesToRegister(FS_CTRL, FS_PLLTUNE_SUB, fsplltune, LEN_FS_PLLTUNE);\n\t\t\t_writeBytesToRegister(FS_CTRL, FS_PLLCFG_SUB, fspllcfg, LEN_FS_PLLCFG);\n\t\t}\n\n\t\tvoid _tune()\n\t\t{\n\t\t\t// these registers are going to be tuned/configured\n\t\t\t_agctune1();\n\t\t\t_agctune2();\n\t\t\t_agctune3();\n\t\t\t_drxtune0b();\n\t\t\t_drxtune1a();\n\t\t\t_drxtune1b();\n\t\t\t_drxtune2();\n\t\t\t_drxtune4H();\n\t\t\t_ldecfg1();\n\t\t\t_ldecfg2();\n\t\t\t_lderepc();\n\t\t\tif (_autoTXPower)\n\t\t\t\t_txpowertune();\n\t\t\t_rfrxctrlh();\n\t\t\t_rftxctrl();\n\t\t\tif (_autoTCPGDelay)\n\t\t\t\t_tcpgdelaytune();\n\t\t\t_fspll();\n\t\t}\n\n\t\tvoid _writeNetworkIdAndDeviceAddress()\n\t\t{\n\t\t\t_writeBytesToRegister(PANADR, NO_SUB, _networkAndAddress, LEN_PANADR);\n\t\t}\n\n\t\tvoid _writeSystemConfigurationRegister()\n\t\t{\n\t\t\t_writeBytesToRegister(SYS_CFG, NO_SUB, _syscfg, LEN_SYS_CFG);\n\t\t}\n\n\t\tvoid _writeChannelControlRegister()\n\t\t{\n\t\t\t_writeBytesToRegister(CHAN_CTRL, NO_SUB, _chanctrl, LEN_CHAN_CTRL);\n\t\t}\n\n\t\tvoid _writeTransmitFrameControlRegister()\n\t\t{\n\t\t\t_writeBytesToRegister(TX_FCTRL, NO_SUB, _txfctrl, LEN_TX_FCTRL);\n\t\t}\n\n\t\tvoid _writeSystemEventMaskRegister()\n\t\t{\n\t\t\t_writeBytesToRegister(SYS_MASK, NO_SUB, _sysmask, LEN_SYS_MASK);\n\t\t}\n\n\t\tvoid _writeAntennaDelayRegisters()\n\t\t{\n\t\t\tbyte antennaTxDelayBytes[2];\n\t\t\tbyte antennaRxDelayBytes[2];\n\t\t\tDW1000NgUtils::writeValueToBytes(antennaTxDelayBytes, _antennaTxDelay, LEN_TX_ANTD);\n\t\t\tDW1000NgUtils::writeValueToBytes(antennaRxDelayBytes, _antennaRxDelay, LEN_LDE_RXANTD);\n\t\t\t_writeBytesToRegister(TX_ANTD, NO_SUB, antennaTxDelayBytes, LEN_TX_ANTD);\n\t\t\t_writeBytesToRegister(LDE_IF, LDE_RXANTD_SUB, antennaRxDelayBytes, LEN_LDE_RXANTD);\n\t\t}\n\n\t\tvoid _writeConfiguration()\n\t\t{\n\t\t\t// write all configurations back to device\n\t\t\t_writeSystemConfigurationRegister();\n\t\t\t_writeChannelControlRegister();\n\t\t\t_writeTransmitFrameControlRegister();\n\t\t}\n\n\t\tvoid _useExtendedFrameLength(boolean val)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, PHR_MODE_0_BIT, val);\n\t\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, PHR_MODE_1_BIT, val);\n\t\t}\n\n\t\tvoid _setReceiverAutoReenable(boolean val)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, RXAUTR_BIT, val);\n\t\t}\n\n\t\tvoid _useFrameCheck(boolean val)\n\t\t{\n\t\t\t_frameCheck = val;\n\t\t}\n\n\t\tvoid _setNlosOptimization(boolean val)\n\t\t{\n\t\t\t_nlos = val;\n\t\t\tif (_nlos)\n\t\t\t{\n\t\t\t\t_ldecfg1();\n\t\t\t\t_ldecfg2();\n\t\t\t}\n\t\t}\n\n\t\tvoid _useSmartPower(boolean smartPower)\n\t\t{\n\t\t\t_smartPower = smartPower;\n\t\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, DIS_STXP_BIT, !smartPower);\n\t\t\t_writeSystemConfigurationRegister();\n\t\t\tif (_autoTXPower)\n\t\t\t\t_txpowertune();\n\t\t}\n\n\t\tvoid _setSFDMode(SFDMode mode)\n\t\t{\n\t\t\tswitch (mode)\n\t\t\t{\n\t\t\tcase SFDMode::STANDARD_SFD:\n\t\t\t\tDW1000NgUtils::setBit(_chanctrl, LEN_CHAN_CTRL, DWSFD_BIT, false);\n\t\t\t\tDW1000NgUtils::setBit(_chanctrl, LEN_CHAN_CTRL, TNSSFD_BIT, false);\n\t\t\t\tDW1000NgUtils::setBit(_chanctrl, LEN_CHAN_CTRL, RNSSFD_BIT, false);\n\t\t\t\t_standardSFD = true;\n\t\t\t\tbreak;\n\t\t\tcase SFDMode::DECAWAVE_SFD:\n\t\t\t\tDW1000NgUtils::setBit(_chanctrl, LEN_CHAN_CTRL, DWSFD_BIT, true);\n\t\t\t\tDW1000NgUtils::setBit(_chanctrl, LEN_CHAN_CTRL, TNSSFD_BIT, true);\n\t\t\t\tDW1000NgUtils::setBit(_chanctrl, LEN_CHAN_CTRL, RNSSFD_BIT, true);\n\t\t\t\t_standardSFD = false;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn; // TODO Proper error handling\n\t\t\t}\n\t\t}\n\n\t\tvoid _setChannel(Channel channel)\n\t\t{\n\t\t\tbyte chan = static_cast<byte>(channel);\n\t\t\tchan &= 0xF;\n\t\t\t_chanctrl[0] = ((chan | (chan << 4)) & 0xFF);\n\n\t\t\t_channel = channel;\n\t\t}\n\n\t\tvoid _setDataRate(DataRate data_rate)\n\t\t{\n\t\t\tbyte rate = static_cast<byte>(data_rate);\n\t\t\trate &= 0x03;\n\t\t\t_txfctrl[1] &= 0x83;\n\t\t\t_txfctrl[1] |= (byte)((rate << 5) & 0xFF);\n\t\t\t// special 110kbps flag\n\t\t\tif (data_rate == DataRate::RATE_110KBPS)\n\t\t\t{\n\t\t\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, RXM110K_BIT, true);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, RXM110K_BIT, false);\n\t\t\t}\n\t\t\t_dataRate = data_rate;\n\t\t}\n\n\t\tvoid _setPulseFrequency(PulseFrequency frequency)\n\t\t{\n\t\t\tbyte freq = static_cast<byte>(frequency);\n\t\t\tfreq &= 0x03;\n\t\t\t_txfctrl[2] &= 0xFC;\n\t\t\t_txfctrl[2] |= (byte)(freq & 0xFF);\n\t\t\t_chanctrl[2] &= 0xF3;\n\t\t\t_chanctrl[2] |= (byte)((freq << 2) & 0xFF);\n\n\t\t\t_pulseFrequency = frequency;\n\t\t}\n\n\t\tvoid _setPreambleLength(PreambleLength preamble_length)\n\t\t{\n\t\t\tbyte prealen = static_cast<byte>(preamble_length);\n\t\t\tprealen &= 0x0F;\n\t\t\t_txfctrl[2] &= 0xC3;\n\t\t\t_txfctrl[2] |= (byte)((prealen << 2) & 0xFF);\n\n\t\t\tswitch (preamble_length)\n\t\t\t{\n\t\t\tcase PreambleLength::LEN_64:\n\t\t\t\t_pacSize = PacSize::SIZE_8;\n\t\t\t\tbreak;\n\t\t\tcase PreambleLength::LEN_128:\n\t\t\t\t_pacSize = PacSize::SIZE_8;\n\t\t\t\tbreak;\n\t\t\tcase PreambleLength::LEN_256:\n\t\t\t\t_pacSize = PacSize::SIZE_16;\n\t\t\t\tbreak;\n\t\t\tcase PreambleLength::LEN_512:\n\t\t\t\t_pacSize = PacSize::SIZE_16;\n\t\t\t\tbreak;\n\t\t\tcase PreambleLength::LEN_1024:\n\t\t\t\t_pacSize = PacSize::SIZE_32;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t_pacSize = PacSize::SIZE_64; // In case of 1536, 2048 or 4096 preamble length.\n\t\t\t}\n\n\t\t\t_preambleLength = preamble_length;\n\t\t}\n\n\t\tvoid _setPreambleCode(PreambleCode preamble_code)\n\t\t{\n\t\t\tbyte preacode = static_cast<byte>(preamble_code);\n\t\t\tpreacode &= 0x1F;\n\t\t\t_chanctrl[2] &= 0x3F;\n\t\t\t_chanctrl[2] |= ((preacode << 6) & 0xFF);\n\t\t\t_chanctrl[3] = 0x00;\n\t\t\t_chanctrl[3] = ((((preacode >> 2) & 0x07) | (preacode << 3)) & 0xFF);\n\n\t\t\t_preambleCode = preamble_code;\n\t\t}\n\n\t\tboolean _checkPreambleCodeValidity()\n\t\t{\n\t\t\tbyte preacode = static_cast<byte>(_preambleCode);\n\t\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t\t{\n\t\t\t\tfor (auto i = 0; i < 2; i++)\n\t\t\t\t{\n\t\t\t\t\tif (preacode == preamble_validity_matrix_PRF16[(int)_channel][i])\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if (_pulseFrequency == PulseFrequency::FREQ_64MHZ)\n\t\t\t{\n\t\t\t\tfor (auto i = 0; i < 4; i++)\n\t\t\t\t{\n\t\t\t\t\tif (preacode == preamble_validity_matrix_PRF64[(int)_channel][i])\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn false; // TODO Proper error handling\n\t\t\t}\n\t\t}\n\n\t\tvoid _setValidPreambleCode()\n\t\t{\n\t\t\tPreambleCode preamble_code;\n\n\t\t\tswitch (_channel)\n\t\t\t{\n\t\t\tcase Channel::CHANNEL_1:\n\t\t\t\tpreamble_code = _pulseFrequency == PulseFrequency::FREQ_16MHZ ? PreambleCode::CODE_2 : PreambleCode::CODE_10;\n\t\t\t\tbreak;\n\t\t\tcase Channel::CHANNEL_3:\n\t\t\t\tpreamble_code = _pulseFrequency == PulseFrequency::FREQ_16MHZ ? PreambleCode::CODE_6 : PreambleCode::CODE_10;\n\t\t\t\tbreak;\n\t\t\tcase Channel::CHANNEL_4:\n\t\t\tcase Channel::CHANNEL_7:\n\t\t\t\tpreamble_code = _pulseFrequency == PulseFrequency::FREQ_16MHZ ? PreambleCode::CODE_8 : PreambleCode::CODE_18;\n\t\t\t\tbreak;\n\t\t\tcase Channel::CHANNEL_2:\n\t\t\tcase Channel::CHANNEL_5:\n\t\t\t\tpreamble_code = _pulseFrequency == PulseFrequency::FREQ_16MHZ ? PreambleCode::CODE_3 : PreambleCode::CODE_10;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn; // TODO Proper Error Handling\n\t\t\t}\n\t\t\tbyte preacode = static_cast<byte>(preamble_code);\n\t\t\tpreacode &= 0x1F;\n\t\t\t_chanctrl[2] &= 0x3F;\n\t\t\t_chanctrl[2] |= ((preacode << 6) & 0xFF);\n\t\t\t_chanctrl[3] = 0x00;\n\t\t\t_chanctrl[3] = ((((preacode >> 2) & 0x07) | (preacode << 3)) & 0xFF);\n\n\t\t\t_preambleCode = preamble_code;\n\t\t}\n\n\t\tvoid _setNonStandardSFDLength()\n\t\t{\n\t\t\tswitch (_dataRate)\n\t\t\t{\n\t\t\tcase DataRate::RATE_6800KBPS:\n\t\t\t\t_writeByte(USR_SFD, SFD_LENGTH_SUB, 0x08);\n\t\t\t\tbreak;\n\t\t\tcase DataRate::RATE_850KBPS:\n\t\t\t\t_writeByte(USR_SFD, SFD_LENGTH_SUB, 0x10);\n\t\t\t\tbreak;\n\t\t\tcase DataRate::RATE_110KBPS:\n\t\t\t\t_writeByte(USR_SFD, SFD_LENGTH_SUB, 0x40);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn; // TODO Proper error handling\n\t\t\t}\n\t\t}\n\n\t\tvoid _interruptOnSent(boolean val)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_MASK, TXFRS_BIT, val);\n\t\t}\n\n\t\tvoid _interruptOnReceived(boolean val)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_MASK, RXDFR_BIT, val);\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_MASK, RXFCG_BIT, val);\n\t\t}\n\n\t\tvoid _interruptOnReceiveFailed(boolean val)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_STATUS, RXPHE_BIT, val);\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_STATUS, RXFCE_BIT, val);\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_STATUS, RXRFSL_BIT, val);\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_STATUS, LDEERR_BIT, val);\n\t\t}\n\n\t\tvoid _interruptOnReceiveTimeout(boolean val)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_MASK, RXRFTO_BIT, val);\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_MASK, RXPTO_BIT, val);\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_MASK, RXSFDTO_BIT, val);\n\t\t}\n\n\t\tvoid _interruptOnReceiveTimestampAvailable(boolean val)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_MASK, LDEDONE_BIT, val);\n\t\t}\n\n\t\tvoid _interruptOnAutomaticAcknowledgeTrigger(boolean val)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysmask, LEN_SYS_MASK, AAT_BIT, val);\n\t\t}\n\n\t\tvoid _manageLDE()\n\t\t{\n\t\t\t// transfer any ldo tune values\n\t\t\tbyte ldoTune[LEN_OTP_RDAT];\n\t\t\tuint16_t LDOTUNE_ADDRESS = 0x04;\n\t\t\t_readBytesOTP(LDOTUNE_ADDRESS, ldoTune); // TODO #define\n\t\t\tif (ldoTune[0] != 0)\n\t\t\t{\n\t\t\t\t// TODO tuning available, copy over to RAM: use OTP_LDO bit\n\t\t\t}\n\t\t\t// tell the chip to load the LDE microcode\n\t\t\t// TODO remove clock-related code (PMSC_CTRL) as handled separately\n\t\t\tbyte pmscctrl0[LEN_PMSC_CTRL0];\n\t\t\tbyte otpctrl[LEN_OTP_CTRL];\n\t\t\tmemset(pmscctrl0, 0, LEN_PMSC_CTRL0);\n\t\t\tmemset(otpctrl, 0, LEN_OTP_CTRL);\n\t\t\t_readBytes(PMSC, PMSC_CTRL0_SUB, pmscctrl0, LEN_PMSC_CTRL0);\n\t\t\t_readBytes(OTP_IF, OTP_CTRL_SUB, otpctrl, LEN_OTP_CTRL);\n\t\t\tpmscctrl0[0] = 0x01;\n\t\t\tpmscctrl0[1] = 0x03;\n\t\t\totpctrl[1] = 0x80;\n\t\t\t_writeBytesToRegister(PMSC, PMSC_CTRL0_SUB, pmscctrl0, 2);\n\t\t\t// uCode\n\t\t\t_enableClock(LDE_CLOCK);\n\t\t\tdelay(5);\n\t\t\t_writeBytesToRegister(OTP_IF, OTP_CTRL_SUB, otpctrl, 2);\n\t\t\tdelay(1);\n\t\t\t_enableClock(SYS_AUTO_CLOCK);\n\t\t\tdelay(5);\n\t\t\tpmscctrl0[0] = 0x00;\n\t\t\tpmscctrl0[1] &= 0x02;\n\t\t\t_writeBytesToRegister(PMSC, PMSC_CTRL0_SUB, pmscctrl0, 2);\n\t\t}\n\n\t\t/* Crystal calibration from OTP (if available)\n\t\t * FS_XTALT - reg:0x2B, sub-reg:0x0E\n\t\t * OTP(one-time-programmable) memory map - table 10 */\n\t\tvoid _fsxtalt()\n\t\t{\n\t\t\tbyte fsxtalt[LEN_FS_XTALT];\n\t\t\tbyte buf_otp[4];\n\t\t\t_readBytesOTP(0x01E, buf_otp); // 0x01E -> byte[0]=XTAL_Trim\n\t\t\tif (buf_otp[0] == 0)\n\t\t\t{\n\t\t\t\t// No trim value available from OTP, use midrange value of 0x10\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fsxtalt, ((0x10 & 0x1F) | 0x60), LEN_FS_XTALT);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tDW1000NgUtils::writeValueToBytes(fsxtalt, ((buf_otp[0] & 0x1F) | 0x60), LEN_FS_XTALT);\n\t\t\t}\n\t\t\t// write configuration back to chip\n\t\t\t_writeBytesToRegister(FS_CTRL, FS_XTALT_SUB, fsxtalt, LEN_FS_XTALT);\n\t\t}\n\n\t\tvoid _clearReceiveStatus()\n\t\t{\n\t\t\t// clear latched RX bits (i.e. write 1 to clear)\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXDFR_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXFCG_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXPRD_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXSFDD_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXPHD_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, LDEDONE_BIT, true);\n\t\t\t_writeBytesToRegister(SYS_STATUS, NO_SUB, _sysstatus, LEN_SYS_STATUS);\n\t\t}\n\n\t\tvoid _clearReceiveTimestampAvailableStatus()\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, LDEDONE_BIT, true);\n\t\t\t_writeBytesToRegister(SYS_STATUS, NO_SUB, _sysstatus, LEN_SYS_STATUS);\n\t\t}\n\n\t\tvoid _clearReceiveTimeoutStatus()\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXRFTO_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXPTO_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXSFDTO_BIT, true);\n\t\t\t_writeBytesToRegister(SYS_STATUS, NO_SUB, _sysstatus, LEN_SYS_STATUS);\n\t\t}\n\n\t\tvoid _clearReceiveFailedStatus()\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXPHE_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXFCE_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, RXRFSL_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, AFFREJ_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, LDEERR_BIT, true);\n\t\t\t_writeBytesToRegister(SYS_STATUS, NO_SUB, _sysstatus, LEN_SYS_STATUS);\n\t\t}\n\n\t\tvoid _clearTransmitStatus()\n\t\t{\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, AAT_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, TXFRB_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, TXPRS_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, TXPHS_BIT, true);\n\t\t\tDW1000NgUtils::setBit(_sysstatus, LEN_SYS_STATUS, TXFRS_BIT, true);\n\t\t\t_writeBytesToRegister(SYS_STATUS, NO_SUB, _sysstatus, LEN_SYS_STATUS);\n\t\t}\n\n\t\tvoid _resetReceiver()\n\t\t{\n\t\t\t/* Set to 0 only bit 28 */\n\t\t\t_writeToRegister(PMSC, PMSC_SOFTRESET_SUB, 0xE0, LEN_PMSC_SOFTRESET);\n\t\t\t/* Set SOFTRESET to all ones */\n\t\t\t_writeToRegister(PMSC, PMSC_SOFTRESET_SUB, 0xF0, LEN_PMSC_SOFTRESET);\n\t\t}\n\n\t\t/* Internal helpers to read configuration */\n\n\t\tvoid _readSystemConfigurationRegister()\n\t\t{\n\t\t\t_readBytes(SYS_CFG, NO_SUB, _syscfg, LEN_SYS_CFG);\n\t\t}\n\n\t\tvoid _readSystemEventStatusRegister()\n\t\t{\n\t\t\t_readBytes(SYS_STATUS, NO_SUB, _sysstatus, LEN_SYS_STATUS);\n\t\t}\n\n\t\tvoid _readNetworkIdAndDeviceAddress()\n\t\t{\n\t\t\t_readBytes(PANADR, NO_SUB, _networkAndAddress, LEN_PANADR);\n\t\t}\n\n\t\tvoid _readSystemEventMaskRegister()\n\t\t{\n\t\t\t_readBytes(SYS_MASK, NO_SUB, _sysmask, LEN_SYS_MASK);\n\t\t}\n\n\t\tvoid _readChannelControlRegister()\n\t\t{\n\t\t\t_readBytes(CHAN_CTRL, NO_SUB, _chanctrl, LEN_CHAN_CTRL);\n\t\t}\n\n\t\tvoid _readTransmitFrameControlRegister()\n\t\t{\n\t\t\t_readBytes(TX_FCTRL, NO_SUB, _txfctrl, LEN_TX_FCTRL);\n\t\t}\n\n\t\tboolean _isTransmitDone()\n\t\t{\n\t\t\treturn DW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, TXFRS_BIT);\n\t\t}\n\n\t\tboolean _isReceiveTimestampAvailable()\n\t\t{\n\t\t\treturn DW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, LDEDONE_BIT);\n\t\t}\n\n\t\tboolean _isReceiveDone()\n\t\t{\n\t\t\tif (_frameCheck)\n\t\t\t{\n\t\t\t\treturn (DW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXFCG_BIT) &&\n\t\t\t\t\t\tDW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXDFR_BIT));\n\t\t\t}\n\t\t\treturn DW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXDFR_BIT);\n\t\t}\n\n\t\tboolean _isReceiveFailed()\n\t\t{\n\t\t\treturn (DW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXPHE_BIT) ||\n\t\t\t\t\tDW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXFCE_BIT) ||\n\t\t\t\t\tDW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXRFSL_BIT) ||\n\t\t\t\t\tDW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, LDEERR_BIT));\n\t\t}\n\n\t\tboolean _isReceiveTimeout()\n\t\t{\n\t\t\treturn (DW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXRFTO_BIT) ||\n\t\t\t\t\tDW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXPTO_BIT) ||\n\t\t\t\t\tDW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RXSFDTO_BIT));\n\t\t}\n\n\t\tboolean _isClockProblem()\n\t\t{\n\t\t\treturn (DW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, CLKPLL_LL_BIT) ||\n\t\t\t\t\tDW1000NgUtils::getBit(_sysstatus, LEN_SYS_STATUS, RFPLL_LL_BIT));\n\t\t}\n\n\t\tvoid _disableSequencing()\n\t\t{\n\t\t\t_enableClock(SYS_XTI_CLOCK);\n\t\t\tbyte zero[2];\n\t\t\tDW1000NgUtils::writeValueToBytes(zero, 0x0000, 2);\n\t\t\t_writeBytesToRegister(PMSC, PMSC_CTRL1_SUB, zero, 2); // To re-enable write 0xE7\n\t\t}\n\n\t\tvoid _configureRFTransmitPowerSpectrumTestMode()\n\t\t{\n\t\t\t/* Enabled TXFEN, PLLFEN, LDOFEN and set TXRXSW to TX */\n\t\t\tbyte enable_mask[4];\n\t\t\tDW1000NgUtils::writeValueToBytes(enable_mask, 0x005FFF00, LEN_RX_CONF_SUB);\n\t\t\t_writeBytesToRegister(RF_CONF, RF_CONF_SUB, enable_mask, LEN_RX_CONF_SUB);\n\t\t}\n\n\t\tvoid _uploadConfigToAON()\n\t\t{\n\t\t\t/* Write 1 in UPL_CFG_BIT */\n\t\t\t_writeToRegister(AON, AON_CTRL_SUB, 0x04, LEN_AON_CTRL);\n\t\t\t/* Clear the register */\n\t\t\t_writeToRegister(AON, AON_CTRL_SUB, 0x00, LEN_AON_CTRL);\n\t\t}\n\t}\n\n\t/* ####################### PUBLIC ###################### */\n\n\tvoid initialize(uint8_t ss, uint8_t irq, uint8_t rst)\n\t{\n\t\t// generous initial init/wake-up-idle delay\n\t\tdelay(5);\n\t\t_ss = ss;\n\t\t_irq = irq;\n\t\t_rst = rst;\n\n\t\tif (rst != 0xff)\n\t\t{\n\t\t\t// DW1000 data sheet v2.08 Â§5.6.1 page 20, the RSTn pin should not be driven high but left floating.\n\t\t\tpinMode(_rst, INPUT);\n\t\t}\n\n\t\tSPIporting::SPIinit();\n\t\t// pin and basic member setup\n\t\t// attach interrupt\n\t\t// TODO throw error if pin is not a interrupt pin\n\t\tif (_irq != 0xff)\n\t\t{\n\t\t\tattachInterrupt(digitalPinToInterrupt(_irq), interruptServiceRoutine, RISING);\n\t\t\t// attachInterrupt(digitalPinToInterrupt(_irq), interruptServiceRoutine, FALLING);\n\t\t}\n\n\t\tSPIporting::SPIselect(_ss, _irq);\n\t\t// reset chip (either soft or hard)\n\t\treset();\n\n\t\tSPIporting::setSPIspeed(SPIClock::SLOW);\n\t\t_enableClock(SYS_XTI_CLOCK);\n\t\tdelay(5);\n\n\t\t// Configure the CPLL lock detect\n\t\t_writeBitToRegister(EXT_SYNC, EC_CTRL_SUB, LEN_EC_CTRL, PLLLDT_BIT, true);\n\n\t\t// Configure XTAL trim\n\t\t_fsxtalt();\n\n\t\t// load LDE micro-code\n\t\t_manageLDE();\n\n\t\t// read the temp and vbat readings from OTP that were recorded during production test\n\t\t// see 6.3.1 OTP memory map\n\t\tbyte buf_otp[4];\n\t\t_readBytesOTP(0x008, buf_otp); // the stored 3.3 V reading\n\t\t_vmeas3v3 = buf_otp[0];\n\t\t// Serial.printf(\"_vmeas3v3=%d\\r\\n\", _vmeas3v3);\n\t\t_readBytesOTP(0x009, buf_otp); // the stored 23C reading\n\t\t_tmeas23C = buf_otp[0];\n\t\t// Serial.printf(\"_tmeas23C=%d\\r\\n\", _tmeas23C);\n\n\t\t_enableClock(SYS_AUTO_CLOCK);\n\t\tdelay(5);\n\t\tSPIporting::setSPIspeed(SPIClock::FAST);\n\n\t\t_readNetworkIdAndDeviceAddress();\n\t\t_readSystemConfigurationRegister();\n\t\t_readChannelControlRegister();\n\t\t_readTransmitFrameControlRegister();\n\t\t_readSystemEventMaskRegister();\n\n\t\t/* Cleared AON:CFG1(0x2C:0x0A) for proper operation of deepSleep */\n\t\t_writeToRegister(AON, AON_CFG1_SUB, 0x00, LEN_AON_CFG1);\n\t}\n\n\tvoid initializeNoInterrupt(uint8_t ss, uint8_t rst)\n\t{\n\t\tinitialize(ss, 0xff, rst);\n\t}\n\n\t/* callback handler management. */\n\tvoid attachErrorHandler(void (*handleError)(void))\n\t{\n\t\t_handleError = handleError;\n\t}\n\n\tvoid attachSentHandler(void (*handleSent)(void))\n\t{\n\t\t_handleSent = handleSent;\n\t}\n\n\tvoid attachReceivedHandler(void (*handleReceived)(void))\n\t{\n\t\t_handleReceived = handleReceived;\n\t}\n\n\tvoid attachReceiveFailedHandler(void (*handleReceiveFailed)(void))\n\t{\n\t\t_handleReceiveFailed = handleReceiveFailed;\n\t}\n\n\tvoid attachReceiveTimeoutHandler(void (*handleReceiveTimeout)(void))\n\t{\n\t\t_handleReceiveTimeout = handleReceiveTimeout;\n\t}\n\n\tvoid attachReceiveTimestampAvailableHandler(void (*handleReceiveTimestampAvailable)(void))\n\t{\n\t\t_handleReceiveTimestampAvailable = handleReceiveTimestampAvailable;\n\t}\n\n\tvoid interruptServiceRoutine()\n\t{\n\t\t// Serial.printf(\"test----------------------------0\\r\\n\");\n\t\t// read current status and handle via callbacks\n\t\t_readSystemEventStatusRegister();\n\t\tif (_isClockProblem() /* TODO and others */ && _handleError != 0)\n\t\t{\n\t\t\t(*_handleError)();\n\t\t\t// Serial.printf(\"interrupt----------------------------1\\r\\n\");\n\t\t}\n\t\tif (_isTransmitDone())\n\t\t{\n\t\t\t_clearTransmitStatus();\n\t\t\tif (_handleSent != nullptr)\n\t\t\t{\n\t\t\t\t(*_handleSent)();\n\t\t\t\t// Serial.printf(\"interrupt----------------------------2\\r\\n\");\n\t\t\t}\n\t\t}\n\t\tif (_isReceiveTimestampAvailable())\n\t\t{\n\t\t\t_clearReceiveTimestampAvailableStatus();\n\t\t\tif (_handleReceiveTimestampAvailable != nullptr)\n\t\t\t{\n\t\t\t\t(*_handleReceiveTimestampAvailable)();\n\t\t\t\t// Serial.printf(\"interrupt----------------------------3\\r\\n\");\n\t\t\t}\n\t\t}\n\t\tif (_isReceiveFailed())\n\t\t{\n\t\t\t_clearReceiveFailedStatus();\n\t\t\tforceTRxOff();\n\t\t\t_resetReceiver();\n\t\t\tif (_handleReceiveFailed != nullptr)\n\t\t\t{\n\t\t\t\t(*_handleReceiveFailed)();\n\t\t\t\t// Serial.printf(\"interrupt----------------------------4\\r\\n\");\n\t\t\t}\n\t\t}\n\t\telse if (_isReceiveTimeout())\n\t\t{\n\t\t\t_clearReceiveTimeoutStatus();\n\t\t\tforceTRxOff();\n\t\t\t_resetReceiver();\n\t\t\tif (_handleReceiveTimeout != nullptr)\n\t\t\t{\n\t\t\t\t(*_handleReceiveTimeout)();\n\t\t\t\t// Serial.printf(\"interrupt----------------------------5\\r\\n\");\n\t\t\t}\n\t\t}\n\t\telse if (_isReceiveDone())\n\t\t{\n\t\t\t_clearReceiveStatus();\n\t\t\tif (_handleReceived != nullptr)\n\t\t\t{\n\t\t\t\t(*_handleReceived)();\n\t\t\t\t// Serial.printf(\"interrupt----------------------------6\\r\\n\");\n\t\t\t}\n\t\t}\n\t\t// Latched bits in status register are reset by writing 1 to them\n\t\tmemset(_sysstatus, 0xff, LEN_SYS_STATUS);\n\t\t_writeBytesToRegister(SYS_STATUS, NO_SUB, _sysstatus, LEN_SYS_STATUS);\n\t}\n\n\tboolean isTransmitDone()\n\t{\n\t\t_readSystemEventStatusRegister();\n\t\treturn _isTransmitDone();\n\t}\n\n\tvoid clearTransmitStatus()\n\t{\n\t\t_clearTransmitStatus();\n\t}\n\n\tboolean isReceiveDone()\n\t{\n\t\t_readSystemEventStatusRegister();\n\t\treturn _isReceiveDone();\n\t}\n\n\tvoid clearReceiveStatus()\n\t{\n\t\t_clearReceiveStatus();\n\t}\n\n\tboolean isReceiveFailed()\n\t{\n\t\t_readSystemEventStatusRegister();\n\t\treturn _isReceiveFailed();\n\t}\n\n\tvoid clearReceiveFailedStatus()\n\t{\n\t\t_clearReceiveFailedStatus();\n\t\tforceTRxOff();\n\t\t_resetReceiver();\n\t}\n\n\tboolean isReceiveTimeout()\n\t{\n\t\t_readSystemEventMaskRegister();\n\t\treturn _isReceiveTimeout();\n\t}\n\n\tvoid clearReceiveTimeoutStatus()\n\t{\n\t\t_clearReceiveTimeoutStatus();\n\t\tforceTRxOff();\n\t\t_resetReceiver();\n\t}\n\n\tvoid enableDebounceClock()\n\t{\n\t\tbyte pmscctrl0[LEN_PMSC_CTRL0];\n\t\tmemset(pmscctrl0, 0, LEN_PMSC_CTRL0);\n\t\t_readBytes(PMSC, PMSC_CTRL0_SUB, pmscctrl0, LEN_PMSC_CTRL0);\n\t\tDW1000NgUtils::setBit(pmscctrl0, LEN_PMSC_CTRL0, GPDCE_BIT, 1);\n\t\tDW1000NgUtils::setBit(pmscctrl0, LEN_PMSC_CTRL0, KHZCLKEN_BIT, 1);\n\t\t_writeBytesToRegister(PMSC, PMSC_CTRL0_SUB, pmscctrl0, LEN_PMSC_CTRL0);\n\t\t_debounceClockEnabled = true;\n\t}\n\n\tvoid enableLedBlinking()\n\t{\n\t\tbyte pmscledc[LEN_PMSC_LEDC];\n\t\tmemset(pmscledc, 0, LEN_PMSC_LEDC);\n\t\t_readBytes(PMSC, PMSC_LEDC_SUB, pmscledc, LEN_PMSC_LEDC);\n\t\tDW1000NgUtils::setBit(pmscledc, LEN_PMSC_LEDC, BLNKEN, 1);\n\t\t_writeBytesToRegister(PMSC, PMSC_LEDC_SUB, pmscledc, LEN_PMSC_LEDC);\n\t}\n\n\tvoid setGPIOMode(uint8_t msgp, uint8_t mode)\n\t{\n\t\tbyte gpiomode[LEN_GPIO_MODE];\n\t\tmemset(gpiomode, 0, LEN_GPIO_MODE);\n\t\t_readBytes(GPIO_CTRL, GPIO_MODE_SUB, gpiomode, LEN_GPIO_MODE);\n\t\tfor (char i = 0; i < 2; i++)\n\t\t{\n\t\t\tDW1000NgUtils::setBit(gpiomode, LEN_GPIO_MODE, msgp + i, (mode >> i) & 1);\n\t\t}\n\t\t_writeBytesToRegister(GPIO_CTRL, GPIO_MODE_SUB, gpiomode, LEN_GPIO_MODE);\n\t}\n\n\tvoid applySleepConfiguration(sleep_configuration_t sleep_config)\n\t{\n\t\tbyte aon_wcfg[LEN_AON_WCFG];\n\t\t_readBytes(AON, AON_WCFG_SUB, aon_wcfg, LEN_AON_WCFG);\n\t\tbyte aon_cfg0[1];\n\t\tmemset(aon_cfg0, 0, 1);\n\n\t\tDW1000NgUtils::setBit(aon_wcfg, LEN_AON_WCFG, ONW_RADC_BIT, sleep_config.onWakeUpRunADC);\n\t\tDW1000NgUtils::setBit(aon_wcfg, LEN_AON_WCFG, ONW_RX_BIT, sleep_config.onWakeUpReceive);\n\t\tDW1000NgUtils::setBit(aon_wcfg, LEN_AON_WCFG, ONW_LEUI_BIT, sleep_config.onWakeUpLoadEUI);\n\t\tDW1000NgUtils::setBit(aon_wcfg, LEN_AON_WCFG, ONW_LDC_BIT, true);\n\t\tDW1000NgUtils::setBit(aon_wcfg, LEN_AON_WCFG, ONW_L64P_BIT, sleep_config.onWakeUpLoadL64Param);\n\t\tDW1000NgUtils::setBit(aon_wcfg, LEN_AON_WCFG, ONW_PRES_SLEEP_BIT, sleep_config.preserveSleep);\n\t\tDW1000NgUtils::setBit(aon_wcfg, LEN_AON_WCFG, ONW_LLDE_BIT, true);\n\t\tDW1000NgUtils::setBit(aon_wcfg, LEN_AON_WCFG, ONW_LLDO_BIT, true);\n\t\t_writeBytesToRegister(AON, AON_WCFG_SUB, aon_wcfg, LEN_AON_WCFG);\n\n\t\tDW1000NgUtils::setBit(aon_cfg0, 1, WAKE_PIN_BIT, sleep_config.enableWakePIN);\n\t\tDW1000NgUtils::setBit(aon_cfg0, 1, WAKE_SPI_BIT, sleep_config.enableWakeSPI);\n\t\tDW1000NgUtils::setBit(aon_cfg0, 1, WAKE_CNT_BIT, false);\n\t\tDW1000NgUtils::setBit(aon_cfg0, 1, SLEEP_EN_BIT, sleep_config.enableSLP);\n\t\t_writeBytesToRegister(AON, AON_CFG0_SUB, aon_cfg0, 1); // Deletes 3 bits of the unused LPCLKDIVA\n\t}\n\n\t/*Puts the device into sleep/deepSleep mode. This function also upload sleep config to AON. */\n\tvoid deepSleep()\n\t{\n\t\t/* Clear the register */\n\t\t_writeToRegister(AON, AON_CTRL_SUB, 0x00, LEN_AON_CTRL);\n\t\t/* Write 1 in SAVE_BIT */\n\t\t_writeToRegister(AON, AON_CTRL_SUB, 0x02, LEN_AON_CTRL);\n\t}\n\n\tvoid spiWakeup()\n\t{\n\t\tbyte deviceId[LEN_DEV_ID];\n\t\tbyte expectedDeviceId[LEN_DEV_ID];\n\t\tDW1000NgUtils::writeValueToBytes(expectedDeviceId, 0xDECA0130, LEN_DEV_ID);\n\t\t_readBytes(DEV_ID, NO_SUB, deviceId, LEN_DEV_ID);\n\t\tif (memcmp(deviceId, expectedDeviceId, LEN_DEV_ID))\n\t\t{\n\t\t\tdigitalWrite(_ss, LOW);\n\t\t\tdelay(1);\n\t\t\tdigitalWrite(_ss, HIGH);\n\t\t\tdelay(5);\n\t\t\tsetTxAntennaDelay(_antennaTxDelay);\n\t\t\tif (_debounceClockEnabled)\n\t\t\t{\n\t\t\t\tenableDebounceClock();\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid reset()   \n\t{\n\t\tif (_rst == 0xff)\n\t\t{ /* Fallback to Software Reset */\n\t\t\tsoftwareReset();\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// DW1000Ng data sheet v2.08 Â§5.6.1 page 20, the RSTn pin should not be driven high but left floating.\n\t\t\tpinMode(_rst, OUTPUT);\n\t\t\tdigitalWrite(_rst, LOW);\n\t\t\tdelay(2); // DW1000Ng data sheet v2.08 Â§5.6.1 page 20: nominal 50ns, to be safe take more time\n\t\t\tpinMode(_rst, INPUT);\n\t\t\tdelay(5); // dw1000Ng data sheet v1.2 page 5: nominal 3 ms, to be safe take more time\n\t\t}\n\t}\n\n\tvoid softwareReset()\n\t{\n\t\tSPIporting::setSPIspeed(SPIClock::SLOW);\n\n\t\t/* Disable sequencing and go to state \"INIT\" - (a) Sets SYSCLKS to 01 */\n\t\t_disableSequencing();\n\t\t/* Clear AON and WakeUp configuration */\n\t\t_writeToRegister(AON, AON_WCFG_SUB, 0x00, LEN_AON_WCFG);\n\t\t_writeToRegister(AON, AON_CFG0_SUB, 0x00, LEN_AON_CFG0);\n\t\t// TODO change this with uploadToAON\n\t\t_writeToRegister(AON, AON_CTRL_SUB, 0x00, LEN_AON_CTRL);\n\t\t_writeToRegister(AON, AON_CTRL_SUB, 0x02, LEN_AON_CTRL);\n\t\t/* (b) Clear SOFTRESET to all zeroâ€™s */\n\t\t_writeToRegister(PMSC, PMSC_SOFTRESET_SUB, 0x00, LEN_PMSC_SOFTRESET);\n\t\tdelay(1);\n\t\t/* (c) Set SOFTRESET to all ones */\n\t\t_writeToRegister(PMSC, PMSC_SOFTRESET_SUB, 0xF0, LEN_PMSC_SOFTRESET);\n\t}\n\n\t/* ###########################################################################\n\t * #### Pretty printed device information ####################################\n\t * ######################################################################### */\n\n\tvoid getPrintableDeviceIdentifier(char msgBuffer[])\n\t{\n\t\tbyte data[LEN_DEV_ID];\n\t\t_readBytes(DEV_ID, NO_SUB, data, LEN_DEV_ID);\n\t\tsprintf(msgBuffer, \"%02X - model: %d, version: %d, revision: %d\",\n\t\t\t\t(uint16_t)((data[3] << 8) | data[2]), data[1], (data[0] >> 4) & 0x0F, data[0] & 0x0F);\n\t}\n\n\tvoid getPrintableExtendedUniqueIdentifier(char msgBuffer[])\n\t{\n\t\tbyte data[LEN_EUI];\n\t\t_readBytes(EUI, NO_SUB, data, LEN_EUI);\n\t\tsprintf(msgBuffer, \"%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X\",\n\t\t\t\tdata[7], data[6], data[5], data[4], data[3], data[2], data[1], data[0]);\n\t}\n\n\tvoid getPrintableNetworkIdAndShortAddress(char msgBuffer[])\n\t{\n\t\tbyte data[LEN_PANADR];\n\t\t_readBytes(PANADR, NO_SUB, data, LEN_PANADR);\n\t\tsprintf(msgBuffer, \"PAN: %02X, Short Address: %02X\",\n\t\t\t\t(uint16_t)((data[3] << 8) | data[2]), (uint16_t)((data[1] << 8) | data[0]));\n\t}\n\n\tvoid getPrintableDeviceMode(char msgBuffer[])\n\t{\n\t\tuint16_t dr;\n\t\tuint8_t prf;\n\t\tuint16_t plen;\n\t\tuint8_t pcode;\n\t\tuint8_t ch;\n\t\tbyte chan_ctrl[LEN_CHAN_CTRL];\n\t\tbyte tx_fctrl[LEN_TX_FCTRL];\n\t\t_readBytes(CHAN_CTRL, NO_SUB, chan_ctrl, LEN_CHAN_CTRL);\n\t\t_readBytes(TX_FCTRL, NO_SUB, tx_fctrl, LEN_TX_FCTRL);\n\t\t/* Data Rate from 0x08 bits:13-14(tx_fctrl) */\n\t\tdr = (uint16_t)(tx_fctrl[1] >> 5 & 0x3);\n\t\tswitch (dr)\n\t\t{\n\t\tcase 0x00:\n\t\t\tdr = 110;\n\t\t\tbreak;\n\t\tcase 0x01:\n\t\t\tdr = 850;\n\t\t\tbreak;\n\t\tcase 0x02:\n\t\t\tdr = 6800;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn; // TODO Error handling\n\t\t}\n\t\t/* PRF(16 or 64) from 0x1F bits:18-19(chan_ctrl) */\n\t\tprf = (uint8_t)(chan_ctrl[2] >> 2 & 0x03);\n\t\tif (prf == 0x01)\n\t\t{\n\t\t\tprf = 16;\n\t\t}\n\t\telse if (prf == 0x02)\n\t\t{\n\t\t\tprf = 64;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn; // TODO Error handling\n\t\t}\n\t\t/* PreambleLength from 0x08 bits:18-21(tx_fctrl) */\n\t\tplen = (uint16_t)(tx_fctrl[2] >> 2 & 0xF);\n\t\tswitch (plen)\n\t\t{\n\t\tcase 0x01:\n\t\t\tplen = 64;\n\t\t\tbreak;\n\t\tcase 0x05:\n\t\t\tplen = 128;\n\t\t\tbreak;\n\t\tcase 0x09:\n\t\t\tplen = 256;\n\t\t\tbreak;\n\t\tcase 0x0D:\n\t\t\tplen = 512;\n\t\t\tbreak;\n\t\tcase 0x02:\n\t\t\tplen = 1024;\n\t\t\tbreak;\n\t\tcase 0x06:\n\t\t\tplen = 1536;\n\t\t\tbreak;\n\t\tcase 0x0A:\n\t\t\tplen = 2048;\n\t\t\tbreak;\n\t\tcase 0x03:\n\t\t\tplen = 4096;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn; // TODO Error handling\n\t\t}\n\t\t/* Channel from 0x1F bits:0-4(tx_chan) */\n\t\tch = (uint8_t)(chan_ctrl[0] & 0xF);\n\t\t/* Preamble Code from 0x1F bits:24-31(chan_ctrl) */\n\t\tpcode = (uint8_t)(chan_ctrl[3] >> 3 & 0x1F);\n\t\tsprintf(msgBuffer, \"Data rate: %u kb/s, PRF: %u MHz, Preamble: %u symbols, Channel: #%u, Preamble code #%u\", dr, prf, plen, ch, pcode);\n\t}\n\n\t/* ###########################################################################\n\t * #### DW1000Ng operation functions ###########################################\n\t * ######################################################################### */\n\n\tvoid setNetworkId(uint16_t val)\n\t{\n\t\t_networkAndAddress[2] = (byte)(val & 0xFF);\n\t\t_networkAndAddress[3] = (byte)((val >> 8) & 0xFF);\n\t\t_writeNetworkIdAndDeviceAddress();\n\t}\n\n\tvoid getNetworkId(byte id[])\n\t{\n\t\t_readNetworkIdAndDeviceAddress();\n\t\tid[0] = _networkAndAddress[2];\n\t\tid[1] = _networkAndAddress[3];\n\t}\n\n\tvoid setDeviceAddress(uint16_t val)\n\t{\n\t\t_networkAndAddress[0] = (byte)(val & 0xFF);\n\t\t_networkAndAddress[1] = (byte)((val >> 8) & 0xFF);\n\t\t_writeNetworkIdAndDeviceAddress();\n\t}\n\n\tvoid getDeviceAddress(byte address[])\n\t{\n\t\t_readNetworkIdAndDeviceAddress();\n\t\taddress[0] = _networkAndAddress[0];\n\t\taddress[1] = _networkAndAddress[1];\n\t}\n\n\tvoid setEUI(char eui[])\n\t{\n\t\tbyte eui_byte[LEN_EUI];\n\t\tDW1000NgUtils::convertToByte(eui, eui_byte);\n\t\tsetEUI(eui_byte);\n\t}\n\n\tvoid setEUI(byte eui[])\n\t{\n\t\t// we reverse the address->\n\t\tbyte reverseEUI[8];\n\t\tuint8_t size = 8;\n\t\tfor (uint8_t i = 0; i < size; i++)\n\t\t{\n\t\t\t*(reverseEUI + i) = *(eui + size - i - 1);\n\t\t}\n\t\t_writeBytesToRegister(EUI, NO_SUB, reverseEUI, LEN_EUI);\n\t}\n\n\tvoid getEUI(byte eui[])\n\t{\n\t\t_readBytes(EUI, NO_SUB, eui, LEN_EUI);\n\t}\n\n\tfloat getTemperature()\n\t{\n\t\t_vbatAndTempSteps();\n\t\tbyte sar_ltemp = 0;\n\t\t_readBytes(TX_CAL, 0x04, &sar_ltemp, 1);\n\t\treturn (sar_ltemp - _tmeas23C) * 1.14f + 23.0f;\n\t}\n\n\tfloat getBatteryVoltage()\n\t{\n\t\t_vbatAndTempSteps();\n\t\tbyte sar_lvbat = 0;\n\t\t_readBytes(TX_CAL, 0x03, &sar_lvbat, 1);\n\t\treturn (sar_lvbat - _vmeas3v3) / 173.0f + 3.3f;\n\t}\n\n\tvoid getTemperatureAndBatteryVoltage(float &temp, float &vbat)\n\t{\n\t\t// follow the procedure from section 6.4 of the User Manual\n\t\t_vbatAndTempSteps();\n\t\tdelay(1);\n\t\tbyte sar_lvbat = 0;\n\t\t_readBytes(TX_CAL, 0x03, &sar_lvbat, 1);\n\t\tbyte sar_ltemp = 0;\n\t\t_readBytes(TX_CAL, 0x04, &sar_ltemp, 1);\n\n\t\t// calculate voltage and temperature\n\t\tvbat = (sar_lvbat - _vmeas3v3) / 173.0f + 3.3f;\n\t\ttemp = (sar_ltemp - _tmeas23C) * 1.14f + 23.0f;\n\t}\n\n\tvoid enableFrameFiltering(frame_filtering_configuration_t config)\n\t{\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFEN_BIT, true);\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFBC_BIT, config.behaveAsCoordinator);\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFAB_BIT, config.allowBeacon);\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFAD_BIT, config.allowData);\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFAA_BIT, config.allowAcknowledgement);\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFAM_BIT, config.allowMacCommand);\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFAR_BIT, config.allowAllReserved);\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFA4_BIT, config.allowReservedFour);\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFA5_BIT, config.allowReservedFive);\n\n\t\t_writeSystemConfigurationRegister();\n\t}\n\n\tvoid disableFrameFiltering()\n\t{\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, FFEN_BIT, false);\n\t\t_writeSystemConfigurationRegister();\n\t}\n\n\tvoid setDoubleBuffering(boolean val)\n\t{\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, DIS_DRXB_BIT, !val);\n\t}\n\n\tvoid setAntennaDelay(uint16_t value)\n\t{\n\t\t_antennaTxDelay = value;\n\t\t_antennaRxDelay = value;\n\t\t_writeAntennaDelayRegisters();\n\t}\n\n\tvoid setTxAntennaDelay(uint16_t value)\n\t{\n\t\t_antennaTxDelay = value;\n\t\t_writeAntennaDelayRegisters();\n\t}\n\tvoid setRxAntennaDelay(uint16_t value)\n\t{\n\t\t_antennaRxDelay = value;\n\t\t_writeAntennaDelayRegisters();\n\t}\n\n\tuint16_t getTxAntennaDelay()\n\t{\n\t\treturn _antennaTxDelay;\n\t}\n\tuint16_t getRxAntennaDelay()\n\t{\n\t\treturn _antennaRxDelay;\n\t}\n\n\tvoid forceTRxOff()\n\t{\n\t\tmemset(_sysctrl, 0, LEN_SYS_CTRL);\n\t\tDW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, TRXOFF_BIT, true);\n\t\t_writeBytesToRegister(SYS_CTRL, NO_SUB, _sysctrl, LEN_SYS_CTRL);\n\t}\n\n\tvoid startReceive(ReceiveMode mode)\n\t{\n\t\tmemset(_sysctrl, 0, LEN_SYS_CTRL);\n\t\tDW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, SFCST_BIT, !_frameCheck);\n\t\tif (mode == ReceiveMode::DELAYED)\n\t\t\tDW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, RXDLYS_BIT, true);\n\t\tDW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, RXENAB_BIT, true);\n\t\t_writeBytesToRegister(SYS_CTRL, NO_SUB, _sysctrl, LEN_SYS_CTRL);\n\t}\n\n\tvoid startTransmit(TransmitMode mode)\n\t{\n\t\tmemset(_sysctrl, 0, LEN_SYS_CTRL);\n\t\tDW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, SFCST_BIT, !_frameCheck);\n\t\tif (mode == TransmitMode::DELAYED)\n\t\t\tDW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, TXDLYS_BIT, true);\n\t\tif (_wait4resp)\n\t\t\tDW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, WAIT4RESP_BIT, true);\n\n\t\tDW1000NgUtils::setBit(_sysctrl, LEN_SYS_CTRL, TXSTRT_BIT, true);\n\t\t_writeBytesToRegister(SYS_CTRL, NO_SUB, _sysctrl, LEN_SYS_CTRL);\n\t}\n\n\tvoid setInterruptPolarity(boolean val)\n\t{\n\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, HIRQ_POL_BIT, val);\n\t\t_writeSystemConfigurationRegister();\n\t}\n\n\tvoid applyConfiguration(device_configuration_t config)\n\t{\n\t\tforceTRxOff();\n\n\t\t_useExtendedFrameLength(config.extendedFrameLength);\n\t\t_setReceiverAutoReenable(config.receiverAutoReenable);\n\t\t_useSmartPower(config.smartPower);\n\t\t_useFrameCheck(config.frameCheck);\n\t\t_setNlosOptimization(config.nlos);\n\t\t_setSFDMode(config.sfd);\n\t\t_setChannel(config.channel);\n\t\t_setDataRate(config.dataRate);\n\t\t_setPulseFrequency(config.pulseFreq);\n\t\t_setPreambleLength(config.preambleLen);\n\t\t_setPreambleCode(config.preaCode);\n\n\t\tif (!_checkPreambleCodeValidity())\n\t\t\t_setValidPreambleCode();\n\n\t\tif (!_standardSFD)\n\t\t\t_setNonStandardSFDLength();\n\n\t\t// writes configuration to registers\n\t\t_writeConfiguration();\n\t\t// tune according to configuration\n\t\t_tune();\n\t}\n\n\tChannel getChannel()\n\t{\n\t\treturn _channel;\n\t}\n\n\tPulseFrequency getPulseFrequency()\n\t{\n\t\treturn _pulseFrequency;\n\t}\n\n\tvoid setPreambleDetectionTimeout(uint16_t pacSize)\n\t{\n\t\tbyte drx_pretoc[LEN_DRX_PRETOC];\n\t\tDW1000NgUtils::writeValueToBytes(drx_pretoc, pacSize, LEN_DRX_PRETOC);\n\t\t_writeBytesToRegister(DRX_TUNE, DRX_PRETOC_SUB, drx_pretoc, LEN_DRX_PRETOC);\n\t}\n\n\tvoid setSfdDetectionTimeout(uint16_t preambleSymbols)\n\t{\n\t\tbyte drx_sfdtoc[LEN_DRX_SFDTOC];\n\t\tDW1000NgUtils::writeValueToBytes(drx_sfdtoc, preambleSymbols, LEN_DRX_SFDTOC);\n\t\t_writeBytesToRegister(DRX_TUNE, DRX_SFDTOC_SUB, drx_sfdtoc, LEN_DRX_SFDTOC);\n\t}\n\n\tvoid setReceiveFrameWaitTimeoutPeriod(uint16_t timeMicroSeconds)\n\t{\n\t\tif (timeMicroSeconds > 0)\n\t\t{\n\t\t\tbyte rx_wfto[LEN_RX_WFTO];\n\t\t\tDW1000NgUtils::writeValueToBytes(rx_wfto, timeMicroSeconds, LEN_RX_WFTO);\n\t\t\t_writeBytesToRegister(RX_WFTO, NO_SUB, rx_wfto, LEN_RX_WFTO);\n\t\t\t/* enable frame wait timeout bit */\n\t\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, RXWTOE_BIT, true);\n\t\t\t_writeSystemConfigurationRegister();\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* disable frame wait timeout bit */\n\t\t\tDW1000NgUtils::setBit(_syscfg, LEN_SYS_CFG, RXWTOE_BIT, false);\n\t\t\t_writeSystemConfigurationRegister();\n\t\t}\n\t}\n\n\tvoid applyInterruptConfiguration(interrupt_configuration_t interrupt_config)\n\t{\n\t\tforceTRxOff();\n\n\t\t_interruptOnSent(interrupt_config.interruptOnSent);\n\t\t_interruptOnReceived(interrupt_config.interruptOnReceived);\n\t\t_interruptOnReceiveFailed(interrupt_config.interruptOnReceiveFailed);\n\t\t_interruptOnReceiveTimeout(interrupt_config.interruptOnReceiveTimeout);\n\t\t_interruptOnReceiveTimestampAvailable(interrupt_config.interruptOnReceiveTimestampAvailable);\n\t\t_interruptOnAutomaticAcknowledgeTrigger(interrupt_config.interruptOnAutomaticAcknowledgeTrigger);\n\n\t\t_writeSystemEventMaskRegister();\n\t}\n\n\tvoid setWait4Response(uint32_t timeMicroSeconds)\n\t{\n\t\t_wait4resp = timeMicroSeconds == 0 ? false : true;\n\n\t\t/* Check if it overflows 20 bits */\n\t\tif (timeMicroSeconds > 1048575)\n\t\t\ttimeMicroSeconds = 1048575;\n\n\t\tbyte W4R_TIME[LEN_ACK_RESP_T_W4R_TIME_SUB];\n\t\tDW1000NgUtils::writeValueToBytes(W4R_TIME, timeMicroSeconds, LEN_ACK_RESP_T_W4R_TIME_SUB);\n\t\tW4R_TIME[2] &= 0x0F;\n\t\t_writeBytesToRegister(ACK_RESP_T, ACK_RESP_T_W4R_TIME_SUB, W4R_TIME, LEN_ACK_RESP_T_W4R_TIME_SUB);\n\t}\n\n\tvoid setTXPower(byte power[])\n\t{\n\t\t// TODO Check byte length\n\t\t_writeBytesToRegister(TX_POWER, NO_SUB, power, LEN_TX_POWER);\n\t\t_autoTXPower = false;\n\t}\n\n\tvoid setTXPower(int32_t power)\n\t{\n\t\tbyte txpower[LEN_TX_POWER];\n\t\tDW1000NgUtils::writeValueToBytes(txpower, power, LEN_TX_POWER);\n\t\tsetTXPower(txpower);\n\t}\n\n\tvoid setTXPower(DriverAmplifierValue driver_amplifier, TransmitMixerValue mixer)\n\t{\n\t\tbyte txpower[LEN_TX_POWER];\n\t\tbyte pwr = 0x00;\n\n\t\tpwr |= ((byte)driver_amplifier << 5);\n\t\tpwr |= (byte)mixer;\n\n\t\tfor (auto i = 0; i < LEN_TX_POWER; i++)\n\t\t{\n\t\t\ttxpower[i] = pwr;\n\t\t}\n\n\t\tsetTXPower(txpower);\n\t}\n\n\tvoid setTXPowerAuto()\n\t{\n\t\t_autoTXPower = true;\n\t\t_txpowertune();\n\t}\n\n\tvoid setTCPGDelay(byte tcpgdelay)\n\t{\n\t\tbyte tcpgBytes[LEN_TC_PGDELAY];\n\t\tDW1000NgUtils::writeValueToBytes(tcpgBytes, tcpgdelay, LEN_TC_PGDELAY);\n\t\t_writeBytesToRegister(TX_CAL, TC_PGDELAY_SUB, tcpgBytes, LEN_TC_PGDELAY);\n\t\t_autoTCPGDelay = false;\n\t}\n\n\tvoid setTCPGDelayAuto()\n\t{\n\t\t_tcpgdelaytune();\n\t\t_autoTCPGDelay = true;\n\t}\n\n\tvoid enableTransmitPowerSpectrumTestMode(int32_t repeat_interval)\n\t{\n\t\t/* DW1000 clocks must be set to crystal speed so SPI rate have to be lowered and will\n\t\tnot be increased again */\n\t\tSPIporting::setSPIspeed(SPIClock::SLOW);\n\n\t\t_disableSequencing();\n\t\t_configureRFTransmitPowerSpectrumTestMode();\n\t\t_enableClock(SYS_PLL_CLOCK);\n\t\t_enableClock(TX_PLL_CLOCK);\n\n\t\tif (repeat_interval < 4)\n\t\t\trepeat_interval = 4;\n\n\t\t/* In diagnostic transmit power  mode (set next) the bytes 31:0 only are used for DX_TIME register */\n\t\tbyte delayBytes[4];\n\t\tDW1000NgUtils::writeValueToBytes(delayBytes, repeat_interval, 4);\n\t\t_writeBytesToRegister(DX_TIME, NO_SUB, delayBytes, 4);\n\n\t\t/* Enable Transmit Power Spectrum Test Mode */\n\t\tbyte diagnosticBytes[2];\n\t\tDW1000NgUtils::writeValueToBytes(diagnosticBytes, 0x0010, LEN_DIAG_TMC);\n\t\t_writeBytesToRegister(DIG_DIAG, DIAG_TMC_SUB, diagnosticBytes, LEN_DIAG_TMC);\n\t}\n\n\tvoid setDelayedTRX(byte futureTimeBytes[])\n\t{\n\t\t/* the least significant 9-bits are ignored in DX_TIME in functional modes */\n\t\t_writeBytesToRegister(DX_TIME, NO_SUB, futureTimeBytes, LEN_DX_TIME);\n\t}\n\n\tvoid setTransmitData(byte data[], uint16_t n)\n\t{\n\t\tif (_frameCheck)\n\t\t{\n\t\t\tn += 2; // two bytes CRC-16\n\t\t}\n\t\tif (n > LEN_EXT_UWB_FRAMES)\n\t\t{\n\t\t\treturn; // TODO proper error handling: frame/buffer size\n\t\t}\n\t\tif (n > LEN_UWB_FRAMES && !_extendedFrameLength)\n\t\t{\n\t\t\treturn; // TODO proper error handling: frame/buffer size\n\t\t}\n\t\t// transmit data and length\n\t\t_writeBytesToRegister(TX_BUFFER, NO_SUB, data, n);\n\n\t\t/* Sets up transmit frame control length based on data length */\n\t\t_txfctrl[0] = (byte)(n & 0xFF); // 1 byte (regular length + 1 bit)\n\t\t_txfctrl[1] &= 0xE0;\n\t\t_txfctrl[1] |= (byte)((n >> 8) & 0x03); // 2 added bits if extended length\n\t\t_writeTransmitFrameControlRegister();\n\t}\n\n\tvoid setTransmitData(const String &data)\n\t{\n\t\tuint16_t n = data.length() + 1;\n\t\tbyte *dataBytes = (byte *)malloc(n);\n\t\tdata.getBytes(dataBytes, n);\n\t\tsetTransmitData(dataBytes, n);\n\t\tfree(dataBytes);\n\t}\n\n\t// TODO reorder\n\tuint16_t getReceivedDataLength()\n\t{\n\t\tuint16_t len = 0;\n\n\t\t// 10 bits of RX frame control register\n\t\tbyte rxFrameInfo[LEN_RX_FINFO];\n\t\t_readBytes(RX_FINFO, NO_SUB, rxFrameInfo, LEN_RX_FINFO);\n\t\tlen = ((((uint16_t)rxFrameInfo[1] << 8) | (uint16_t)rxFrameInfo[0]) & 0x03FF);\n\n\t\tif (_frameCheck && len > 2)\n\t\t{\n\t\t\treturn len - 2;\n\t\t}\n\t\treturn len;\n\t}\n\n\tvoid getReceivedData(byte data[], uint16_t n)\n\t{\n\t\tif (n <= 0)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\t_readBytes(RX_BUFFER, NO_SUB, data, n);\n\t}\n\n\tvoid getReceivedData(String &data)\n\t{\n\t\tuint16_t i;\n\t\tuint16_t n = getReceivedDataLength(); // number of bytes w/o the two FCS ones\n\t\tif (n <= 0)\n\t\t{ // TODO\n\t\t\treturn;\n\t\t}\n\t\tbyte *dataBytes = (byte *)malloc(n);\n\t\tgetReceivedData(dataBytes, n);\n\t\t// clear string\n\t\tdata.remove(0);\n\t\tdata = \"\";\n\t\t// append to string\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tdata += (char)dataBytes[i];\n\t\t}\n\t\tfree(dataBytes);\n\t}\n\n\tuint64_t getTransmitTimestamp()\n\t{\n\t\tbyte data[LENGTH_TIMESTAMP];\n\t\tmemset(data, 0, LENGTH_TIMESTAMP);\n\t\t_readBytes(TX_TIME, TX_STAMP_SUB, data, LEN_TX_STAMP);\n\t\treturn DW1000NgUtils::bytesAsValue(data, LEN_TX_STAMP);\n\t}\n\n\tuint64_t getReceiveTimestamp()\n\t{\n\t\tbyte data[LEN_RX_STAMP];\n\t\tmemset(data, 0, LEN_RX_STAMP);\n\t\t_readBytes(RX_TIME, RX_STAMP_SUB, data, LEN_RX_STAMP);\n\t\treturn DW1000NgUtils::bytesAsValue(data, LEN_RX_STAMP);\n\t}\n\n\tuint64_t getSystemTimestamp()\n\t{\n\t\tbyte data[LEN_SYS_TIME];\n\t\tmemset(data, 0, LEN_SYS_TIME);\n\t\t_readBytes(SYS_TIME, NO_SUB, data, LEN_SYS_TIME);\n\t\treturn DW1000NgUtils::bytesAsValue(data, LEN_SYS_TIME);\n\t}\n\n\tfloat getReceiveQuality()\n\t{\n\t\tbyte noiseBytes[LEN_STD_NOISE];\n\t\tbyte fpAmpl2Bytes[LEN_FP_AMPL2];\n\t\tuint16_t noise, f2;\n\t\t_readBytes(RX_FQUAL, STD_NOISE_SUB, noiseBytes, LEN_STD_NOISE);\n\t\t_readBytes(RX_FQUAL, FP_AMPL2_SUB, fpAmpl2Bytes, LEN_FP_AMPL2);\n\t\tnoise = (uint16_t)noiseBytes[0] | ((uint16_t)noiseBytes[1] << 8);\n\t\tf2 = (uint16_t)fpAmpl2Bytes[0] | ((uint16_t)fpAmpl2Bytes[1] << 8);\n\t\treturn (float)f2 / noise;\n\t}\n\n\tfloat getFirstPathPower()\n\t{\n\t\tbyte fpAmpl1Bytes[LEN_FP_AMPL1];\n\t\tbyte fpAmpl2Bytes[LEN_FP_AMPL2];\n\t\tbyte fpAmpl3Bytes[LEN_FP_AMPL3];\n\t\tbyte rxFrameInfo[LEN_RX_FINFO];\n\t\tuint16_t f1, f2, f3, N;\n\t\tfloat A, corrFac;\n\t\t_readBytes(RX_TIME, FP_AMPL1_SUB, fpAmpl1Bytes, LEN_FP_AMPL1);\n\t\t_readBytes(RX_FQUAL, FP_AMPL2_SUB, fpAmpl2Bytes, LEN_FP_AMPL2);\n\t\t_readBytes(RX_FQUAL, FP_AMPL3_SUB, fpAmpl3Bytes, LEN_FP_AMPL3);\n\t\t_readBytes(RX_FINFO, NO_SUB, rxFrameInfo, LEN_RX_FINFO);\n\t\tf1 = (uint16_t)fpAmpl1Bytes[0] | ((uint16_t)fpAmpl1Bytes[1] << 8);\n\t\tf2 = (uint16_t)fpAmpl2Bytes[0] | ((uint16_t)fpAmpl2Bytes[1] << 8);\n\t\tf3 = (uint16_t)fpAmpl3Bytes[0] | ((uint16_t)fpAmpl3Bytes[1] << 8);\n\t\tN = (((uint16_t)rxFrameInfo[2] >> 4) & 0xFF) | ((uint16_t)rxFrameInfo[3] << 4);\n\n\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t{\n\t\t\tA = 113.77;\n\t\t\tcorrFac = 2.3334;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tA = 121.74;\n\t\t\tcorrFac = 1.1667;\n\t\t}\n\t\tfloat estFpPwr = 10.0 * log10(((float)f1 * (float)f1 + (float)f2 * (float)f2 + (float)f3 * (float)f3) / ((float)N * (float)N)) - A;\n\t\tif (estFpPwr <= -88)\n\t\t{\n\t\t\treturn estFpPwr;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// approximation of Fig. 22 in user manual for dbm correction\n\t\t\testFpPwr += (estFpPwr + 88) * corrFac;\n\t\t}\n\t\treturn estFpPwr;\n\t}\n\n\tfloat getReceivePower()\n\t{\n\t\tbyte cirPwrBytes[LEN_CIR_PWR];\n\t\tbyte rxFrameInfo[LEN_RX_FINFO];\n\t\tuint32_t twoPower17 = 131072;\n\t\tuint16_t C, N;\n\t\tfloat A, corrFac;\n\t\t_readBytes(RX_FQUAL, CIR_PWR_SUB, cirPwrBytes, LEN_CIR_PWR);\n\t\t_readBytes(RX_FINFO, NO_SUB, rxFrameInfo, LEN_RX_FINFO);\n\t\tC = (uint16_t)cirPwrBytes[0] | ((uint16_t)cirPwrBytes[1] << 8);\n\t\tN = (((uint16_t)rxFrameInfo[2] >> 4) & 0xFF) | ((uint16_t)rxFrameInfo[3] << 4);\n\n\t\tif (_pulseFrequency == PulseFrequency::FREQ_16MHZ)\n\t\t{\n\t\t\tA = 113.77;\n\t\t\tcorrFac = 2.3334;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tA = 121.74;\n\t\t\tcorrFac = 1.1667;\n\t\t}\n\n\t\tfloat estRxPwr = 10.0 * log10(((float)C * (float)twoPower17) / ((float)N * (float)N)) - A;\n\t\tif (estRxPwr <= -88)\n\t\t{\n\t\t\treturn estRxPwr;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// approximation of Fig. 22 in user manual for dbm correction\n\t\t\testRxPwr += (estRxPwr + 88) * corrFac;\n\t\t}\n\t\treturn estRxPwr;\n\t}\n\n#if DW1000NG_DEBUG\n\tvoid getPrettyBytes(byte data[], char msgBuffer[], uint16_t n)\n\t{\n\t\tuint16_t i, j, b;\n\t\tb = sprintf(msgBuffer, \"Data, bytes: %d\\nB: 7 6 5 4 3 2 1 0\\n\", n); // TODO - type\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tbyte curByte = data[i];\n\t\t\tsnprintf(&msgBuffer[b++], 2, \"%d\", (i + 1));\n\t\t\tmsgBuffer[b++] = (char)((i + 1) & 0xFF);\n\t\t\tmsgBuffer[b++] = ':';\n\t\t\tmsgBuffer[b++] = ' ';\n\t\t\tfor (j = 0; j < 8; j++)\n\t\t\t{\n\t\t\t\tmsgBuffer[b++] = ((curByte >> (7 - j)) & 0x01) ? '1' : '0';\n\t\t\t\tif (j < 7)\n\t\t\t\t{\n\t\t\t\t\tmsgBuffer[b++] = ' ';\n\t\t\t\t}\n\t\t\t\telse if (i < n - 1)\n\t\t\t\t{\n\t\t\t\t\tmsgBuffer[b++] = '\\n';\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmsgBuffer[b++] = '\\0';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmsgBuffer[b++] = '\\0';\n\t}\n\n\tvoid getPrettyBytes(byte cmd, uint16_t offset, char msgBuffer[], uint16_t n)\n\t{\n\t\tuint16_t i, j, b;\n\t\tbyte *readBuf = (byte *)malloc(n);\n\t\t_readBytes(cmd, offset, readBuf, n);\n\t\tb = sprintf(msgBuffer, \"Reg: 0x%02x, bytes: %d\\nB: 7 6 5 4 3 2 1 0\\n\", cmd, n); // TODO - tpye\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tbyte curByte = readBuf[i];\n\t\t\tsnprintf(&msgBuffer[b++], 2, \"%d\", (i + 1));\n\t\t\tmsgBuffer[b++] = (char)((i + 1) & 0xFF);\n\t\t\tmsgBuffer[b++] = ':';\n\t\t\tmsgBuffer[b++] = ' ';\n\t\t\tfor (j = 0; j < 8; j++)\n\t\t\t{\n\t\t\t\tmsgBuffer[b++] = ((curByte >> (7 - j)) & 0x01) ? '1' : '0';\n\t\t\t\tif (j < 7)\n\t\t\t\t{\n\t\t\t\t\tmsgBuffer[b++] = ' ';\n\t\t\t\t}\n\t\t\t\telse if (i < n - 1)\n\t\t\t\t{\n\t\t\t\t\tmsgBuffer[b++] = '\\n';\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmsgBuffer[b++] = '\\0';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmsgBuffer[b++] = '\\0';\n\t\tfree(readBuf);\n\t}\n#endif\n}"}}}Content-Length: 226

{"jsonrpc":"2.0","id":129,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1664,"character":25}}}Content-Length: 190

{"jsonrpc":"2.0","id":130,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"}}}Content-Length: 302

{"jsonrpc":"2.0","id":131,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"range":{"start":{"line":53,"character":26},"end":{"line":53,"character":26}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 185

{"id":129,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}Content-Length: 185

{"id":130,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}Content-Length: 485

{"id":131,"result":[{"title":"Add using-declaration for initializeNoInterrupt and remove qualifier","kind":"refactor","command":{"title":"Add using-declaration for initializeNoInterrupt and remove qualifier","command":"clangd.applyTweak","arguments":[{"tweakID":"AddUsing","file":"file:///C:/Users/ltp/AppData/Local/Temp/arduino-language-server801712847/sketch/BasicSender.ino.cpp","selection":{"start":{"line":62,"character":26},"end":{"line":62,"character":26}}}]}}],"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":132,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1664,"character":29}}}
>>>
Content-Length: 185

{"id":132,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":133,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1664,"character":30}}}
>>>
Content-Length: 185

{"id":133,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":134,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1661,"character":31}}}
>>>
Content-Length: 185

{"id":134,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":135,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1661,"character":32}}}
>>>
Content-Length: 185

{"id":135,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":136,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1643,"character":31}}}
>>>
Content-Length: 185

{"id":136,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":137,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1643,"character":40}}}
>>>
Content-Length: 185

{"id":137,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":138,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1643,"character":41}}}
>>>
Content-Length: 185

{"id":138,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 220

{"jsonrpc":"2.0","id":139,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1645,"character":9}}}
>>>
Content-Length: 185

{"id":139,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 233

{"jsonrpc":"2.0","id":140,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1645,"character":10}}}Content-Length: 190

{"jsonrpc":"2.0","id":141,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"}}}
>>>
Content-Length: 185

{"id":140,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}Content-Length: 185

{"id":141,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":142,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1645,"character":24}}}
>>>
Content-Length: 185

{"id":142,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 220

{"jsonrpc":"2.0","id":143,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1645,"character":8}}}
>>>
Content-Length: 185

{"id":143,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 225

{"jsonrpc":"2.0","id":144,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1645,"character":9}}}
>>>
Content-Length: 185

{"id":144,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 226

{"jsonrpc":"2.0","id":145,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1645,"character":15}}}
>>>
Content-Length: 185

{"id":145,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 226

{"jsonrpc":"2.0","id":146,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1645,"character":12}}}
>>>
Content-Length: 185

{"id":146,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 220

{"jsonrpc":"2.0","id":147,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1645,"character":6}}}
>>>
Content-Length: 185

{"id":147,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 220

{"jsonrpc":"2.0","id":148,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1645,"character":7}}}
>>>
Content-Length: 185

{"id":148,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 220

{"jsonrpc":"2.0","id":149,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1645,"character":8}}}
>>>
Content-Length: 185

{"id":149,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 190

{"jsonrpc":"2.0","id":150,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"}}}
>>>
Content-Length: 185

{"id":150,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 226

{"jsonrpc":"2.0","id":151,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1645,"character":14}}}
>>>
Content-Length: 185

{"id":151,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 226

{"jsonrpc":"2.0","id":152,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1645,"character":10}}}
>>>
Content-Length: 185

{"id":152,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 220

{"jsonrpc":"2.0","id":153,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1645,"character":8}}}
>>>
Content-Length: 185

{"id":153,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 232

{"jsonrpc":"2.0","id":154,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1645,"character":8}}}Content-Length: 190

{"jsonrpc":"2.0","id":155,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"}}}
>>>
Content-Length: 185

{"id":154,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}Content-Length: 185

{"id":155,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 225

{"jsonrpc":"2.0","id":156,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1645,"character":8}}}
>>>
Content-Length: 185

{"id":156,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 190

{"jsonrpc":"2.0","id":157,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"}}}
>>>
Content-Length: 185

{"id":157,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 225

{"jsonrpc":"2.0","id":158,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1645,"character":8}}}
>>>
Content-Length: 185

{"id":158,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 220

{"jsonrpc":"2.0","id":159,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1645,"character":6}}}
>>>
Content-Length: 185

{"id":159,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 190

{"jsonrpc":"2.0","id":160,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"}}}
>>>
Content-Length: 185

{"id":160,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 225

{"jsonrpc":"2.0","id":161,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1645,"character":7}}}
>>>
Content-Length: 185

{"id":161,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 220

{"jsonrpc":"2.0","id":162,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1645,"character":8}}}
>>>
Content-Length: 185

{"id":162,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 190

{"jsonrpc":"2.0","id":163,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"}}}
>>>
Content-Length: 185

{"id":163,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 225

{"jsonrpc":"2.0","id":164,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1645,"character":8}}}
>>>
Content-Length: 185

{"id":164,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 190

{"jsonrpc":"2.0","id":165,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"}}}
>>>
Content-Length: 185

{"id":165,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 225

{"jsonrpc":"2.0","id":166,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1645,"character":8}}}
>>>
Content-Length: 185

{"id":166,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 220

{"jsonrpc":"2.0","id":167,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1645,"character":8}}}
>>>
Content-Length: 185

{"id":167,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 225

{"jsonrpc":"2.0","id":168,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1645,"character":9}}}
>>>
Content-Length: 185

{"id":168,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 220

{"jsonrpc":"2.0","id":169,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1645,"character":8}}}
>>>
Content-Length: 185

{"id":169,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 190

{"jsonrpc":"2.0","id":170,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"}}}
>>>
Content-Length: 185

{"id":170,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":171,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1576,"character":28}}}
>>>
Content-Length: 185

{"id":171,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":172,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1576,"character":41}}}
>>>
Content-Length: 185

{"id":172,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":173,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1580,"character":32}}}
>>>
Content-Length: 185

{"id":173,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":174,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1578,"character":35}}}
>>>
Content-Length: 185

{"id":174,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":175,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1578,"character":26}}}
>>>
Content-Length: 185

{"id":175,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":176,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1578,"character":26}}}
>>>
Content-Length: 185

{"id":176,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":177,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1580,"character":26}}}
>>>
Content-Length: 185

{"id":177,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":178,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1580,"character":28}}}
>>>
Content-Length: 185

{"id":178,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":179,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1580,"character":29}}}
>>>
Content-Length: 185

{"id":179,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":180,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1578,"character":27}}}
>>>
Content-Length: 185

{"id":180,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":181,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1580,"character":37}}}
>>>
Content-Length: 185

{"id":181,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 190

{"jsonrpc":"2.0","id":182,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"}}}
>>>
Content-Length: 185

{"id":182,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 233

{"jsonrpc":"2.0","id":183,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1589,"character":13}}}Content-Length: 190

{"jsonrpc":"2.0","id":184,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"}}}
>>>
Content-Length: 185

{"id":183,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}Content-Length: 185

{"id":184,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 190

{"jsonrpc":"2.0","id":185,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"}}}
>>>
Content-Length: 185

{"id":185,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":186,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1589,"character":24}}}
>>>
Content-Length: 185

{"id":186,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":187,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1589,"character":24}}}
>>>
Content-Length: 185

{"id":187,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":188,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1589,"character":19}}}
>>>
Content-Length: 185

{"id":188,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":189,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1588,"character":31}}}
>>>
Content-Length: 185

{"id":189,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":190,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1595,"character":27}}}
>>>
Content-Length: 185

{"id":190,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":191,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1595,"character":28}}}
>>>
Content-Length: 185

{"id":191,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":192,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1598,"character":26}}}
>>>
Content-Length: 185

{"id":192,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":193,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1598,"character":28}}}
>>>
Content-Length: 185

{"id":193,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":194,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1606,"character":18}}}
>>>
Content-Length: 185

{"id":194,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":195,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1595,"character":22}}}
>>>
Content-Length: 185

{"id":195,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":196,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1595,"character":23}}}
>>>
Content-Length: 185

{"id":196,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 220

{"jsonrpc":"2.0","id":197,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1604,"character":5}}}
>>>
Content-Length: 185

{"id":197,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 232

{"jsonrpc":"2.0","id":198,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1604,"character":6}}}Content-Length: 190

{"jsonrpc":"2.0","id":199,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"}}}
>>>
Content-Length: 185

{"id":198,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}Content-Length: 185

{"id":199,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 190

{"jsonrpc":"2.0","id":200,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"}}}
>>>
Content-Length: 185

{"id":200,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 220

{"jsonrpc":"2.0","id":201,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1604,"character":5}}}
>>>
Content-Length: 185

{"id":201,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 225

{"jsonrpc":"2.0","id":202,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1604,"character":5}}}
>>>
Content-Length: 185

{"id":202,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 220

{"jsonrpc":"2.0","id":203,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1604,"character":4}}}
>>>
Content-Length: 185

{"id":203,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 220

{"jsonrpc":"2.0","id":204,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1604,"character":5}}}
>>>
Content-Length: 185

{"id":204,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 220

{"jsonrpc":"2.0","id":205,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1604,"character":5}}}
>>>
Content-Length: 185

{"id":205,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 220

{"jsonrpc":"2.0","id":206,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1604,"character":5}}}
>>>
Content-Length: 185

{"id":206,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 190

{"jsonrpc":"2.0","id":207,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"}}}
>>>
Content-Length: 185

{"id":207,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 225

{"jsonrpc":"2.0","id":208,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1604,"character":5}}}
>>>
Content-Length: 185

{"id":208,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 190

{"jsonrpc":"2.0","id":209,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"}}}
>>>
Content-Length: 185

{"id":209,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 225

{"jsonrpc":"2.0","id":210,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1604,"character":5}}}
>>>
Content-Length: 185

{"id":210,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 220

{"jsonrpc":"2.0","id":211,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1604,"character":4}}}
>>>
Content-Length: 185

{"id":211,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 190

{"jsonrpc":"2.0","id":212,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"}}}
>>>
Content-Length: 185

{"id":212,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 225

{"jsonrpc":"2.0","id":213,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1604,"character":4}}}
>>>
Content-Length: 185

{"id":213,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 190

{"jsonrpc":"2.0","id":214,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"}}}
>>>
Content-Length: 185

{"id":214,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 190

{"jsonrpc":"2.0","id":215,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"}}}
>>>
Content-Length: 185

{"id":215,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 190

{"jsonrpc":"2.0","id":216,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"}}}
>>>
Content-Length: 185

{"id":216,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 190

{"jsonrpc":"2.0","id":217,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"}}}
>>>
Content-Length: 185

{"id":217,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 190

{"jsonrpc":"2.0","id":218,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"}}}
>>>
Content-Length: 185

{"id":218,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 225

{"jsonrpc":"2.0","id":219,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1604,"character":4}}}
>>>
Content-Length: 185

{"id":219,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 190

{"jsonrpc":"2.0","id":220,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"}}}
>>>
Content-Length: 185

{"id":220,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 232

{"jsonrpc":"2.0","id":221,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1604,"character":4}}}Content-Length: 190

{"jsonrpc":"2.0","id":222,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"}}}
>>>
Content-Length: 185

{"id":221,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}Content-Length: 185

{"id":222,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 190

{"jsonrpc":"2.0","id":223,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"}}}
>>>
Content-Length: 185

{"id":223,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":224,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1604,"character":10}}}
>>>
Content-Length: 185

{"id":224,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 190

{"jsonrpc":"2.0","id":225,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"}}}
>>>
Content-Length: 185

{"id":225,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 190

{"jsonrpc":"2.0","id":226,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"}}}
>>>
Content-Length: 185

{"id":226,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 190

{"jsonrpc":"2.0","id":227,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"}}}
>>>
Content-Length: 185

{"id":227,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 190

{"jsonrpc":"2.0","id":228,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"}}}
>>>
Content-Length: 185

{"id":228,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 190

{"jsonrpc":"2.0","id":229,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"}}}
>>>
Content-Length: 185

{"id":229,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 190

{"jsonrpc":"2.0","id":230,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"}}}
>>>
Content-Length: 185

{"id":230,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":231,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1880,"character":14}}}
>>>
Content-Length: 185

{"id":231,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":232,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1880,"character":15}}}
>>>
Content-Length: 185

{"id":232,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":233,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1880,"character":16}}}
>>>
Content-Length: 185

{"id":233,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":234,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1880,"character":11}}}
>>>
Content-Length: 185

{"id":234,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 233

{"jsonrpc":"2.0","id":235,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1880,"character":11}}}Content-Length: 190

{"jsonrpc":"2.0","id":236,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"}}}
>>>
Content-Length: 185

{"id":235,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}Content-Length: 185

{"id":236,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 190

{"jsonrpc":"2.0","id":237,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"}}}
>>>
Content-Length: 185

{"id":237,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":238,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1895,"character":32}}}
>>>
Content-Length: 185

{"id":238,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":239,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1897,"character":43}}}
>>>
Content-Length: 185

{"id":239,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":240,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1897,"character":43}}}
>>>
Content-Length: 185

{"id":240,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":241,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1897,"character":43}}}
>>>
Content-Length: 185

{"id":241,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":242,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1897,"character":44}}}
>>>
Content-Length: 185

{"id":242,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 221

{"jsonrpc":"2.0","id":243,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"},"position":{"line":1889,"character":23}}}
>>>
Content-Length: 185

{"id":243,"error":{"code":0,"message":"Document is not available: file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 175

{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///c%3A/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp"}}}Content-Length: 199

{"jsonrpc":"2.0","id":244,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"}}}
>>>
Content-Length: 183

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///c:/Users/ltp/Documents/Arduino/libraries/RAK13801-UWB-Library/src/DW1000Ng.cpp","diagnostics":[]},"jsonrpc":"2.0"}Content-Length: 1388

{"id":244,"result":[{"name":"PIN_SS","kind":13,"range":{"start":{"line":12,"character":0},"end":{"line":12,"character":25}},"selectionRange":{"start":{"line":12,"character":14},"end":{"line":12,"character":20}}},{"name":"delaySent","kind":13,"range":{"start":{"line":16,"character":0},"end":{"line":16,"character":36}},"selectionRange":{"start":{"line":16,"character":23},"end":{"line":16,"character":32}}},{"name":"sentNum","kind":13,"range":{"start":{"line":17,"character":0},"end":{"line":17,"character":19}},"selectionRange":{"start":{"line":17,"character":8},"end":{"line":17,"character":15}}},{"name":"DEFAULT_CONFIG","kind":13,"range":{"start":{"line":19,"character":0},"end":{"line":31,"character":1}},"selectionRange":{"start":{"line":19,"character":23},"end":{"line":19,"character":37}}},{"name":"setup","kind":12,"range":{"start":{"line":33,"character":0},"end":{"line":78,"character":1}},"selectionRange":{"start":{"line":33,"character":5},"end":{"line":33,"character":10}}},{"name":"transmit","kind":12,"range":{"start":{"line":87,"character":0},"end":{"line":101,"character":1}},"selectionRange":{"start":{"line":87,"character":5},"end":{"line":87,"character":13}}},{"name":"loop","kind":12,"range":{"start":{"line":103,"character":0},"end":{"line":110,"character":1}},"selectionRange":{"start":{"line":103,"character":5},"end":{"line":103,"character":9}}}],"jsonrpc":"2.0"}
<<<
Content-Length: 227

{"jsonrpc":"2.0","id":245,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":34,"character":6}}}
>>>
Content-Length: 394

{"id":245,"result":{"contents":{"kind":"markdown","value":"### function `pinMode`  \n\n---\nâ†’ `void`  \nParameters:  \n- `pin_size_t pinNumber`\n- `PinMode pinMode`\n\nRedeclare Common.h functions with the updated PinMode  \n\n---\n```cpp\nvoid pinMode(pin_size_t pinNumber, PinMode pinMode)\n```"},"range":{"start":{"line":34,"character":2},"end":{"line":34,"character":9}}},"jsonrpc":"2.0"}
<<<
Content-Length: 228

{"jsonrpc":"2.0","id":246,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":38,"character":19}}}
>>>
Content-Length: 40

{"id":246,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 228

{"jsonrpc":"2.0","id":247,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":64,"character":37}}}
>>>
Content-Length: 40

{"id":247,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 228

{"jsonrpc":"2.0","id":248,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":53,"character":39}}}
>>>
Content-Length: 309

{"id":248,"result":{"contents":{"kind":"markdown","value":"### variable `PIN_SS`  \n\n---\nType: `const uint8_t`  \nValue = `17`  \nPassed as ss  \nspi select pin  \n\n---\n```cpp\nconst uint8_t PIN_SS = SS\n```"},"range":{"start":{"line":53,"character":34},"end":{"line":53,"character":40}}},"jsonrpc":"2.0"}
<<<
Content-Length: 240

{"jsonrpc":"2.0","id":249,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":53,"character":40}}}
>>>
Content-Length: 126

{"id":249,"result":[{"range":{"start":{"line":53,"character":12},"end":{"line":53,"character":33}},"kind":1}],"jsonrpc":"2.0"}
<<<
Content-Length: 302

{"jsonrpc":"2.0","id":250,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"range":{"start":{"line":53,"character":40},"end":{"line":53,"character":40}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":250,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 228

{"jsonrpc":"2.0","id":251,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":53,"character":40}}}
>>>
Content-Length: 771

{"id":251,"result":{"contents":{"kind":"markdown","value":"### function `initializeNoInterrupt`  \n\n---\nâ†’ `void`  \nParameters:  \n- `uint8_t ss`\n- `uint8_t rst = 255`\n\nInitiates and starts a sessions with a DW1000 without interrupt. If rst is not set or value 0xff, a soft resets (i.e. command triggered) are used and it is assumed that no reset line is wired.  \n@param[in] ss The SPI Selection pin used to identify the specific connection  \n@param[in] rst The reset line/pin for hard resets of ICs that connect to the Arduino. Value 0xff means soft reset.  \n\n---\n```cpp\n// In namespace DW1000Ng\nvoid initializeNoInterrupt(uint8_t ss, uint8_t rst = 255)\n```"},"range":{"start":{"line":53,"character":34},"end":{"line":53,"character":40}}},"jsonrpc":"2.0"}
<<<
Content-Length: 228

{"jsonrpc":"2.0","id":252,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":54,"character":48}}}
>>>
Content-Length: 40

{"id":252,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 228

{"jsonrpc":"2.0","id":253,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":12,"character":27}}}
>>>
Content-Length: 40

{"id":253,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 228

{"jsonrpc":"2.0","id":254,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":12,"character":41}}}
>>>
Content-Length: 40

{"id":254,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 240

{"jsonrpc":"2.0","id":255,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":12,"character":44}}}
>>>
Content-Length: 38

{"id":255,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 302

{"jsonrpc":"2.0","id":256,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"range":{"start":{"line":12,"character":44},"end":{"line":12,"character":44}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 38

{"id":256,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 326

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino","version":2},"contentChanges":[{"range":{"start":{"line":12,"character":44},"end":{"line":12,"character":44}},"rangeLength":0,"text":"\r\n"}]}}Content-Length: 199

{"jsonrpc":"2.0","id":257,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"}}}
>>>
Content-Length: 1388

{"id":257,"result":[{"name":"PIN_SS","kind":13,"range":{"start":{"line":12,"character":0},"end":{"line":12,"character":25}},"selectionRange":{"start":{"line":12,"character":14},"end":{"line":12,"character":20}}},{"name":"delaySent","kind":13,"range":{"start":{"line":17,"character":0},"end":{"line":17,"character":36}},"selectionRange":{"start":{"line":17,"character":23},"end":{"line":17,"character":32}}},{"name":"sentNum","kind":13,"range":{"start":{"line":18,"character":0},"end":{"line":18,"character":19}},"selectionRange":{"start":{"line":18,"character":8},"end":{"line":18,"character":15}}},{"name":"DEFAULT_CONFIG","kind":13,"range":{"start":{"line":20,"character":0},"end":{"line":32,"character":1}},"selectionRange":{"start":{"line":20,"character":23},"end":{"line":20,"character":37}}},{"name":"setup","kind":12,"range":{"start":{"line":34,"character":0},"end":{"line":79,"character":1}},"selectionRange":{"start":{"line":34,"character":5},"end":{"line":34,"character":10}}},{"name":"transmit","kind":12,"range":{"start":{"line":88,"character":0},"end":{"line":102,"character":1}},"selectionRange":{"start":{"line":88,"character":5},"end":{"line":88,"character":13}}},{"name":"loop","kind":12,"range":{"start":{"line":104,"character":0},"end":{"line":111,"character":1}},"selectionRange":{"start":{"line":104,"character":5},"end":{"line":104,"character":9}}}],"jsonrpc":"2.0"}
<<<
Content-Length: 386

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino","version":3},"contentChanges":[{"range":{"start":{"line":13,"character":0},"end":{"line":13,"character":0}},"rangeLength":0,"text":"const uint8_t PIN_RST = WB_IO6;\r\nconst uint8_t PIN_IRQ = WB_IO5;"}]}}Content-Length: 199

{"jsonrpc":"2.0","id":258,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"}}}






Started logging.

<<<
Content-Length: 3141

{"jsonrpc":"2.0","id":0,"method":"initialize","params":{"processId":37416,"clientInfo":{"name":"vscode","version":"1.53.2"},"rootPath":"d:\\RAK-Work\\20210707\\RAK13801\\RAK13801-UWB-Library\\examples\\BasicSender","rootUri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender","capabilities":{"workspace":{"applyEdit":true,"workspaceEdit":{"documentChanges":true,"resourceOperations":["create","rename","delete"],"failureHandling":"textOnlyTransactional"},"didChangeConfiguration":{"dynamicRegistration":true},"didChangeWatchedFiles":{"dynamicRegistration":true},"symbol":{"dynamicRegistration":true,"symbolKind":{"valueSet":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]}},"executeCommand":{"dynamicRegistration":true},"configuration":true,"workspaceFolders":true},"textDocument":{"publishDiagnostics":{"relatedInformation":true,"versionSupport":false,"tagSupport":{"valueSet":[1,2]}},"synchronization":{"dynamicRegistration":true,"willSave":true,"willSaveWaitUntil":true,"didSave":true},"completion":{"dynamicRegistration":true,"contextSupport":true,"completionItem":{"snippetSupport":true,"commitCharactersSupport":true,"documentationFormat":["markdown","plaintext"],"deprecatedSupport":true,"preselectSupport":true,"tagSupport":{"valueSet":[1]}},"completionItemKind":{"valueSet":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25]}},"hover":{"dynamicRegistration":true,"contentFormat":["markdown","plaintext"]},"signatureHelp":{"dynamicRegistration":true,"signatureInformation":{"documentationFormat":["markdown","plaintext"],"parameterInformation":{"labelOffsetSupport":true}},"contextSupport":true},"definition":{"dynamicRegistration":true,"linkSupport":true},"references":{"dynamicRegistration":true},"documentHighlight":{"dynamicRegistration":true},"documentSymbol":{"dynamicRegistration":true,"symbolKind":{"valueSet":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]},"hierarchicalDocumentSymbolSupport":true},"codeAction":{"dynamicRegistration":true,"isPreferredSupport":true,"codeActionLiteralSupport":{"codeActionKind":{"valueSet":["","quickfix","refactor","refactor.extract","refactor.inline","refactor.rewrite","source","source.organizeImports"]}}},"codeLens":{"dynamicRegistration":true},"formatting":{"dynamicRegistration":true},"rangeFormatting":{"dynamicRegistration":true},"onTypeFormatting":{"dynamicRegistration":true},"rename":{"dynamicRegistration":true,"prepareSupport":true},"documentLink":{"dynamicRegistration":true,"tooltipSupport":true},"typeDefinition":{"dynamicRegistration":true,"linkSupport":true},"implementation":{"dynamicRegistration":true,"linkSupport":true},"colorProvider":{"dynamicRegistration":true},"foldingRange":{"dynamicRegistration":true,"rangeLimit":5000,"lineFoldingOnly":true},"declaration":{"dynamicRegistration":true,"linkSupport":true},"selectionRange":{"dynamicRegistration":true}},"window":{"workDoneProgress":true}},"initializationOptions":{},"trace":"off","workspaceFolders":[{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender","name":"BasicSender"}]}}
>>>
Content-Length: 598

{"id":0,"result":{"capabilities":{"textDocumentSync":2,"hoverProvider":true,"completionProvider":{"triggerCharacters":[".","\u003e",":"]},"signatureHelpProvider":{"triggerCharacters":["(",","]},"definitionProvider":true,"documentHighlightProvider":true,"documentSymbolProvider":true,"workspaceSymbolProvider":true,"codeActionProvider":true,"documentFormattingProvider":true,"documentRangeFormattingProvider":true,"documentOnTypeFormattingProvider":{"firstTriggerCharacter":"\n"},"renameProvider":false,"executeCommandProvider":{"commands":["clangd.applyFix","clangd.applyTweak"]}}},"jsonrpc":"2.0"}
<<<
Content-Length: 52

{"jsonrpc":"2.0","method":"initialized","params":{}}Content-Length: 3555

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino","languageId":"cpp","version":3,"text":"/**\r\n   @file BasicSender.ino\r\n   @author rakwireless.com\r\n   @brief UWB transmit sender\r\n   @version 0.1\r\n   @date 2022-1-28\r\n   @copyright Copyright (c) 2020\r\n**/\r\n\r\n#include <SPI.h>\r\n#include <DW1000Ng.hpp>\r\n\r\nconst uint8_t PIN_SS = SS; // spi select pin\r\nconst uint8_t PIN_RST = WB_IO6;\r\nconst uint8_t PIN_IRQ = WB_IO5;\r\n\r\n\r\n// DEBUG packet sent status and count\r\nvolatile unsigned long delaySent = 0;\r\nint16_t sentNum = 0; // todo check int type\r\n\r\ndevice_configuration_t DEFAULT_CONFIG = {\r\n    false,\r\n    true,\r\n    true,\r\n    true,\r\n    false,\r\n    SFDMode::STANDARD_SFD,\r\n    Channel::CHANNEL_5,\r\n    DataRate::RATE_850KBPS,\r\n    PulseFrequency::FREQ_16MHZ,\r\n    PreambleLength::LEN_256,\r\n    PreambleCode::CODE_3\r\n};\r\n\r\nvoid setup() {\r\n  pinMode(WB_IO2, OUTPUT);\r\n  digitalWrite(WB_IO2, HIGH); //Turn on the power switch\r\n  delay(300);\r\n  time_t serial_timeout = millis();\r\n  // DEBUG monitoring\r\n  Serial.begin(115200);\r\n  while (!Serial)\r\n  {\r\n    if ((millis() - serial_timeout) < 5000)\r\n    {\r\n      delay(100);\r\n    }\r\n    else\r\n    {\r\n      break;\r\n    }\r\n  }\r\n  Serial.println(F(\"### DW1000Ng-arduino-sender-test ###\"));\r\n  // initialize the driver\r\n  DW1000Ng::initializeNoInterrupt(PIN_SS);\r\n  Serial.println(F(\"DW1000Ng initialized ...\"));\r\n\r\n  DW1000Ng::applyConfiguration(DEFAULT_CONFIG);\r\n\t//DW1000Ng::applyInterruptConfiguration(DEFAULT_INTERRUPT_CONFIG);\r\n\r\n  DW1000Ng::setDeviceAddress(5);\r\n  DW1000Ng::setNetworkId(10);\r\n\r\n  DW1000Ng::setAntennaDelay(16436);\r\n  Serial.println(F(\"Committed configuration ...\"));\r\n  // DEBUG chip info and registers pretty printed\r\n  char msg[128];\r\n  DW1000Ng::getPrintableDeviceIdentifier(msg);\r\n  Serial.print(\"Device ID: \"); Serial.println(msg);\r\n  DW1000Ng::getPrintableExtendedUniqueIdentifier(msg);\r\n  Serial.print(\"Unique ID: \"); Serial.println(msg);\r\n  DW1000Ng::getPrintableNetworkIdAndShortAddress(msg);\r\n  Serial.print(\"Network ID & Device Address: \"); Serial.println(msg);\r\n  DW1000Ng::getPrintableDeviceMode(msg);\r\n  Serial.print(\"Device mode: \"); Serial.println(msg);\r\n  // attach callback for (successfully) sent messages\r\n  //DW1000Ng::attachSentHandler(handleSent);\r\n  // start a transmission\r\n  transmit();\r\n}\r\n\r\n/*\r\nvoid handleSent() {\r\n  // status change on sent success\r\n  sentAck = true;\r\n}\r\n*/\r\n\r\nvoid transmit() {\r\n  // transmit some data\r\n  Serial.print(\"Transmitting packet ... #\"); Serial.println(sentNum);\r\n  String msg = \"Hello DW1000Ng, it's #\"; msg += sentNum;\r\n  DW1000Ng::setTransmitData(msg);\r\n  // delay sending the message for the given amount\r\n  delay(1000);\r\n  DW1000Ng::startTransmit(TransmitMode::IMMEDIATE);\r\n  delaySent = millis();\r\n  while(!DW1000Ng::isTransmitDone()) {\r\n\r\n  }\r\n  sentNum++;\r\n  DW1000Ng::clearTransmitStatus();\r\n}\r\n\r\nvoid loop() {\r\n    transmit();\r\n    // update and print some information about the sent message\r\n    Serial.print(\"ARDUINO delay sent [ms] ... \"); Serial.println(millis() - delaySent);\r\n    uint64_t newSentTime = DW1000Ng::getTransmitTimestamp();\r\n    Serial.print(\"Processed packet ... #\"); Serial.println(sentNum);\r\n    Serial.println();\r\n}\r\n"}}}Content-Length: 300

{"jsonrpc":"2.0","id":1,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"range":{"start":{"line":14,"character":31},"end":{"line":14,"character":31}},"context":{"diagnostics":[]}}}Content-Length: 197

{"jsonrpc":"2.0","id":2,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"}}}Content-Length: 195

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino","version":3}}}Content-Length: 231

{"jsonrpc":"2.0","id":3,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":14,"character":27}}}Content-Length: 62

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":3}}Content-Length: 231

{"jsonrpc":"2.0","id":4,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":13,"character":29}}}Content-Length: 226

{"jsonrpc":"2.0","id":5,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":13,"character":29}}}Content-Length: 62

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":5}}Content-Length: 226

{"jsonrpc":"2.0","id":6,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":13,"character":18}}}Content-Length: 238

{"jsonrpc":"2.0","id":7,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":13,"character":18}}}Content-Length: 62

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":2}}Content-Length: 62

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":6}}Content-Length: 197

{"jsonrpc":"2.0","id":8,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"}}}Content-Length: 62

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":8}}Content-Length: 197

{"jsonrpc":"2.0","id":9,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"}}}Content-Length: 301

{"jsonrpc":"2.0","id":10,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"range":{"start":{"line":13,"character":14},"end":{"line":13,"character":21}},"context":{"diagnostics":[]}}}Content-Length: 62

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":1}}Content-Length: 227

{"jsonrpc":"2.0","id":11,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":13,"character":18}}}Content-Length: 62

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":4}}Content-Length: 232

{"jsonrpc":"2.0","id":12,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":13,"character":19}}}Content-Length: 63

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":11}}Content-Length: 227

{"jsonrpc":"2.0","id":13,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RA
>>>
Content-Length: 111

{"method":"window/workDoneProgress/create","params":{"token":"backgroundIndexProgress"},"id":0,"jsonrpc":"2.0"}Content-Length: 36

{"id":1,"result":[],"jsonrpc":"2.0"}Content-Length: 607

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino","diagnostics":[{"range":{"start":{"line":39,"character":2},"end":{"line":39,"character":8}},"severity":1,"code":"unknown_typename_suggest","source":"clang","message":"Unknown type name 'time_t'; did you mean 'size_t'? (fix available)\n\nc:\\Users\\ltp\\AppData\\Local\\Programs\\Arduino IDE\\resources\\app\\node_modules\\arduino-ide-extension\\build\\lib\\clang\\12.0.0\\include\\stddef.h:46:23:\nnote: 'size_t' declared here"}]},"jsonrpc":"2.0"}Content-Length: 1772

{"id":2,"result":[{"name":"PIN_SS","kind":13,"range":{"start":{"line":12,"character":0},"end":{"line":12,"character":25}},"selectionRange":{"start":{"line":12,"character":14},"end":{"line":12,"character":20}}},{"name":"PIN_RST","kind":13,"range":{"start":{"line":13,"character":0},"end":{"line":13,"character":30}},"selectionRange":{"start":{"line":13,"character":14},"end":{"line":13,"character":21}}},{"name":"PIN_IRQ","kind":13,"range":{"start":{"line":14,"character":0},"end":{"line":14,"character":30}},"selectionRange":{"start":{"line":14,"character":14},"end":{"line":14,"character":21}}},{"name":"delaySent","kind":13,"range":{"start":{"line":18,"character":0},"end":{"line":18,"character":36}},"selectionRange":{"start":{"line":18,"character":23},"end":{"line":18,"character":32}}},{"name":"sentNum","kind":13,"range":{"start":{"line":19,"character":0},"end":{"line":19,"character":19}},"selectionRange":{"start":{"line":19,"character":8},"end":{"line":19,"character":15}}},{"name":"DEFAULT_CONFIG","kind":13,"range":{"start":{"line":21,"character":0},"end":{"line":33,"character":1}},"selectionRange":{"start":{"line":21,"character":23},"end":{"line":21,"character":37}}},{"name":"setup","kind":12,"range":{"start":{"line":35,"character":0},"end":{"line":80,"character":1}},"selectionRange":{"start":{"line":35,"character":5},"end":{"line":35,"character":10}}},{"name":"transmit","kind":12,"range":{"start":{"line":89,"character":0},"end":{"line":103,"character":1}},"selectionRange":{"start":{"line":89,"character":5},"end":{"line":89,"character":13}}},{"name":"loop","kind":12,"range":{"start":{"line":105,"character":0},"end":{"line":112,"character":1}},"selectionRange":{"start":{"line":105,"character":5},"end":{"line":105,"character":9}}}],"jsonrpc":"2.0"}Content-Length: 264

{"id":3,"result":[{"uri":"file:///C:/Users/ltp/AppData/Local/Arduino15/packages/rakwireless/hardware/mbed_rp2040/0.0.5/variants/WisBlock_RAK11300_Board/pins_arduino.h","range":{"start":{"line":32,"character":21},"end":{"line":32,"character":27}}}],"jsonrpc":"2.0"}Content-Length: 264

{"id":4,"result":[{"uri":"file:///C:/Users/ltp/AppData/Local/Arduino15/packages/rakwireless/hardware/mbed_rp2040/0.0.5/variants/WisBlock_RAK11300_Board/pins_arduino.h","range":{"start":{"line":33,"character":21},"end":{"line":33,"character":27}}}],"jsonrpc":"2.0"}Content-Length: 288

{"id":5,"result":{"contents":{"kind":"markdown","value":"### variable `WB_IO6`  \n\n---\nType: `const uint8_t`  \nValue = `8`  \nSLOT_D  \n\n---\n```cpp\nstatic const uint8_t WB_IO6 = 8\n```"},"range":{"start":{"line":13,"character":24},"end":{"line":13,"character":30}}},"jsonrpc":"2.0"}Content-Length: 278

{"id":6,"result":{"contents":{"kind":"markdown","value":"### variable `PIN_RST`  \n\n---\nType: `const uint8_t`  \nValue = `8`  \n\n---\n```cpp\nconst uint8_t PIN_RST = WB_IO6\n```"},"range":{"start":{"line":13,"character":14},"end":{"line":13,"character":21}}},"jsonrpc":"2.0"}Content-Length: 124

{"id":7,"result":[{"range":{"start":{"line":13,"character":14},"end":{"line":13,"character":21}},"kind":1}],"jsonrpc":"2.0"}Content-Length: 1772

{"id":8,"result":[{"name":"PIN_SS","kind":13,"range":{"start":{"line":12,"character":0},"end":{"line":12,"character":25}},"selectionRange":{"start":{"line":12,"character":14},"end":{"line":12,"character":20}}},{"name":"PIN_RST","kind":13,"range":{"start":{"line":13,"character":0},"end":{"line":13,"character":30}},"selectionRange":{"start":{"line":13,"character":14},"end":{"line":13,"character":21}}},{"name":"PIN_IRQ","kind":13,"range":{"start":{"line":14,"character":0},"end":{"line":14,"character":30}},"selectionRange":{"start":{"line":14,"character":14},"end":{"line":14,"character":21}}},{"name":"delaySent","kind":13,"range":{"start":{"line":18,"character":0},"end":{"line":18,"character":36}},"selectionRange":{"start":{"line":18,"character":23},"end":{"line":18,"character":32}}},{"name":"sentNum","kind":13,"range":{"start":{"line":19,"character":0},"end":{"line":19,"character":19}},"selectionRange":{"start":{"line":19,"character":8},"end":{"line":19,"character":15}}},{"name":"DEFAULT_CONFIG","kind":13,"range":{"start":{"line":21,"character":0},"end":{"line":33,"character":1}},"selectionRange":{"start":{"line":21,"character":23},"end":{"line":21,"character":37}}},{"name":"setup","kind":12,"range":{"start":{"line":35,"character":0},"end":{"line":80,"character":1}},"selectionRange":{"start":{"line":35,"character":5},"end":{"line":35,"character":10}}},{"name":"transmit","kind":12,"range":{"start":{"line":89,"character":0},"end":{"line":103,"character":1}},"selectionRange":{"start":{"line":89,"character":5},"end":{"line":89,"character":13}}},{"name":"loop","kind":12,"range":{"start":{"line":105,"character":0},"end":{"line":112,"character":1}},"selectionRange":{"start":{"line":105,"character":5},"end":{"line":105,"character":9}}}],"jsonrpc":"2.0"}Content-Length: 1772

{"id":9,"result":[{"name":"PIN_SS","kind":13,"range":{"start":{"line":12,"character":0},"end":{"line":12,"character":25}},"selectionRange":{"start":{"line":12,"character":14},"end":{"line":12,"character":20}}},{"name":"PIN_RST","kind":13,"range":{"start":{"line":13,"character":0},"end":{"line":13,"character":30}},"selectionRange":{"start":{"line":13,"character":14},"end":{"line":13,"character":21}}},{"name":"PIN_IRQ","kind":13,"range":{"start":{"line":14,"character":0},"end":{"line":14,"character":30}},"selectionRange":{"start":{"line":14,"character":14},"end":{"line":14,"character":21}}},{"name":"delaySent","kind":13,"range":{"start":{"line":18,"character":0},"end":{"line":18,"character":36}},"selectionRange":{"start":{"line":18,"character":23},"end":{"line":18,"character":32}}},{"name":"sentNum","kind":13,"range":{"start":{"line":19,"character":0},"end":{"line":19,"character":19}},"selectionRange":{"start":{"line":19,"character":8},"end":{"line":19,"character":15}}},{"name":"DEFAULT_CONFIG","kind":13,"range":{"start":{"line":21,"character":0},"end":{"line":33,"character":1}},"selectionRange":{"start":{"line":21,"character":23},"end":{"line":21,"character":37}}},{"name":"setup","kind":12,"range":{"start":{"line":35,"character":0},"end":{"line":80,"character":1}},"selectionRange":{"start":{"line":35,"character":5},"end":{"line":35,"character":10}}},{"name":"transmit","kind":12,"range":{"start":{"line":89,"character":0},"end":{"line":103,"character":1}},"selectionRange":{"start":{"line":89,"character":5},"end":{"line":89,"character":13}}},{"name":"loop","kind":12,"range":{"start":{"line":105,"character":0},"end":{"line":112,"character":1}},"selectionRange":{"start":{"line":105,"character":5},"end":{"line":105,"character":9}}}],"jsonrpc":"2.0"}Content-Length: 37

{"id":10,"result":[],"jsonrpc":"2.0"}Content-Length: 279

{"id":11,"result":{"contents":{"kind":"markdown","value":"### variable `PIN_RST`  \n\n---\nType: `const uint8_t`  \nValue = `8`  \n\n---\n```cpp\nconst uint8_t PIN_RST = WB_IO6\n```"},"range":{"start":{"line":13,"character":14},"end":{"line":13,"character":21}}},"jsonrpc":"2.0"}Content-Length: 222

{"id":12,"result":[{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino","range":{"start":{"line":13,"character":14},"end":{"line":13,"character":21}}}],"jsonrpc":"2.0"}
<<<
K-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":39,"character":27}}}Content-Length: 63

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":13}}Content-Length: 227

{"jsonrpc":"2.0","id":14,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":39,"character":30}}}Content-Length: 63

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":14}}Content-Length: 227

{"jsonrpc":"2.0","id":15,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":55,"character":33}}}Content-Length: 63

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":15}}Content-Length: 227

{"jsonrpc":"2.0","id":16,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":55,"character":39}}}Content-Length: 63

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":16}}Content-Length: 62

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":7}}Content-Length: 239

{"jsonrpc":"2.0","id":17,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":55,"character":40}}}Content-Length: 62

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":9}}Content-Length: 198

{"jsonrpc":"2.0","id":18,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"}}}Content-Length: 301

{"jsonrpc":"2.0","id":19,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"range":{"start":{"line":55,"character":40},"end":{"line":55,"character":40}},"context":{"diagnostics":[]}}}Content-Length: 63

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":10}}Content-Length: 227

{"jsonrpc":"2.0","id":20,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":55,"character":35}}}Content-Length: 63

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":20}}Content-Length: 325

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino","version":4},"contentChanges":[{"range":{"start":{"line":55,"character":40},"end":{"line":55,"character":40}},"rangeLength":0,"text":"ï¼Œ"}]}}Content-Length: 63

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":17}}Content-Length: 63

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":18}}Content-Length: 63

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":19}}Content-Length: 198

{"jsonrpc":"2.0","id":21,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"}}}Content-Length: 329

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino","version":5},"contentChanges":[{"range":{"start":{"line":55,"character":41},"end":{"line":55,"character":41}},"rangeLength":0,"text":"PIN_RST"}]}}Content-Length: 63

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":21}}Content-Length: 198

{"jsonrpc":"2.0","id":22,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"}}}Conte
>>>
Content-Length: 253

{"id":13,"result":{"contents":{"kind":"markdown","value":"### function `millis`  \n\n---\nâ†’ `unsigned long`  \n\n---\n```cpp\nunsigned long millis()\n```"},"range":{"start":{"line":39,"character":26},"end":{"line":39,"character":32}}},"jsonrpc":"2.0"}Content-Length: 253

{"id":14,"result":{"contents":{"kind":"markdown","value":"### function `millis`  \n\n---\nâ†’ `unsigned long`  \n\n---\n```cpp\nunsigned long millis()\n```"},"range":{"start":{"line":39,"character":26},"end":{"line":39,"character":32}}},"jsonrpc":"2.0"}Content-Length: 770

{"id":15,"result":{"contents":{"kind":"markdown","value":"### function `initializeNoInterrupt`  \n\n---\nâ†’ `void`  \nParameters:  \n- `uint8_t ss`\n- `uint8_t rst = 255`\n\nInitiates and starts a sessions with a DW1000 without interrupt. If rst is not set or value 0xff, a soft resets (i.e. command triggered) are used and it is assumed that no reset line is wired.  \n@param[in] ss The SPI Selection pin used to identify the specific connection  \n@param[in] rst The reset line/pin for hard resets of ICs that connect to the Arduino. Value 0xff means soft reset.  \n\n---\n```cpp\n// In namespace DW1000Ng\nvoid initializeNoInterrupt(uint8_t ss, uint8_t rst = 255)\n```"},"range":{"start":{"line":55,"character":12},"end":{"line":55,"character":33}}},"jsonrpc":"2.0"}Content-Length: 308

{"id":16,"result":{"contents":{"kind":"markdown","value":"### variable `PIN_SS`  \n\n---\nType: `const uint8_t`  \nValue = `17`  \nPassed as ss  \nspi select pin  \n\n---\n```cpp\nconst uint8_t PIN_SS = SS\n```"},"range":{"start":{"line":55,"character":34},"end":{"line":55,"character":40}}},"jsonrpc":"2.0"}Content-Length: 125

{"id":17,"result":[{"range":{"start":{"line":55,"character":12},"end":{"line":55,"character":33}},"kind":1}],"jsonrpc":"2.0"}Content-Length: 1773

{"id":18,"result":[{"name":"PIN_SS","kind":13,"range":{"start":{"line":12,"character":0},"end":{"line":12,"character":25}},"selectionRange":{"start":{"line":12,"character":14},"end":{"line":12,"character":20}}},{"name":"PIN_RST","kind":13,"range":{"start":{"line":13,"character":0},"end":{"line":13,"character":30}},"selectionRange":{"start":{"line":13,"character":14},"end":{"line":13,"character":21}}},{"name":"PIN_IRQ","kind":13,"range":{"start":{"line":14,"character":0},"end":{"line":14,"character":30}},"selectionRange":{"start":{"line":14,"character":14},"end":{"line":14,"character":21}}},{"name":"delaySent","kind":13,"range":{"start":{"line":18,"character":0},"end":{"line":18,"character":36}},"selectionRange":{"start":{"line":18,"character":23},"end":{"line":18,"character":32}}},{"name":"sentNum","kind":13,"range":{"start":{"line":19,"character":0},"end":{"line":19,"character":19}},"selectionRange":{"start":{"line":19,"character":8},"end":{"line":19,"character":15}}},{"name":"DEFAULT_CONFIG","kind":13,"range":{"start":{"line":21,"character":0},"end":{"line":33,"character":1}},"selectionRange":{"start":{"line":21,"character":23},"end":{"line":21,"character":37}}},{"name":"setup","kind":12,"range":{"start":{"line":35,"character":0},"end":{"line":80,"character":1}},"selectionRange":{"start":{"line":35,"character":5},"end":{"line":35,"character":10}}},{"name":"transmit","kind":12,"range":{"start":{"line":89,"character":0},"end":{"line":103,"character":1}},"selectionRange":{"start":{"line":89,"character":5},"end":{"line":89,"character":13}}},{"name":"loop","kind":12,"range":{"start":{"line":105,"character":0},"end":{"line":112,"character":1}},"selectionRange":{"start":{"line":105,"character":5},"end":{"line":105,"character":9}}}],"jsonrpc":"2.0"}Content-Length: 37

{"id":19,"result":[],"jsonrpc":"2.0"}Content-Length: 308

{"id":20,"result":{"contents":{"kind":"markdown","value":"### variable `PIN_SS`  \n\n---\nType: `const uint8_t`  \nValue = `17`  \nPassed as ss  \nspi select pin  \n\n---\n```cpp\nconst uint8_t PIN_SS = SS\n```"},"range":{"start":{"line":55,"character":34},"end":{"line":55,"character":40}}},"jsonrpc":"2.0"}Content-Length: 1773

{"id":21,"result":[{"name":"PIN_SS","kind":13,"range":{"start":{"line":12,"character":0},"end":{"line":12,"character":25}},"selectionRange":{"start":{"line":12,"character":14},"end":{"line":12,"character":20}}},{"name":"PIN_RST","kind":13,"range":{"start":{"line":13,"character":0},"end":{"line":13,"character":30}},"selectionRange":{"start":{"line":13,"character":14},"end":{"line":13,"character":21}}},{"name":"PIN_IRQ","kind":13,"range":{"start":{"line":14,"character":0},"end":{"line":14,"character":30}},"selectionRange":{"start":{"line":14,"character":14},"end":{"line":14,"character":21}}},{"name":"delaySent","kind":13,"range":{"start":{"line":18,"character":0},"end":{"line":18,"character":36}},"selectionRange":{"start":{"line":18,"character":23},"end":{"line":18,"character":32}}},{"name":"sentNum","kind":13,"range":{"start":{"line":19,"character":0},"end":{"line":19,"character":19}},"selectionRange":{"start":{"line":19,"character":8},"end":{"line":19,"character":15}}},{"name":"DEFAULT_CONFIG","kind":13,"range":{"start":{"line":21,"character":0},"end":{"line":33,"character":1}},"selectionRange":{"start":{"line":21,"character":23},"end":{"line":21,"character":37}}},{"name":"setup","kind":12,"range":{"start":{"line":35,"character":0},"end":{"line":80,"character":1}},"selectionRange":{"start":{"line":35,"character":5},"end":{"line":35,"character":10}}},{"name":"transmit","kind":12,"range":{"start":{"line":89,"character":0},"end":{"line":103,"character":1}},"selectionRange":{"start":{"line":89,"character":5},"end":{"line":89,"character":13}}},{"name":"loop","kind":12,"range":{"start":{"line":105,"character":0},"end":{"line":112,"character":1}},"selectionRange":{"start":{"line":105,"character":5},"end":{"line":105,"character":9}}}],"jsonrpc":"2.0"}Content-Length: 1773

{"id":22,"result":[{"name":"PIN_SS","kind":13,"range":{"start":{"line":12,"character":0},"end":{"line":12,"character":25}},"selectionRange":{"start":{"line":12,"character":14},"end":{"line":12,"character":20}}},{"name":"PIN_RST","kind":13,"range":{"start":{"line":13,"character":0},"end":{"line":13,"character":30}},"selectionRange":{"start":{"line":13,"character":14},"end":{"line":13,"character":21}}},{"name":"PIN_IRQ","kind":13,"range":{"start":{"line":14,"character":0},"end":{"line":14,"character":30}},"selectionRange":{"start":{"line":14,"character":14},"end":{"line":14,"character":21}}},{"name":"delaySent","kind":13,"range":{"start":{"line":18,"character":0},"end":{"line":18,"character":36}},"selectionRange":{"start":{"line":18,"character":23},"end":{"line":18,"character":32}}},{"name":"sentNum","kind":13,"range":{"start":{"line":19,"character":0},"end":{"line":19,"character":19}},"selectionRange":{"start":{"line":19,"character":8},"end":{"line":19,"character":15}}},{"name":"DEFAULT_CONFIG","kind":13,"range":{"start":{"line":21,"character":0},"end":{"line":33,"character":1}},"selectionRange":{"start":{"line":21,"character":23},"end":{"line":21,"character":37}}},{"name":"setup","kind":12,"range":{"start":{"line":35,"character":0},"end":{"line":80,"character":1}},"selectionRange":{"start":{"line":35,"character":5},"end":{"line":35,"character":10}}},{"name":"transmit","kind":12,"range":{"start":{"line":89,"character":0},"end":{"line":103,"character":1}},"selectionRange":{"start":{"line":89,"character":5},"end":{"line":89,"character":13}}},{"name":"loop","kind":12,"range":{"start":{"line":105,"character":0},"end":{"line":112,"character":1}},"selectionRange":{"start":{"line":105,"character":5},"end":{"line":105,"character":9}}}],"jsonrpc":"2.0"}
<<<
nt-Length: 301

{"jsonrpc":"2.0","id":23,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"range":{"start":{"line":55,"character":48},"end":{"line":55,"character":48}},"context":{"diagnostics":[]}}}Content-Length: 195

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino","version":5}}}Content-Length: 227

{"jsonrpc":"2.0","id":24,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":55,"character":41}}}Content-Length: 63

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":24}}Content-Length: 239

{"jsonrpc":"2.0","id":25,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":55,"character":40}}}Content-Length: 63

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":22}}Content-Length: 198

{"jsonrpc":"2.0","id":26,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"}}}Content-Length: 301

{"jsonrpc":"2.0","id":27,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"range":{"start":{"line":55,"character":40},"end":{"line":55,"character":40}},"context":{"diagnostics":[]}}}Content-Length: 63

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":23}}Content-Length: 227

{"jsonrpc":"2.0","id":28,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":55,"character":40}}}Content-Length: 63

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":26}}Content-Length: 63

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":28}}Content-Length: 198

{"jsonrpc":"2.0","id":29,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"}}}Content-Length: 301

{"jsonrpc":"2.0","id":30,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"range":{"start":{"line":55,"character":41},"end":{"line":55,"character":41}},"context":{"diagnostics":[]}}}Content-Length: 63

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":27}}Content-Length: 227

{"jsonrpc":"2.0","id":31,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":55,"character":40}}}Content-Length: 322

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino","version":6},"contentChanges":[{"range":{"start":{"line":55,"character":40},"end":{"line":55,"character":41}},"rangeLength":1,"text":""}]}}Content-Length: 63

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":25}}Content-Length: 63

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":29}}Content-Length: 63

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":30}}Content-Length: 198

{"jsonrpc":"2.0","id":32,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"}}}Content-Length: 301

{"jsonrpc":"2.0","id":33,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:
>>>
Content-Length: 37

{"id":23,"result":[],"jsonrpc":"2.0"}Content-Length: 39

{"id":24,"result":null,"jsonrpc":"2.0"}Content-Length: 37

{"id":25,"result":[],"jsonrpc":"2.0"}Content-Length: 1773

{"id":26,"result":[{"name":"PIN_SS","kind":13,"range":{"start":{"line":12,"character":0},"end":{"line":12,"character":25}},"selectionRange":{"start":{"line":12,"character":14},"end":{"line":12,"character":20}}},{"name":"PIN_RST","kind":13,"range":{"start":{"line":13,"character":0},"end":{"line":13,"character":30}},"selectionRange":{"start":{"line":13,"character":14},"end":{"line":13,"character":21}}},{"name":"PIN_IRQ","kind":13,"range":{"start":{"line":14,"character":0},"end":{"line":14,"character":30}},"selectionRange":{"start":{"line":14,"character":14},"end":{"line":14,"character":21}}},{"name":"delaySent","kind":13,"range":{"start":{"line":18,"character":0},"end":{"line":18,"character":36}},"selectionRange":{"start":{"line":18,"character":23},"end":{"line":18,"character":32}}},{"name":"sentNum","kind":13,"range":{"start":{"line":19,"character":0},"end":{"line":19,"character":19}},"selectionRange":{"start":{"line":19,"character":8},"end":{"line":19,"character":15}}},{"name":"DEFAULT_CONFIG","kind":13,"range":{"start":{"line":21,"character":0},"end":{"line":33,"character":1}},"selectionRange":{"start":{"line":21,"character":23},"end":{"line":21,"character":37}}},{"name":"setup","kind":12,"range":{"start":{"line":35,"character":0},"end":{"line":80,"character":1}},"selectionRange":{"start":{"line":35,"character":5},"end":{"line":35,"character":10}}},{"name":"transmit","kind":12,"range":{"start":{"line":89,"character":0},"end":{"line":103,"character":1}},"selectionRange":{"start":{"line":89,"character":5},"end":{"line":89,"character":13}}},{"name":"loop","kind":12,"range":{"start":{"line":105,"character":0},"end":{"line":112,"character":1}},"selectionRange":{"start":{"line":105,"character":5},"end":{"line":105,"character":9}}}],"jsonrpc":"2.0"}Content-Length: 37

{"id":27,"result":[],"jsonrpc":"2.0"}Content-Length: 39

{"id":28,"result":null,"jsonrpc":"2.0"}Content-Length: 1773

{"id":29,"result":[{"name":"PIN_SS","kind":13,"range":{"start":{"line":12,"character":0},"end":{"line":12,"character":25}},"selectionRange":{"start":{"line":12,"character":14},"end":{"line":12,"character":20}}},{"name":"PIN_RST","kind":13,"range":{"start":{"line":13,"character":0},"end":{"line":13,"character":30}},"selectionRange":{"start":{"line":13,"character":14},"end":{"line":13,"character":21}}},{"name":"PIN_IRQ","kind":13,"range":{"start":{"line":14,"character":0},"end":{"line":14,"character":30}},"selectionRange":{"start":{"line":14,"character":14},"end":{"line":14,"character":21}}},{"name":"delaySent","kind":13,"range":{"start":{"line":18,"character":0},"end":{"line":18,"character":36}},"selectionRange":{"start":{"line":18,"character":23},"end":{"line":18,"character":32}}},{"name":"sentNum","kind":13,"range":{"start":{"line":19,"character":0},"end":{"line":19,"character":19}},"selectionRange":{"start":{"line":19,"character":8},"end":{"line":19,"character":15}}},{"name":"DEFAULT_CONFIG","kind":13,"range":{"start":{"line":21,"character":0},"end":{"line":33,"character":1}},"selectionRange":{"start":{"line":21,"character":23},"end":{"line":21,"character":37}}},{"name":"setup","kind":12,"range":{"start":{"line":35,"character":0},"end":{"line":80,"character":1}},"selectionRange":{"start":{"line":35,"character":5},"end":{"line":35,"character":10}}},{"name":"transmit","kind":12,"range":{"start":{"line":89,"character":0},"end":{"line":103,"character":1}},"selectionRange":{"start":{"line":89,"character":5},"end":{"line":89,"character":13}}},{"name":"loop","kind":12,"range":{"start":{"line":105,"character":0},"end":{"line":112,"character":1}},"selectionRange":{"start":{"line":105,"character":5},"end":{"line":105,"character":9}}}],"jsonrpc":"2.0"}Content-Length: 37

{"id":30,"result":[],"jsonrpc":"2.0"}Content-Length: 39

{"id":31,"result":null,"jsonrpc":"2.0"}Content-Length: 1773

{"id":32,"result":[{"name":"PIN_SS","kind":13,"range":{"start":{"line":12,"character":0},"end":{"line":12,"character":25}},"selectionRange":{"start":{"line":12,"character":14},"end":{"line":12,"character":20}}},{"name":"PIN_RST","kind":13,"range":{"start":{"line":13,"character":0},"end":{"line":13,"character":30}},"selectionRange":{"start":{"line":13,"character":14},"end":{"line":13,"character":21}}},{"name":"PIN_IRQ","kind":13,"range":{"start":{"line":14,"character":0},"end":{"line":14,"character":30}},"selectionRange":{"start":{"line":14,"character":14},"end":{"line":14,"character":21}}},{"name":"delaySent","kind":13,"range":{"start":{"line":18,"character":0},"end":{"line":18,"character":36}},"selectionRange":{"start":{"line":18,"character":23},"end":{"line":18,"character":32}}},{"name":"sentNum","kind":13,"range":{"start":{"line":19,"character":0},"end":{"line":19,"character":19}},"selectionRange":{"start":{"line":19,"character":8},"end":{"line":19,"character":15}}},{"name":"DEFAULT_CONFIG","kind":13,"range":{"start":{"line":21,"character":0},"end":{"line":33,"character":1}},"selectionRange":{"start":{"line":21,"character":23},"end":{"line":21,"character":37}}},{"name":"setup","kind":12,"range":{"start":{"line":35,"character":0},"end":{"line":80,"character":1}},"selectionRange":{"start":{"line":35,"character":5},"end":{"line":35,"character":10}}},{"name":"transmit","kind":12,"range":{"start":{"line":89,"character":0},"end":{"line":103,"character":1}},"selectionRange":{"start":{"line":89,"character":5},"end":{"line":89,"character":13}}},{"name":"loop","kind":12,"range":{"start":{"line":105,"character":0},"end":{"line":112,"character":1}},"selectionRange":{"start":{"line":105,"character":5},"end":{"line":105,"character":9}}}],"jsonrpc":"2.0"}
<<<
///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"range":{"start":{"line":55,"character":40},"end":{"line":55,"character":40}},"context":{"diagnostics":[]}}}Content-Length: 63

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":31}}Content-Length: 323

{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino","version":7},"contentChanges":[{"range":{"start":{"line":55,"character":40},"end":{"line":55,"character":40}},"rangeLength":0,"text":","}]}}Content-Length: 63

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":32}}Content-Length: 63

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":33}}Content-Length: 198

{"jsonrpc":"2.0","id":34,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"}}}Content-Length: 306

{"jsonrpc":"2.0","id":35,"method":"textDocument/signatureHelp","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":55,"character":41},"context":{"isRetrigger":false,"triggerCharacter":",","triggerKind":2}}}Content-Length: 301

{"jsonrpc":"2.0","id":36,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"range":{"start":{"line":55,"character":41},"end":{"line":55,"character":41}},"context":{"diagnostics":[]}}}Content-Length: 195

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino","version":7}}}Content-Length: 63

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":35}}Content-Length: 63

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":34}}Content-Length: 198

{"jsonrpc":"2.0","id":37,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"}}}Content-Length: 63

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":36}}Content-Length: 38

{"jsonrpc":"2.0","id":0,"result":null}
>>>
Content-Length: 37

{"id":33,"result":[],"jsonrpc":"2.0"}Content-Length: 1773

{"id":34,"result":[{"name":"PIN_SS","kind":13,"range":{"start":{"line":12,"character":0},"end":{"line":12,"character":25}},"selectionRange":{"start":{"line":12,"character":14},"end":{"line":12,"character":20}}},{"name":"PIN_RST","kind":13,"range":{"start":{"line":13,"character":0},"end":{"line":13,"character":30}},"selectionRange":{"start":{"line":13,"character":14},"end":{"line":13,"character":21}}},{"name":"PIN_IRQ","kind":13,"range":{"start":{"line":14,"character":0},"end":{"line":14,"character":30}},"selectionRange":{"start":{"line":14,"character":14},"end":{"line":14,"character":21}}},{"name":"delaySent","kind":13,"range":{"start":{"line":18,"character":0},"end":{"line":18,"character":36}},"selectionRange":{"start":{"line":18,"character":23},"end":{"line":18,"character":32}}},{"name":"sentNum","kind":13,"range":{"start":{"line":19,"character":0},"end":{"line":19,"character":19}},"selectionRange":{"start":{"line":19,"character":8},"end":{"line":19,"character":15}}},{"name":"DEFAULT_CONFIG","kind":13,"range":{"start":{"line":21,"character":0},"end":{"line":33,"character":1}},"selectionRange":{"start":{"line":21,"character":23},"end":{"line":21,"character":37}}},{"name":"setup","kind":12,"range":{"start":{"line":35,"character":0},"end":{"line":80,"character":1}},"selectionRange":{"start":{"line":35,"character":5},"end":{"line":35,"character":10}}},{"name":"transmit","kind":12,"range":{"start":{"line":89,"character":0},"end":{"line":103,"character":1}},"selectionRange":{"start":{"line":89,"character":5},"end":{"line":89,"character":13}}},{"name":"loop","kind":12,"range":{"start":{"line":105,"character":0},"end":{"line":112,"character":1}},"selectionRange":{"start":{"line":105,"character":5},"end":{"line":105,"character":9}}}],"jsonrpc":"2.0"}Content-Length: 182

{"id":35,"error":{"code":0,"message":"json: cannot unmarshal array into Go struct field ParameterInformation.signatures.parameters.label of type string","data":null},"jsonrpc":"2.0"}Content-Length: 37

{"id":36,"result":[],"jsonrpc":"2.0"}Content-Length: 1773

{"id":37,"result":[{"name":"PIN_SS","kind":13,"range":{"start":{"line":12,"character":0},"end":{"line":12,"character":25}},"selectionRange":{"start":{"line":12,"character":14},"end":{"line":12,"character":20}}},{"name":"PIN_RST","kind":13,"range":{"start":{"line":13,"character":0},"end":{"line":13,"character":30}},"selectionRange":{"start":{"line":13,"character":14},"end":{"line":13,"character":21}}},{"name":"PIN_IRQ","kind":13,"range":{"start":{"line":14,"character":0},"end":{"line":14,"character":30}},"selectionRange":{"start":{"line":14,"character":14},"end":{"line":14,"character":21}}},{"name":"delaySent","kind":13,"range":{"start":{"line":18,"character":0},"end":{"line":18,"character":36}},"selectionRange":{"start":{"line":18,"character":23},"end":{"line":18,"character":32}}},{"name":"sentNum","kind":13,"range":{"start":{"line":19,"character":0},"end":{"line":19,"character":19}},"selectionRange":{"start":{"line":19,"character":8},"end":{"line":19,"character":15}}},{"name":"DEFAULT_CONFIG","kind":13,"range":{"start":{"line":21,"character":0},"end":{"line":33,"character":1}},"selectionRange":{"start":{"line":21,"character":23},"end":{"line":21,"character":37}}},{"name":"setup","kind":12,"range":{"start":{"line":35,"character":0},"end":{"line":80,"character":1}},"selectionRange":{"start":{"line":35,"character":5},"end":{"line":35,"character":10}}},{"name":"transmit","kind":12,"range":{"start":{"line":89,"character":0},"end":{"line":103,"character":1}},"selectionRange":{"start":{"line":89,"character":5},"end":{"line":89,"character":13}}},{"name":"loop","kind":12,"range":{"start":{"line":105,"character":0},"end":{"line":112,"character":1}},"selectionRange":{"start":{"line":105,"character":5},"end":{"line":105,"character":9}}}],"jsonrpc":"2.0"}Content-Length: 143

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"title":"indexing","percentage":0,"kind":"begin"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"3/36","percentage":8.333333333333334,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"4/36","percentage":11.11111111111111,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"4/36","percentage":11.11111111111111,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 116

{"method":"window/workDoneProgress/create","params":{"token":"arduinoLanguageServerRebuild"},"id":1,"jsonrpc":"2.0"}
<<<
Content-Length: 38

{"jsonrpc":"2.0","id":1,"result":null}
>>>
Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"title":"Building sketch","kind":"begin"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"5/36","percentage":13.88888888888889,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"6/36","percentage":16.666666666666668,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"6/36","percentage":16.666666666666668,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"7/36","percentage":19.444444444444443,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"8/36","percentage":22.22222222222222,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"8/36","percentage":22.22222222222222,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 143

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"9/36","percentage":25,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"10/36","percentage":27.77777777777778,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"10/36","percentage":27.77777777777778,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"11/36","percentage":30.555555555555557,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"11/36","percentage":30.555555555555557,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"12/36","percentage":33.333333333333336,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"13/36","percentage":36.111111111111114,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"13/36","percentage":36.111111111111114,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"14/36","percentage":38.888888888888886,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"15/36","percentage":41.666666666666664,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"16/36","percentage":44.44444444444444,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"17/36","percentage":47.22222222222222,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 144

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"18/36","percentage":50,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 144

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"18/36","percentage":50,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"19/36","percentage":52.77777777777778,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"19/36","percentage":52.77777777777778,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"20/36","percentage":55.55555555555556,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"20/36","percentage":55.55555555555556,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"21/36","percentage":58.333333333333336,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"21/36","percentage":58.333333333333336,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"22/36","percentage":61.111111111111114,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"22/36","percentage":61.111111111111114,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"23/36","percentage":63.888888888888886,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"23/36","percentage":63.888888888888886,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"24/36","percentage":66.66666666666667,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"24/36","percentage":66.66666666666667,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"25/36","percentage":69.44444444444444,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"26/36","percentage":72.22222222222223,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 144

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"27/36","percentage":75,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 144

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"27/36","percentage":75,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"28/36","percentage":77.77777777777777,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"28/36","percentage":77.77777777777777,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"29/36","percentage":80.55555555555556,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"29/36","percentage":80.55555555555556,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"30/36","percentage":83.33333333333333,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"30/36","percentage":83.33333333333333,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"31/36","percentage":86.11111111111111,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"32/36","percentage":88.88888888888889,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"32/36","percentage":88.88888888888889,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"33/36","percentage":91.66666666666667,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"34/36","percentage":94.44444444444444,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"35/36","percentage":97.22222222222223,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 107

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"kind":"end"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}
<<<
Content-Length: 227

{"jsonrpc":"2.0","id":38,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":65,"character":31}}}
>>>
Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 138

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling.","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 139

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling..","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 140

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"compiling...","kind":"report"}},"jsonrpc":"2.0"}Content-Length: 129

{"method":"$/progress","params":{"token":"arduinoLanguageServerRebuild","value":{"message":"done","kind":"end"}},"jsonrpc":"2.0"}Content-Length: 193

{"id":38,"error":{"code":0,"message":"Document is not available: file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 63

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":38}}
>>>
Content-Length: 607

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino","diagnostics":[{"range":{"start":{"line":43,"character":2},"end":{"line":43,"character":8}},"severity":1,"code":"unknown_typename_suggest","source":"clang","message":"Unknown type name 'time_t'; did you mean 'size_t'? (fix available)\n\nc:\\Users\\ltp\\AppData\\Local\\Programs\\Arduino IDE\\resources\\app\\node_modules\\arduino-ide-extension\\build\\lib\\clang\\12.0.0\\include\\stddef.h:46:23:\nnote: 'size_t' declared here"}]},"jsonrpc":"2.0"}Content-Length: 111

{"method":"window/workDoneProgress/create","params":{"token":"backgroundIndexProgress"},"id":2,"jsonrpc":"2.0"}
<<<
Content-Length: 38

{"jsonrpc":"2.0","id":2,"result":null}
>>>
Content-Length: 143

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"title":"indexing","percentage":0,"kind":"begin"}},"jsonrpc":"2.0"}Content-Length: 141

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"0/1","percentage":0,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 837

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino","diagnostics":[{"range":{"start":{"line":43,"character":2},"end":{"line":43,"character":8}},"severity":1,"code":"unknown_typename_suggest","source":"clang","message":"Unknown type name 'time_t'; did you mean 'size_t'? (fix available)\n\nc:\\Users\\ltp\\AppData\\Local\\Programs\\Arduino IDE\\resources\\app\\node_modules\\arduino-ide-extension\\build\\lib\\clang\\12.0.0\\include\\stddef.h:46:23:\nnote: 'size_t' declared here"},{"range":{"start":{"line":12,"character":14},"end":{"line":12,"character":20}},"severity":3,"message":"'PIN_SS' declared here\n\nBasicSender.ino.cpp:65:35: error: use of undeclared identifier 'PIN_SSï¼Œ'; did you mean 'PIN_SS'?"}]},"jsonrpc":"2.0"}Content-Length: 141

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"0/1","percentage":0,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 107

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"kind":"end"}},"jsonrpc":"2.0"}Content-Length: 1153

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino","diagnostics":[{"range":{"start":{"line":39,"character":2},"end":{"line":39,"character":8}},"severity":1,"code":"unknown_typename_suggest","source":"clang","message":"Unknown type name 'time_t'; did you mean 'size_t'? (fix available)\n\nc:\\Users\\ltp\\AppData\\Local\\Programs\\Arduino IDE\\resources\\app\\node_modules\\arduino-ide-extension\\build\\lib\\clang\\12.0.0\\include\\stddef.h:46:23:\nnote: 'size_t' declared here"},{"range":{"start":{"line":56,"character":0},"end":{"line":56,"character":0}},"severity":1,"code":"expected_expression","source":"clang","message":"Expected expression"},{"range":{"start":{"line":56,"character":0},"end":{"line":56,"character":0}},"severity":1,"code":"expected","source":"clang","message":"Expected '}'\n\nBasicSender.ino.cpp:41:14: note: to match this '{'"},{"range":{"start":{"line":35,"character":13},"end":{"line":35,"character":14}},"severity":3,"message":"To match this '{'\n\nBasicSender.ino.cpp:62:1: error: expected '}'"}]},"jsonrpc":"2.0"}
<<<
Content-Length: 227

{"jsonrpc":"2.0","id":39,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":59,"character":25}}}
>>>
Content-Length: 193

{"id":39,"error":{"code":0,"message":"Document is not available: file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 226

{"jsonrpc":"2.0","id":40,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":55,"character":3}}}
>>>
Content-Length: 39

{"id":40,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 227

{"jsonrpc":"2.0","id":41,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":35,"character":13}}}
>>>
Content-Length: 39

{"id":41,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 492

{"jsonrpc":"2.0","id":42,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"range":{"start":{"line":35,"character":13},"end":{"line":35,"character":14}},"context":{"diagnostics":[{"range":{"start":{"line":35,"character":13},"end":{"line":35,"character":14}},"message":"To match this '{'\n\nBasicSender.ino.cpp:62:1: error: expected '}'","severity":3}],"only":["quickfix"]}}}
>>>
Content-Length: 37

{"id":42,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 227

{"jsonrpc":"2.0","id":43,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":94,"character":43}}}
>>>
Content-Length: 193

{"id":43,"error":{"code":0,"message":"Document is not available: file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino","data":null},"jsonrpc":"2.0"}
<<<
Content-Length: 59

{"jsonrpc":"2.0","id":44,"method":"shutdown","params":null}
>>>
Content-Length: 39

{"id":44,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 47

{"jsonrpc":"2.0","method":"exit","params":null}






Started logging.

<<<
Content-Length: 3141

{"jsonrpc":"2.0","id":0,"method":"initialize","params":{"processId":38832,"clientInfo":{"name":"vscode","version":"1.53.2"},"rootPath":"d:\\RAK-Work\\20210707\\RAK13801\\RAK13801-UWB-Library\\examples\\BasicSender","rootUri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender","capabilities":{"workspace":{"applyEdit":true,"workspaceEdit":{"documentChanges":true,"resourceOperations":["create","rename","delete"],"failureHandling":"textOnlyTransactional"},"didChangeConfiguration":{"dynamicRegistration":true},"didChangeWatchedFiles":{"dynamicRegistration":true},"symbol":{"dynamicRegistration":true,"symbolKind":{"valueSet":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]}},"executeCommand":{"dynamicRegistration":true},"configuration":true,"workspaceFolders":true},"textDocument":{"publishDiagnostics":{"relatedInformation":true,"versionSupport":false,"tagSupport":{"valueSet":[1,2]}},"synchronization":{"dynamicRegistration":true,"willSave":true,"willSaveWaitUntil":true,"didSave":true},"completion":{"dynamicRegistration":true,"contextSupport":true,"completionItem":{"snippetSupport":true,"commitCharactersSupport":true,"documentationFormat":["markdown","plaintext"],"deprecatedSupport":true,"preselectSupport":true,"tagSupport":{"valueSet":[1]}},"completionItemKind":{"valueSet":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25]}},"hover":{"dynamicRegistration":true,"contentFormat":["markdown","plaintext"]},"signatureHelp":{"dynamicRegistration":true,"signatureInformation":{"documentationFormat":["markdown","plaintext"],"parameterInformation":{"labelOffsetSupport":true}},"contextSupport":true},"definition":{"dynamicRegistration":true,"linkSupport":true},"references":{"dynamicRegistration":true},"documentHighlight":{"dynamicRegistration":true},"documentSymbol":{"dynamicRegistration":true,"symbolKind":{"valueSet":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]},"hierarchicalDocumentSymbolSupport":true},"codeAction":{"dynamicRegistration":true,"isPreferredSupport":true,"codeActionLiteralSupport":{"codeActionKind":{"valueSet":["","quickfix","refactor","refactor.extract","refactor.inline","refactor.rewrite","source","source.organizeImports"]}}},"codeLens":{"dynamicRegistration":true},"formatting":{"dynamicRegistration":true},"rangeFormatting":{"dynamicRegistration":true},"onTypeFormatting":{"dynamicRegistration":true},"rename":{"dynamicRegistration":true,"prepareSupport":true},"documentLink":{"dynamicRegistration":true,"tooltipSupport":true},"typeDefinition":{"dynamicRegistration":true,"linkSupport":true},"implementation":{"dynamicRegistration":true,"linkSupport":true},"colorProvider":{"dynamicRegistration":true},"foldingRange":{"dynamicRegistration":true,"rangeLimit":5000,"lineFoldingOnly":true},"declaration":{"dynamicRegistration":true,"linkSupport":true},"selectionRange":{"dynamicRegistration":true}},"window":{"workDoneProgress":true}},"initializationOptions":{},"trace":"off","workspaceFolders":[{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender","name":"BasicSender"}]}}
>>>
Content-Length: 598

{"id":0,"result":{"capabilities":{"textDocumentSync":2,"hoverProvider":true,"completionProvider":{"triggerCharacters":[".","\u003e",":"]},"signatureHelpProvider":{"triggerCharacters":["(",","]},"definitionProvider":true,"documentHighlightProvider":true,"documentSymbolProvider":true,"workspaceSymbolProvider":true,"codeActionProvider":true,"documentFormattingProvider":true,"documentRangeFormattingProvider":true,"documentOnTypeFormattingProvider":{"firstTriggerCharacter":"\n"},"renameProvider":false,"executeCommandProvider":{"commands":["clangd.applyFix","clangd.applyTweak"]}}},"jsonrpc":"2.0"}
<<<
Content-Length: 52

{"jsonrpc":"2.0","method":"initialized","params":{}}Content-Length: 3563

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino","languageId":"cpp","version":1,"text":"/**\r\n   @file BasicSender.ino\r\n   @author rakwireless.com\r\n   @brief UWB transmit sender\r\n   @version 0.1\r\n   @date 2022-1-28\r\n   @copyright Copyright (c) 2020\r\n**/\r\n\r\n#include <SPI.h>\r\n#include <DW1000Ng.hpp>\r\n\r\nconst uint8_t PIN_SS = SS; // spi select pin\r\nconst uint8_t PIN_RST = WB_IO6;\r\nconst uint8_t PIN_IRQ = WB_IO5;\r\n\r\n\r\n// DEBUG packet sent status and count\r\nvolatile unsigned long delaySent = 0;\r\nint16_t sentNum = 0; // todo check int type\r\n\r\ndevice_configuration_t DEFAULT_CONFIG = {\r\n    false,\r\n    true,\r\n    true,\r\n    true,\r\n    false,\r\n    SFDMode::STANDARD_SFD,\r\n    Channel::CHANNEL_5,\r\n    DataRate::RATE_850KBPS,\r\n    PulseFrequency::FREQ_16MHZ,\r\n    PreambleLength::LEN_256,\r\n    PreambleCode::CODE_3\r\n};\r\n\r\nvoid setup() {\r\n  pinMode(WB_IO2, OUTPUT);\r\n  digitalWrite(WB_IO2, HIGH); //Turn on the power switch\r\n  delay(300);\r\n  time_t serial_timeout = millis();\r\n  // DEBUG monitoring\r\n  Serial.begin(115200);\r\n  while (!Serial)\r\n  {\r\n    if ((millis() - serial_timeout) < 5000)\r\n    {\r\n      delay(100);\r\n    }\r\n    else\r\n    {\r\n      break;\r\n    }\r\n  }\r\n  Serial.println(F(\"### DW1000Ng-arduino-sender-test ###\"));\r\n  // initialize the driver\r\n  DW1000Ng::initializeNoInterrupt(PIN_SS,PIN_RST);\r\n  Serial.println(F(\"DW1000Ng initialized ...\"));\r\n\r\n  DW1000Ng::applyConfiguration(DEFAULT_CONFIG);\r\n\t//DW1000Ng::applyInterruptConfiguration(DEFAULT_INTERRUPT_CONFIG);\r\n\r\n  DW1000Ng::setDeviceAddress(5);\r\n  DW1000Ng::setNetworkId(10);\r\n\r\n  DW1000Ng::setAntennaDelay(16436);\r\n  Serial.println(F(\"Committed configuration ...\"));\r\n  // DEBUG chip info and registers pretty printed\r\n  char msg[128];\r\n  DW1000Ng::getPrintableDeviceIdentifier(msg);\r\n  Serial.print(\"Device ID: \"); Serial.println(msg);\r\n  DW1000Ng::getPrintableExtendedUniqueIdentifier(msg);\r\n  Serial.print(\"Unique ID: \"); Serial.println(msg);\r\n  DW1000Ng::getPrintableNetworkIdAndShortAddress(msg);\r\n  Serial.print(\"Network ID & Device Address: \"); Serial.println(msg);\r\n  DW1000Ng::getPrintableDeviceMode(msg);\r\n  Serial.print(\"Device mode: \"); Serial.println(msg);\r\n  // attach callback for (successfully) sent messages\r\n  //DW1000Ng::attachSentHandler(handleSent);\r\n  // start a transmission\r\n  transmit();\r\n}\r\n\r\n/*\r\nvoid handleSent() {\r\n  // status change on sent success\r\n  sentAck = true;\r\n}\r\n*/\r\n\r\nvoid transmit() {\r\n  // transmit some data\r\n  Serial.print(\"Transmitting packet ... #\"); Serial.println(sentNum);\r\n  String msg = \"Hello DW1000Ng, it's #\"; msg += sentNum;\r\n  DW1000Ng::setTransmitData(msg);\r\n  // delay sending the message for the given amount\r\n  delay(1000);\r\n  DW1000Ng::startTransmit(TransmitMode::IMMEDIATE);\r\n  delaySent = millis();\r\n  while(!DW1000Ng::isTransmitDone()) {\r\n\r\n  }\r\n  sentNum++;\r\n  DW1000Ng::clearTransmitStatus();\r\n}\r\n\r\nvoid loop() {\r\n    transmit();\r\n    // update and print some information about the sent message\r\n    Serial.print(\"ARDUINO delay sent [ms] ... \"); Serial.println(millis() - delaySent);\r\n    uint64_t newSentTime = DW1000Ng::getTransmitTimestamp();\r\n    Serial.print(\"Processed packet ... #\"); Serial.println(sentNum);\r\n    Serial.println();\r\n}\r\n"}}}Content-Length: 296

{"jsonrpc":"2.0","id":1,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}Content-Length: 197

{"jsonrpc":"2.0","id":2,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"}}}Content-Length: 225

{"jsonrpc":"2.0","id":3,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":6,"character":29}}}Content-Length: 62

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":3}}Content-Length: 226

{"jsonrpc":"2.0","id":4,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":56,"character":17}}}Content-Length: 62

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":4}}Content-Length: 226

{"jsonrpc":"2.0","id":5,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":55,"character":18}}}Content-Length: 62

{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":5}}
>>>
Content-Length: 111

{"method":"window/workDoneProgress/create","params":{"token":"backgroundIndexProgress"},"id":0,"jsonrpc":"2.0"}Content-Length: 36

{"id":1,"result":[],"jsonrpc":"2.0"}Content-Length: 607

{"method":"textDocument/publishDiagnostics","params":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino","diagnostics":[{"range":{"start":{"line":39,"character":2},"end":{"line":39,"character":8}},"severity":1,"code":"unknown_typename_suggest","source":"clang","message":"Unknown type name 'time_t'; did you mean 'size_t'? (fix available)\n\nc:\\Users\\ltp\\AppData\\Local\\Programs\\Arduino IDE\\resources\\app\\node_modules\\arduino-ide-extension\\build\\lib\\clang\\12.0.0\\include\\stddef.h:46:23:\nnote: 'size_t' declared here"}]},"jsonrpc":"2.0"}Content-Length: 1772

{"id":2,"result":[{"name":"PIN_SS","kind":13,"range":{"start":{"line":12,"character":0},"end":{"line":12,"character":25}},"selectionRange":{"start":{"line":12,"character":14},"end":{"line":12,"character":20}}},{"name":"PIN_RST","kind":13,"range":{"start":{"line":13,"character":0},"end":{"line":13,"character":30}},"selectionRange":{"start":{"line":13,"character":14},"end":{"line":13,"character":21}}},{"name":"PIN_IRQ","kind":13,"range":{"start":{"line":14,"character":0},"end":{"line":14,"character":30}},"selectionRange":{"start":{"line":14,"character":14},"end":{"line":14,"character":21}}},{"name":"delaySent","kind":13,"range":{"start":{"line":18,"character":0},"end":{"line":18,"character":36}},"selectionRange":{"start":{"line":18,"character":23},"end":{"line":18,"character":32}}},{"name":"sentNum","kind":13,"range":{"start":{"line":19,"character":0},"end":{"line":19,"character":19}},"selectionRange":{"start":{"line":19,"character":8},"end":{"line":19,"character":15}}},{"name":"DEFAULT_CONFIG","kind":13,"range":{"start":{"line":21,"character":0},"end":{"line":33,"character":1}},"selectionRange":{"start":{"line":21,"character":23},"end":{"line":21,"character":37}}},{"name":"setup","kind":12,"range":{"start":{"line":35,"character":0},"end":{"line":80,"character":1}},"selectionRange":{"start":{"line":35,"character":5},"end":{"line":35,"character":10}}},{"name":"transmit","kind":12,"range":{"start":{"line":89,"character":0},"end":{"line":103,"character":1}},"selectionRange":{"start":{"line":89,"character":5},"end":{"line":89,"character":13}}},{"name":"loop","kind":12,"range":{"start":{"line":105,"character":0},"end":{"line":112,"character":1}},"selectionRange":{"start":{"line":105,"character":5},"end":{"line":105,"character":9}}}],"jsonrpc":"2.0"}Content-Length: 38

{"id":3,"result":null,"jsonrpc":"2.0"}Content-Length: 471

{"id":4,"result":{"contents":{"kind":"markdown","value":"### function `F`  \n\n---\nâ†’ `const arduino::__FlashStringHelper *`  \nParameters:  \n- `char const (\u0026)[25] A`\n\nC++11 F replacement declaration  \n\n---\n```cpp\ntemplate \u003c\u003e\nauto F\u003cchar const (\u0026)[25]\u003e(char const (\u0026A)[25])\n    -\u003e const arduino::__FlashStringHelper *\n```"},"range":{"start":{"line":56,"character":17},"end":{"line":56,"character":18}}},"jsonrpc":"2.0"}Content-Length: 769

{"id":5,"result":{"contents":{"kind":"markdown","value":"### function `initializeNoInterrupt`  \n\n---\nâ†’ `void`  \nParameters:  \n- `uint8_t ss`\n- `uint8_t rst = 255`\n\nInitiates and starts a sessions with a DW1000 without interrupt. If rst is not set or value 0xff, a soft resets (i.e. command triggered) are used and it is assumed that no reset line is wired.  \n@param[in] ss The SPI Selection pin used to identify the specific connection  \n@param[in] rst The reset line/pin for hard resets of ICs that connect to the Arduino. Value 0xff means soft reset.  \n\n---\n```cpp\n// In namespace DW1000Ng\nvoid initializeNoInterrupt(uint8_t ss, uint8_t rst = 255)\n```"},"range":{"start":{"line":55,"character":12},"end":{"line":55,"character":33}}},"jsonrpc":"2.0"}
<<<
Content-Length: 38

{"jsonrpc":"2.0","id":0,"result":null}
>>>
Content-Length: 143

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"title":"indexing","percentage":0,"kind":"begin"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"1/36","percentage":2.7777777777777777,"kind":"report"}},"jsonrpc":"2.0"}
<<<
Content-Length: 296

{"jsonrpc":"2.0","id":6,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 36

{"id":6,"result":[],"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"2/36","percentage":5.555555555555555,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"2/36","percentage":5.555555555555555,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"3/36","percentage":8.333333333333334,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"3/36","percentage":8.333333333333334,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"4/36","percentage":11.11111111111111,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"5/36","percentage":13.88888888888889,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"5/36","percentage":13.88888888888889,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"6/36","percentage":16.666666666666668,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"7/36","percentage":19.444444444444443,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"7/36","percentage":19.444444444444443,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"8/36","percentage":22.22222222222222,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 158

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"8/36","percentage":22.22222222222222,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 143

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"9/36","percentage":25,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 143

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"9/36","percentage":25,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"10/36","percentage":27.77777777777778,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"10/36","percentage":27.77777777777778,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"11/36","percentage":30.555555555555557,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"11/36","percentage":30.555555555555557,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"12/36","percentage":33.333333333333336,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"12/36","percentage":33.333333333333336,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"13/36","percentage":36.111111111111114,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"13/36","percentage":36.111111111111114,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"14/36","percentage":38.888888888888886,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"15/36","percentage":41.666666666666664,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"15/36","percentage":41.666666666666664,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"16/36","percentage":44.44444444444444,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"16/36","percentage":44.44444444444444,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"17/36","percentage":47.22222222222222,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"17/36","percentage":47.22222222222222,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 144

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"18/36","percentage":50,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 144

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"18/36","percentage":50,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"19/36","percentage":52.77777777777778,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"19/36","percentage":52.77777777777778,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"20/36","percentage":55.55555555555556,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"20/36","percentage":55.55555555555556,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"21/36","percentage":58.333333333333336,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"21/36","percentage":58.333333333333336,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"22/36","percentage":61.111111111111114,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"22/36","percentage":61.111111111111114,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"23/36","percentage":63.888888888888886,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 160

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"23/36","percentage":63.888888888888886,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"24/36","percentage":66.66666666666667,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"25/36","percentage":69.44444444444444,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"25/36","percentage":69.44444444444444,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"26/36","percentage":72.22222222222223,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"26/36","percentage":72.22222222222223,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 144

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"27/36","percentage":75,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 144

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"27/36","percentage":75,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"28/36","percentage":77.77777777777777,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"28/36","percentage":77.77777777777777,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"29/36","percentage":80.55555555555556,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"29/36","percentage":80.55555555555556,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"30/36","percentage":83.33333333333333,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"31/36","percentage":86.11111111111111,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"31/36","percentage":86.11111111111111,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"32/36","percentage":88.88888888888889,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"32/36","percentage":88.88888888888889,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"33/36","percentage":91.66666666666667,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"34/36","percentage":94.44444444444444,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 159

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"message":"35/36","percentage":97.22222222222223,"kind":"report"}},"jsonrpc":"2.0"}Content-Length: 107

{"method":"$/progress","params":{"token":"backgroundIndexProgress","value":{"kind":"end"}},"jsonrpc":"2.0"}
<<<
Content-Length: 226

{"jsonrpc":"2.0","id":7,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":58,"character":26}}}
>>>
Content-Length: 478

{"id":7,"result":{"contents":{"kind":"markdown","value":"### function `applyConfiguration`  \n\n---\nâ†’ `void`  \nParameters:  \n- `device_configuration_t config`\n\nApplies the target configuration to the DW1000  \n@param [in] config the configuration to apply to the DW1000  \n\n---\n```cpp\n// In namespace DW1000Ng\nvoid applyConfiguration(device_configuration_t config)\n```"},"range":{"start":{"line":58,"character":12},"end":{"line":58,"character":30}}},"jsonrpc":"2.0"}
<<<
Content-Length: 237

{"jsonrpc":"2.0","id":8,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":54,"character":9}}}
>>>
Content-Length: 36

{"id":8,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 298

{"jsonrpc":"2.0","id":9,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"range":{"start":{"line":54,"character":9},"end":{"line":54,"character":9}},"context":{"diagnostics":[]}}}
>>>
Content-Length: 36

{"id":9,"result":[],"jsonrpc":"2.0"}
<<<
Content-Length: 227

{"jsonrpc":"2.0","id":10,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///d%3A/RAK-Work/20210707/RAK13801/RAK13801-UWB-Library/examples/BasicSender/BasicSender.ino"},"position":{"line":54,"character":10}}}
>>>
Content-Length: 39

{"id":10,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 59

{"jsonrpc":"2.0","id":11,"method":"shutdown","params":null}
>>>
Content-Length: 39

{"id":11,"result":null,"jsonrpc":"2.0"}
<<<
Content-Length: 47

{"jsonrpc":"2.0","method":"exit","params":null}